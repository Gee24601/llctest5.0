<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>茶茶乐淘金记</title>
    <style>
        @font-face {
            font-family: 'Pixel';
            src: url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
            font-weight: normal;
            font-style: normal;
        }

        :root {
            --primary-color: #FF7E5F;
            --secondary-color: #8A7CFF;
            --accent-color: #FFD86B;
            --background-light: #342D6E;
            --background-dark: #1E1A4A;
            --text-light: #FFFFFF;
            --text-dark: #FFE26A;
            --accent-light: #FFE34D;
            --accent-dark: #FFD12E;
            --track-light: #5578FF;
            --track-dark: #4251CF;
            --ui-highlight: #FB5EEE;
            --ui-shadow: #371E73;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            image-rendering: pixelated;
        }

        body {
            font-family: 'Pixel', 'Courier New', monospace;
            overflow: hidden;
            background-color: var(--background-dark);
            color: var(--text-light);
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            letter-spacing: 1px;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 480px;
            overflow: hidden;
            border: 4px solid var(--primary-color);
            border-radius: 8px;
            margin: 0 auto;
            image-rendering: pixelated;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
        }

        @media (max-width: 800px) and (orientation: landscape) {
            #game-container {
                height: 300px;
            }
        }
        
        /* 竖屏模式下增加游戏高度，提供更大的跳跃空间 */
        @media (orientation: portrait) {
            #game-container {
                height: 70vh; /* 使用视口高度的70%，提供更大的游戏空间 */
                max-height: 600px;
            }
            
            #mobile-controls {
                bottom: 10px;
            }
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #141432;
        }

        .ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            display: flex;
            gap: 15px;
        }

        .stats-box {
            background-color: rgba(0, 0, 0, 0.7);
            color: var(--text-light);
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            padding: 6px 12px;
            border: 2px solid var(--primary-color);
        }

        .stats-icon {
            margin-right: 10px;
        }

        #score-container {
            border: 2px solid var(--primary-color);
        }
        
        #tea-container {
            border: 2px solid var(--secondary-color);
        }
        
        #distance-container {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: var(--text-light);
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            z-index: 10;
            padding: 6px 12px;
            border: 2px solid var(--accent-color);
            min-width: 100px;
            text-align: center;
        }

        #milestone-notification {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: var(--accent-light);
            border: 2px solid var(--primary-color);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 18px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s;
            text-align: center;
            pointer-events: none;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(30, 30, 63, 0.9);
            z-index: 100;
            color: white;
            text-align: center;
            padding: 20px;
            font-family: 'Comic Sans MS', 'Courier New', monospace;
        }

        #game-title {
            font-size: 42px;
            margin-bottom: 30px;
            color: #f0f261; /* 修改: 明亮的金黄色 */
            font-family: 'Pixel', 'Comic Sans MS', 'Courier New', monospace;
            font-weight: 800;
            position: relative;
            padding: 20px 0px;
            text-shadow: 3px 3px 0px rgba(226, 229, 216, 0.5); /* 修改: 更柔和的金色阴影 */
            letter-spacing: 2px;
            animation: titlePulse 3s ease-in-out infinite;
            /* 更清新可爱的描边效果 */
            -webkit-text-stroke: 2px rgba(197, 216, 173, 0.6); /* 修改: 金色描边 */
        }
        
        @keyframes titlePulse {
            0%, 100% {
                text-shadow: 3px 3px 0px rgba(204, 172, 13, 0.5); /* 修改: 金色阴影 */
                transform: scale(1);
            }
            50% {
                text-shadow: 4px 4px 0px rgba(204, 172, 13, 0.5); /* 修改: 金色阴影 */
                transform: scale(1.05);
            }
        }
        
        /* 竖屏模式优化 */
        @media (max-width: 480px), (max-height: 600px) {
            #game-title {
                font-size: 28px;
                margin-bottom: 15px;
                padding: 10px 0;
            }
            
            #start-screen .instructions,
            #game-over .score-box,
            .pixel-btn {
                font-size: 14px;
                padding: 10px 18px;
                max-width: 90%;
            }
            
            #final-score, 
            #high-score, 
            #final-distance {
                font-size: 16px;
            }
            
            h2 {
                font-size: 24px !important;
                margin-bottom: 5px !important;
            }
        }

        #game-logo {
            width: 120px;
            height: 120px;
            margin-bottom: 20px;
            image-rendering: pixelated;
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        .pixel-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 24px;
            margin-top: 20px;
            font-size: 18px;
            cursor: pointer;
            font-family: 'Pixel', 'Courier New', monospace;
            transition: transform 0.1s, box-shadow 0.1s, background-color 0.2s;
            position: relative;
            box-shadow: 0px 4px 0px 0px var(--ui-shadow);
            border-radius: 4px;
            letter-spacing: 1px;
            text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.3);
        }

        .pixel-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0px 6px 0px 0px var(--ui-shadow);
            background-color: var(--ui-highlight);
        }

        .pixel-btn:active {
            transform: translateY(2px);
            box-shadow: 0px 2px 0px 0px var(--ui-shadow);
        }

        /* 新增restart-btn特殊样式 */
        #restart-btn {
            margin-top: 5px;
            margin-bottom: 8px;
            background: linear-gradient(to right, #FF512F, #FF6B6B) !important;
            color: #FFFFFF !important;
            font-weight: bold;
            padding: 10px 28px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0px 4px 0px 0px rgba(178, 34, 34, 0.5),
                        0px 0px 10px rgba(255, 69, 0, 0.3);
            text-shadow: 0 2px 2px rgba(0, 0, 0, 0.3);
        }

        #game-over #restart-btn:hover {
            background: linear-gradient(to right, #FF512F, #FF6B6B) !important;
            transform: translateY(-2px);
            box-shadow: 0px 6px 0px 0px rgba(178, 34, 34, 0.5),
                        0px 0px 15px rgba(255, 69, 0, 0.4);
        }

        #game-over #restart-btn:active {
            transform: translateY(2px);
            box-shadow: 0px 2px 0px 0px rgba(178, 34, 34, 0.5),
                        0px 0px 5px rgba(255, 69, 0, 0.2);
        }

        #restart-btn:hover {
            background: linear-gradient(to right, #FF512F, #FF6B6B);
            transform: translateY(-2px);
            box-shadow: 0px 6px 0px 0px rgba(178, 34, 34, 0.5),
                        0px 0px 15px rgba(255, 69, 0, 0.4);
        }

        #restart-btn:active {
            transform: translateY(2px);
            box-shadow: 0px 2px 0px 0px rgba(178, 34, 34, 0.5),
                        0px 0px 5px rgba(255, 69, 0, 0.2);
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.15), 
                rgba(173, 216, 230, 0.25));
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
            padding: 20px 25px 30px 25px !important;  /* 调整内边距 */
            border-radius: 15px;
            text-align: center;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 8px;  /* 减小元素间距 */
            min-width: 250px;  /* 稍微减小最小宽度 */
            max-width: 90%;  /* 减小最大宽度比例 */
            max-height: 80vh;  /* 限制最大高度为视口高度的75% */
            overflow-y: auto;
            margin: 0;
        }
        #character-selection {
            margin: 5px 0;
            margin-top: 50px;        /* 新增: 减小与score-box的间距 */
            margin-bottom: 10px;    /* 新增: 增加与restart按钮的间距 */
        }
        #restart-btn {
            margin-top: 2px;        /* 新增: 控制与角色选择的间距 */
            margin-bottom: 2px;            /* 新增: 控制与署名的间距 */
        }
        #game-over h2 {
            color: rgba(255, 255, 255, 0.9);
            margin: 5px 0 6px 0;  /* 调整标题边距 */
            font-size: 20px;  /* 减小标题字体 */
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #game-over p {
            color: rgba(255, 255, 255, 0.8);
            margin: 5px 0;
            width: 100%;  /* 确保文字不会超出容器 */
            word-wrap: break-word;  /* 长文字自动换行 */
        }

        #game-over button {
            background: linear-gradient(to right, 
                rgba(255, 255, 255, 0.2), 
                rgba(173, 216, 230, 0.3));  /* 更柔和的按钮背景 */
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 25px;
            border-radius: 25px;
            color: rgba(255, 255, 255, 0.9);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.1);
            margin-bottom: 10px;
        }

        #game-over button:hover {
            transform: translateY(-2px);
            background: linear-gradient(to right, 
                rgba(255, 255, 255, 0.3), 
                rgba(173, 216, 230, 0.4));
            box-shadow: 0 6px 20px rgba(255, 255, 255, 0.15);
        }

        #game-over button:active {
            transform: translateY(0px);
        }

        /* 修改作者署名样式 */
        #game-over .author-credit,
        #game-over div[style*="margin-top: 10px"] {
            position: relative;
            width: 100%;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            padding: 5px 0;
            margin-top: 2px !important;  /* 减小上边距 */
            margin-bottom: 5px !important;  /* 减小下边距 */
            white-space: nowrap;
            overflow: visible;
        }
        
        .score-box {
            background-color: rgba(0, 0, 0, 0.6);
            padding: 5px 18px;  /* 减小内边距 */
            border-radius: 6px;
            margin: 6px 0;  /* 减小外边距 */
            margin-top: 2px;       /* 新增: 特别控制与标题的距离 */
            margin-bottom: 5px;    /* 新增: 增加与角色选择的间距 */
            border: 1px solid var(--accent-color);
            font-size: 12px;           /* 新增: 控制整体字体大小 */
        }

        #final-score {
            font-size: 20px;
            margin: 5px 0;
            color: var(--accent-light);
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5);
        }

        .instructions {
            font-size: 16px;
            margin-top: 15px;
            max-width: 300px;
            line-height: 1.8 !important; /* 增加行高 */
            white-space: normal; /* 允许正常换行 */
            background-color: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #c2a500; /* 修改: 金色边框 */
        }

        #game-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }

        #mobile-controls {
            display: none;
        }

        @media (max-width: 800px) {
            #mobile-controls {
                display: block;
                position: fixed;
                bottom: 20px;
                width: 100%;
                text-align: center;
                z-index: 50;
            }
            
            #jump-btn {
                background-color: var(--primary-color);
                color: white;
                border: none;
                padding: 15px 30px;
                font-size: 20px;
                border-radius: 50px;
                opacity: 0.9;
                box-shadow: 0px 4px 0px 0px #ad3f3a;
            }
            
            #jump-btn:active {
                transform: translateY(4px);
                box-shadow: 0px 0px 0px 0px #ad3f3a;
            }
        }
        
        /* Particle effects */
        @keyframes sparkle {
            0%, 100% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1); }
        }
        
        .sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: #FFFFFF;
            border-radius: 50%;
            animation: sparkle 1s ease-in-out infinite;
            pointer-events: none;
        }

        #tea-container {
            transition: all 0.3s ease;
        }

        /* 添加角色选择样式 */
        .character-options {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;  /* 减小下边距 */
        }
        .character-option {
            cursor: pointer;
            padding: 8px;  /* 减小内边距 */
            border: 2px solid transparent;  /* 减小边框宽度 */
            border-radius: 6px;
            background-color: rgba(0, 0, 0, 0.5);
            transition: all 0.3s;
            text-align: center;
            position: relative;
        }
        .character-option:hover {
            background-color: rgba(0, 0, 0, 0.7);
            transform: translateY(-5px);
        }
        .character-option.selected {
            border-color: var(--accent-color);
            box-shadow: 0 0 15px var(--accent-color);
        }
        .character-name {
            color: white;
            margin-top: 6px;  /* 减小上边距 */
            font-size: 12px;  /* 减小字体大小 */
        }
        .character-preview {
            width: 50px;  /* 减小预览图尺寸 */
            height: 50px;  /* 减小预览图尺寸 */
            margin: 0 auto;
            position: relative;
            overflow: hidden;
        }
        .sprite-preview {
            image-rendering: pixelated;
        }
        .character-silhouette {
            position: relative;
            width: 50px;  /* 减小剪影尺寸 */
            height: 50px;  /* 减小剪影尺寸 */
        }
        .silhouette {
            filter: brightness(0);
            opacity: 0;
        }
        .question-mark {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: var(--accent-color);
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.7);
        }
        .unlock-hint {
            position: absolute;
            bottom: -30px;  /* 增加底部间距 */
            left: 0;
            right: 0;
            font-size: 12px;
            color: var(--accent-light);
        }
        .character-option.locked {
            cursor: not-allowed;
            opacity: 0.8;
        }
        .character-option.locked:hover {
            transform: none;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        .shake {
            animation: shake 0.5s;
        }
        .unlock-notification {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--accent-color);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            color: white;
            z-index: 200;
            animation: popup 0.5s, fadeout 0.5s 3s forwards;
        }
        .unlock-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }
        .unlock-message {
            font-size: 24px;
            color: var(--accent-light);
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        @keyframes popup {
            from { transform: translate(-50%, -50%) scale(0); }
            to { transform: translate(-50%, -50%) scale(1); }
        }
        @keyframes fadeout {
            from { opacity: 1; }
            to { opacity: 0; }
        }
    </style>
</head>
<body>
    <!-- 添加网站图标 -->
    <link rel="icon" type="image/png" href="favicon.png">

    <!-- 添加加载提示 -->
    <div id="loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">游戏加载中...</div>
    </div>

    <style>
    /* 添加加载动画样式 */
    #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #1E1A4A;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 9999;
    }

    .loading-spinner {
        width: 50px;
        height: 50px;
        border: 5px solid #FFD86B;
        border-top: 5px solid transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .loading-text {
        margin-top: 20px;
        color: #FFFFFF;
        font-family: 'Pixel', monospace;
    }
    </style>

    <script>
    // 添加资源预加载
    window.addEventListener('load', function() {
        // 隐藏加载屏幕
        document.getElementById('loading-screen').style.display = 'none';
    });

    // 添加离线缓存支持
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('sw.js')
            .then(registration => console.log('ServiceWorker registered'))
            .catch(error => console.log('ServiceWorker error:', error));
    }
    </script>

    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div class="ui-container">
            <div id="score-container" class="stats-box">
                <div class="stats-icon">🏅</div>
                <span id="score">0</span>
            </div>
            <div id="tea-container" class="stats-box">
                <div class="stats-icon">🍵</div>
                <span id="tea-count">2</span>
            </div>
        </div>
        <div id="distance-container" class="stats-box">
            <span id="distance">0</span> 米
        </div>
        <div id="milestone-notification">里程碑: 3000米!</div>
        <div id="start-screen">
            <h1 id="game-title">茶茶乐淘金记</h1>
            <div class="instructions">
                与小乐小茶一起奔跑，跳过障碍，赢得金牌！<br>
                <span style="color: var(--accent-light);">空格键/点击屏幕</span> 进行跳跃
            </div>
            <div id="game-controls">
                <button id="start-btn" class="pixel-btn">开始游戏</button>
                <div style="margin-top: 15px; font-size: 14px; color: var(--accent-light);">BY：刺</div>
            </div>
        </div>
        <div id="game-over">
            <h2 style="font-size: 22px; margin-bottom: 0px; color: var(--accent-light);">游戏结束</h2>
            <div class="score-box">
                <div id="final-score">金牌数量: 0</div>
                <div id="high-score" style="color: var(--accent-light);">最高金牌数量: 0</div>
                <div id="final-distance" style="margin-top: 3px;">距离: 0 米</div>
            </div>
            <div id="character-selection" style="margin: 5px 0;">
                <h3 style="margin-bottom: 5px; color: var(--accent-light);font-size: 16px;">选择角色</h3>
                <div class="character-options">
                    <div class="character-option selected" data-character="sprite">
                        <img src="sprite.png" style="width: 50px; height: 50px; object-fit: contain;">
                        <div class="character-name">小乐小茶</div>
                    </div>
                    <div class="character-option" data-character="sprite02">
                        <img src="sprite02.png" style="width: 50px; height: 50px; object-fit: contain;">
                        <div class="character-name">新角色</div>
                    </div>
                </div>
            </div>
            <button id="restart-btn" class="pixel-btn" style="margin-top: 3px; margin-bottom: 3px;">再玩一次</button>
            <div class="author-credit" style="margin-top: 3px; font-size: 12px; color: var(--accent-light);">BY：刺</div>
        </div>
    </div>

    <div id="mobile-controls">
        <button id="jump-btn">跳跃</button>
    </div>

    <script>
        // Game setup
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreDisplay = document.getElementById('final-score');
        const highScoreDisplay = document.getElementById('high-score');
        const finalDistanceDisplay = document.getElementById('final-distance');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const jumpBtn = document.getElementById('jump-btn');
        const milestoneNotification = document.getElementById('milestone-notification');

        // Set canvas size
        canvas.width = 800;
        canvas.height = 480;
        
        // Game state
        let gameRunning = false;
        let gameSpeed = 5;
        let gravity = 0.5;
        let score = 0;
        let highScore = 0;
        let distance = 0;
        let frameCount = 0;
        let lastMilestone = 0;
        const distanceDisplay = document.getElementById('distance');
        
        // 添加角色解锁状态管理
        function saveUnlockStatus() {
            // 使用localStorage保存角色解锁状态
            localStorage.setItem('characterUnlocked', JSON.stringify(window.characterUnlocked));
        }

        function loadUnlockStatus() {
            // 从localStorage加载角色解锁状态
            const savedStatus = localStorage.getItem('window.characterUnlocked');
            if (savedStatus) {
                try {
                    characterUnlocked = JSON.parse(savedStatus);
                } catch (e) {
                    // 如果解析出错，使用默认值
                    window.characterUnlocked = {
                        'sprite': true,
                        'sprite02': false
                    };
                }
            }
        }
        
        // 视图/相机设置
        let cameraY = 0; // 相机垂直偏移量
        let targetCameraY = 0; // 目标相机位置

        // Background state
        let currentBgStage = 0;
        let activeSceneName = null; // Track which scene is currently active
        let gameScene = 'sakura'; // Default game scene
        let clouds = []; // Cloud array
        let fireworksCity = []; // 定义fireworksCity变量
        
        const bgStages = [
            { name: "夜间体育场", color1: "#0C0C24", color2: "#1E1E3F", groundColor: "#343A6B" },
            { name: "一起爬山吧！", color1: "#1A2C50", color2: "#4B3F72", groundColor: "#454F7A" },
            { name: "雨夜海盗船", color1: "#0A1B29", color2: "#1A2C3E", groundColor: "#253545" }, // 新增场景
            { name: "海底潜艇", color1: "#051525", color2: "#0E2B4E", groundColor: "#1A3A5E" },
            { name: "樱花庭院", color1: "#362852", color2: "#4A3B65", groundColor: "#443A68" },
            { name: "星空流星雨", color1: "#050A24", color2: "#1A1559", groundColor: "#232654" },
            { name: "一起放烟花", color1: "#0F0618", color2: "#2A0A44", groundColor: "#26104E" }
        ];

        // Special background elements for each milestone
        const bgElements = [
            { 
                distance: 1200, 
                name: "mountains",
                setup: createMountains, 
                draw: drawMountains,
                description: "一起登山！", 
                color: "#ffcc00" 
            },
            {
                distance: 3700,  // 在山区和潜艇之间的距离
                name: "pirateShip",
                setup: createPirateShipScene,
                draw: drawPirateShipScene,
                description: "雨夜行船！",
                color: "#4682B4"
            },
            { 
                distance: 6700, 
                name: "pirate",
                setup: createPirateScene, 
                draw: drawPirateScene,
                description: "海底两万里！", 
                color: "#4682B4" 
            },
            { 
                distance: 10200, 
                name: "cherryBlossom",
                setup: createCherryBlossom, 
                draw: drawCherryBlossom,
                description: "恰如天上月！", 
                color: "#FF9CCB" 
            },
            { 
                distance: 14200, 
                name: "meteors",
                setup: createMeteorShower, 
                draw: drawMeteors,
                description: "一起来看流星雨！", 
                color: "#FF5252" 
            },
            { 
                distance: 17700, 
                name: "fireworks",
                setup: createFireworks, 
                draw: drawFireworks,
                description: "一起放烟花！", 
                color: "#FF4081" 
            }
        ];
        
        // Background element containers
        let mountains = [];
        let pirateElements = [];
        let cherrySakura = [];
        let gardenElements = [];
        let meteors = [];
        let fireworks = [];

        // Animation state
        let runningAnimationFrame = 0;
        let runningAnimationSpeed = 3; // frames per animation step (faster)
        let animationTimer = 0;
        let bodyTilt = 0; // For body tilt animation

        // 地图相关变量
        let currentMap = "initialMap"; // 添加：定义当前选择的地图变量，默认为初始地图
        // 添加：定义地图解锁状态变量
        let mapUnlocked = {
            initialMap: true,  // 初始地图默认解锁
            newMap: false      // 新地图默认未解锁
        };
        const MAP_UNLOCK_SCORE = 188;  // 添加：定义解锁新地图所需的金牌数量
        const mapConfigs = {  // 添加：定义不同地图的配置对象
            initialMap: {  // 添加：初始地图配置
                name: "蜜月旅行",  // 添加：地图显示名称
                description: "包含多种精彩场景的冒险之旅",  // 添加：地图描述
                bgElements: bgElements  // 添加：使用原有的bgElements
            },
            newMap: {  // 添加：新地图配置
            name: "末日旅行",  // 添加：地图显示名称
            description: "纯净的夜空背景",  // 添加：地图描述
            bgElements: [],  // 添加：新地图没有特殊场景，数组为空
            unlockScore: MAP_UNLOCK_SCORE  // 添加：解锁所需分数
    }
};
        // 添加：背景切换相关配置
        const BACKGROUND_CHANGE_DISTANCE = 3000; // 每3000米切换一次背景 【说明】：定义背景切换的距离间隔
        const BACKGROUNDS_SEQUENCE = ['bg1', 'bg2', 'bg3', 'bg4', 'bg5']; // 背景切换顺序 【说明】：定义背景切换的顺序

// 添加：背景切换状态
        let currentBackgroundState = {
            current: 'bg1',         // 当前显示的背景 【说明】：当前正在显示的背景
            next: null,             // 下一个要显示的背景 【说明】：即将切换到的背景
            fadeProgress: 0,        // 过渡进度(0-1) 【说明】：控制过渡动画的进度
            isFading: false,        // 是否正在过渡中 【说明】：标记是否正在执行过渡动画
            fadeDuration: 60,       // 过渡持续的帧数 【说明】：控制过渡动画的速度
            lastChangeDistance: 0   // 上次切换的距离 【说明】：记录上次切换背景的距离
        }; // 【说明】：管理背景切换的状态和过渡效果
        // Sound effects
// 超级马里奥风格的金币收集音效（极简版本）
        const collectSound = new Audio('shoujijinbi.mp3');        
        collectSound.volume = 0.2;

        const gameoverSound = new Audio('data:audio/wav;base64,UklGRrQDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YZADAABp/5X/0v/W/7//pf9e/0//ev+S/7j/3//8/wMABwAFABUAQgB7ALkA9QAiAUMBWQFnAWABUgFCAT0BQAFFAUYBQQEsAQkB1QCSAFUAGwDd/53/Yf8h/+z+tf6L/nD+X/5V/lr+cf6V/tD+Gf9o/7j/DQBhAK8A+gA+AWQBeQF+AW4BTgEjAesAoQBUAAgAuf9i/w3/uP5j/g/+vf1r/SD91/yX/Fj8KPwH/On75vvk+/370/vX++v7A/wk/FP8hvzA/Az9WP2j/e/9Qf6U/uj+Pf+T/+b/OACPAOMAOQGCAbsBDQI6Ilo2wfrt+ZT5pflK+gf72/o5+lf6CPyR/T395vwP/Z3+SADDAD4BgQJnA/IDXQSYBOMEyQTfBCMFNgUJBaMEPARqAwICwgDo/yT/TP6X/QT9c/zn+3P7FPvI+qH6jfqS+qr64/oj+3T72PtB/Lf8NP23/Tn+xf5M/9b/YQDtAHYB/gGHAvgCaQPKAycEhQTdBCwFcwW3BfsFFwY8Bl4GcQaLBpoGqQaqBrEGsAaxBq0GnwaTBosGdwZkBk0GOAYbBvYF0QWlBW8FOgX+BL4EegQ5BPcDvgN/AzsD9QLHAokCSQILAskBewE5AfYAuAByACsA4/+g/1j/Hf/c/pn+Xf4i/ub9r/19/Uj9FP3s/LX8i/xa/DX8Efzu+9X7vvuq+5H7gvt0+2r7YPte+177avt6+4r7pvvF++f7D/w4/Gf8mPzK/P38MP1m/Z79z/0K/kL+e/62/u/+KP9f/5r/0/8NAEIAeQCuAOMACwE4AVUBiwGxAc8B8AEAASQB1ACXAFsAKQDbAGkB/gGPAiADjQMiBJYEFgWKBe4FYQa4BgMHTweLB8MH+QcgCD0IWwhrCHsIfwiJCI0IlQiPCIoIeghwCFMIPAgiCPsH3AfBB6IHgQdhBz0HEQfsBr4GkAZqBjQGCQbQBaAFagUvBfcEvgSFBFAEEgTYA54DZQM3A/0C0AKFAkwCFgLgAasBagE7AfkAvACEAEsAEQDb/5j/bP8g/+f+pf5x/jj+Dv7V/a79ev1E/Rf96/y7/JT8afw//Bj87fvN+637jPt0+177Uvs9+zT7I/sl+yP7KPst+zf7Qvtc+2n7hfud+8D73/sI/C38U/x+/Kn81PwD/S/9XP2Q/b39+P0i/lf+if7A/vL+Lf9g/5n/yP8EADcAcACmANsAEgFGAYYBsAHzANkBEQLPAikDnwMRBG8E3QQwBYYF0AUgBmkGuQb9Bj0HfAfBBwEIQAh7CK4I3QgACTAJUwl1CZUJsAnECeEJ7QkBCgkKGQofCjYKPwpDClcKVwpmCmUKbApvCm8KcQpuCnQKcgp5CoAKiQqPCpiKnQqkCp8KlQqRCo0KkgqLCowKfQp5CnUKYwpvClkKRQpJCjMKKgo');
        gameoverSound.volume = 0.3;


// 添加：新地图背景图片加载
        const newMapBackgrounds = {
        bg1: { image: new Image(), src: 'xinditu01.png' },
        bg2: { image: new Image(), src: 'xinditu02.png' },
        bg3: { image: new Image(), src: 'xinditu03.png' },
        bg4: { image: new Image(), src: 'xinditu04.png' },
        bg5: { image: new Image(), src: 'xinditu05.png' }
        }; // 【说明】：创建新地图的背景图片对象集合

        collectSound.addEventListener('error', function() {
        console.error('无法加载金币音效文件shoujijinbi.mp3，请检查文件是否存在');
        });

        // 初始化加载所有背景图片
        Object.values(newMapBackgrounds).forEach(bg => {
            bg.image.src = bg.src;
        }); // 【说明】：预加载所有背景图片所有背景图片，并在加载完成时分析颜色

        // 添加GM指令处理函数
        function handleGMCommand(key) {
            if (key === 'g' || key === 'G') {
                score += 300;
                scoreDisplay.textContent = score;
                
                if (score > highScore) {
                    highScore = score;
                    highScoreDisplay.textContent = "最高金牌数量: " + highScore;
                }
                
                if (score >= UNLOCK_SCORE && !window.characterUnlocked.sprite02) {
                    window.characterUnlocked.sprite02 = true;
                    saveUnlockStatus();
                    showUnlockNotification('小嘎小哞已解锁！');
                    
                    if (gameOverScreen.style.display === 'flex') {
                        updateCharacterSelectionUI();
                    }
                }
                
                console.log('GM Command: Added 300 to score');
                
            } else if (key === 'p' || key === 'P') {
                // 快速呼出海盗船场景
                console.log('GM Command: 切换到海盗船场景');
                
                // 设置距离到海盗船场景的里程碑
                distance = 7500;
                distanceDisplay.textContent = Math.floor(distance);
                
                // 手动触发场景切换
                checkMilestones();
                
                // 显示提示
                showMilestoneNotification("开发模式: 海盗船场景已加载", "#4682B4");
            }
            else if (key === 'm' || key === 'M') {
    // 切换新地图解锁状态
                    mapUnlocked.newMap = !mapUnlocked.newMap;
                    saveMapUnlockStatus();
    
    // 显示提示
                    const status = mapUnlocked.newMap ? "已解锁" : "已锁定";
                    showMilestoneNotification(`末日旅行: ${status}`, "#4682B4");
            }
            // [新增] 按R键重置角色解锁状态
            else if (key === 'r' || key === 'R') {
        // 重置角色解锁状态
            characterUnlocked = {
            'sprite': true,     // 初始角色保持解锁
            'sprite02': false   // 新角色重置为未解锁
        };
        // 保存到localStorage
        saveUnlockStatus();
        // 更新UI
        updateCharacterSelectionUI();
        // 显示提示
        showMilestoneNotification("已重置角色解锁状态", "#FF6B6B");
        console.log('GM Command: 角色解锁状态已重置');
    }
    // [新增] 按L键查看当前解锁状态
    else if (key === 'u' || key === 'U') {
    // 直接设置解锁状态
    window.characterUnlocked.sprite02 = true;
    
    // 保存到localStorage
    saveUnlockStatus();
    
    // 强制更新UI
    updateCharacterSelectionUI();
    
    // 输出调试信息
    console.log('调试命令: 强制解锁角色', window.characterUnlocked);
    showMilestoneNotification("调试: 已强制解锁角色", "#4682B4");
    
    // 输出DOM状态
    const characterElement = document.querySelector('.character-option[data-character="sprite02"]');
    console.log('角色元素类名:', characterElement.className);
    console.log('角色预览HTML:', document.querySelector('.character-option[data-character="sprite02"] .character-preview').innerHTML);
}
    else if (key === 'l' || key === 'L') {
        console.log('当前角色解锁状态:', characterUnlocked);
        const status = characterUnlocked.sprite02 ? "已解锁" : "未解锁";
        showMilestoneNotification(`小嘎小哞: ${status}`, "#4682B4");
    }
}

// 修改现有的键盘事件监听器
window.addEventListener('keydown', function(e) {
    if (!gameRunning && (e.code === 'Space' || e.key === ' ')) {
        startGame();
    }
    
    // 添加GM指令检测
    if (gameRunning) {
        handleGMCommand(e.key);
    }
});

// Characters
const playerHeight = 100;
const playerWidth = 85;
const groundHeight = 30;
const GROUND_Y = canvas.height - playerHeight - groundHeight + 55; // 将+20改为+50，使角色更贴近地面

let player = {
    x: 50,
    y: GROUND_Y,
    width: playerWidth,
    height: playerHeight,
    jumping: false,
    jumpForce: 10,           // 增加基础跳跃力（从11改为5）
    maxJumpForce: 18,        // 增加最大跳跃力（从16改为19）
    jumpTimeStart: 0,
    maxJumpHoldTime: 370,    // 增加最大蓄力时间（从300改为400）
    minJumpHoldTime: 50,
    yVelocity: 0,
    frameX: 0,
    frameY: 0,
    animationSpeed: 0.15,
    animationTimer: 0,
    bodyTilt: 0,
    runningPhase: 0,
    invincible: false,
    invincibleTimer: 0,
    invincibleDuration: 5000, // 无敌时间5秒
    sparkles: [], // 用于存储特效粒子
    glowIntensity: 0, // 发光强度
    teaCollectFlash: 0 // 收集茶道具时的闪光效果
};

// 加载新的精灵图
const characterSprite = new Image();
characterSprite.src = "sprite.png";

// 精灵图动画配置
const spriteConfig = {
    frameWidth: 1280,
    frameHeight: 760,
    totalFrames: 10,
    framesPerRow: 5,
    rows: 2,
    runFrames: {row: 0, frames: [0, 1, 2, 3, 4]},
    jumpFrames: {row: 1, frames: [0, 1, 2, 3, 4]}
};

// Color palette for pixel art
const palette = {
    background: '#141432',
    ground: '#4466CC',
    koalaBody: '#A0A0A0',
    koalaEar: '#808080',
    koalaEarInner: '#FFCBC0',
    koalaEye: '#000000',
    koalaEyeArea: '#FFFFFF',
    koalaNose: '#000000',
    kittyBody: '#FFC0CB',
    kittyBodyDark: '#FF9CAC',
    kittyFace: '#FFFFFF',
    kittyBow: '#FF0000',
    kittyEye: '#000000',
    kittyNose: '#FFFF00',
    gold: '#FFD700',
    goldShine: '#FFFFFF',
    goldRibbon: '#CC0000',
    teaColor: '#66CC66',
    teaCup: '#FFFFFF',
    obstacleColors: {
        horse: '#D2B48C',
        horseLeg: '#8B4513',
        horsePadding: '#CD853F',
        horseHandle: '#A0522D',
        pool: '#1E90FF',
        poolEdge: '#FFFFFF',
        poolWave: '#ADD8E6',
        hurdle: '#D2691E',
        hurdleSupport: '#A52A2A',
        hurdleTop: '#FF4500',
        hurdleStripe: '#FFFFFF',
        rail: '#696969',
        railPost: '#A9A9A9',
        railTop: '#C0C0C0',
        railLine: '#808080',
        beam: '#6D4C41',
        beamSupport: '#5D4037',
        beamPad: '#8D6E63',
        pommelHorse: '#BC8F8F',
        pommelHandles: '#8B4513',
        divingBoard: '#795548',
        divingSpring: '#8D6E63',
        platform: '#795548',
        bar: '#FFD700',
        ring: '#FF5722'
    }
};

// Obstacles
const obstacleTypes = {
    HORSE: 0,
    POOL: 1,
    HURDLE: 2,
    RAIL: 3,
    BALANCE_BEAM: 4,
    POMMEL_HORSE: 5,
    DIVING_BOARD: 6,
    RINGS: 7,
    BARREL: 8,
    BIRD: 9,
    CRATE: 10,
    CACTUS: 11,
    SNAKE: 12,
    PARALLEL_BARS: 13,
    WATER_JUMP: 14,
    HIGH_JUMP: 15,
    UNEVEN_BARS: 16
};

let obstacles = [];
const obstacleHeight = {
    [obstacleTypes.HORSE]: 50,
    [obstacleTypes.POOL]: 20,
    [obstacleTypes.HURDLE]: 40,
    [obstacleTypes.RAIL]: 30,
    [obstacleTypes.BALANCE_BEAM]: 30,
    [obstacleTypes.POMMEL_HORSE]: 50,
    [obstacleTypes.DIVING_BOARD]: 40,
    [obstacleTypes.RINGS]: 70,
    [obstacleTypes.BARREL]: 35,
    [obstacleTypes.BIRD]: 20,
    [obstacleTypes.CRATE]: 40,
    [obstacleTypes.CACTUS]: 40,
    [obstacleTypes.SNAKE]: 15
};
const obstacleWidth = {
    [obstacleTypes.HORSE]: 60,
    [obstacleTypes.POOL]: 100,
    [obstacleTypes.HURDLE]: 20,
    [obstacleTypes.RAIL]: 80,
    [obstacleTypes.BALANCE_BEAM]: 120,
    [obstacleTypes.POMMEL_HORSE]: 70,
    [obstacleTypes.DIVING_BOARD]: 50,
    [obstacleTypes.RINGS]: 40,
    [obstacleTypes.BARREL]: 35,
    [obstacleTypes.BIRD]: 30,
    [obstacleTypes.CRATE]: 40,
    [obstacleTypes.CACTUS]: 25,
    [obstacleTypes.SNAKE]: 40
};

// Collectibles
let medals = [];
const medalSize = 20;
const collectibleTypes = {
    GOLD: 0,
    TEA: 1
};

// Player stats
let teaCount = 2; // Start with 2 tea items

// Game background elements
const cloudPositions = [];
for (let i = 0; i < 6; i++) {
    cloudPositions.push({
        x: Math.random() * canvas.width,
        y: Math.random() * 100 + 20,
        width: Math.random() * 60 + 40,
        height: Math.random() * 30 + 20, // Added height for more natural clouds
        puffs: [], // Will contain individual cloud parts
        speed: Math.random() * 0.5 + 0.2
    });
    
    // Initialize cloud puffs for more natural shapes
    const cloud = cloudPositions[i];
    const puffCount = 3 + Math.floor(Math.random() * 3);
    for (let j = 0; j < puffCount; j++) {
        cloud.puffs.push({
            x: cloud.x + (j / (puffCount - 1)) * cloud.width,
            y: cloud.y + Math.sin(j * 0.8) * (cloud.height * 0.2),
            size: cloud.height * (0.6 + Math.random() * 0.4)
        });
    }
}

// Stars for background
const stars = [];
for (let i = 0; i < 70; i++) {
    stars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * (canvas.height - 100),
        size: Math.random() * 2 + 1,
        twinkle: Math.random() * 100
    });
}

// Track markings
const trackMarkings = [];
const markingWidth = 30;
const markingGap = 50;
for (let x = 0; x < canvas.width + markingWidth + markingGap; x += markingWidth + markingGap) {
    trackMarkings.push(x);
}

// Create particle system for effects
const particles = [];

function createParticles(x, y, color, count = 10) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 3,
            vy: (Math.random() - 0.5) * 3,
            color: color,
            size: Math.random() * 3 + 1,
            life: Math.random() * 30 + 10
        });
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.life--;
        
        if (particle.life <= 0) {
            particles.splice(i, 1);
        }
    }
}

function drawParticles() {
    for (const particle of particles) {
        ctx.globalAlpha = particle.life / 40;
        ctx.fillStyle = particle.color;
        ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
    }
    ctx.globalAlpha = 1;
}

// 添加绘制轨道/地面函数
function drawTrack() {
    // 获取当前背景阶段
    const bg = bgStages[currentBgStage];
    
    // 判断当前场景
    const isUnderwaterScene = activeSceneName === "pirate";
    const isPirateShipScene = activeSceneName === "pirateShip"; 
    const isCherryBlossomScene = activeSceneName === "cherryBlossom"; // 添加樱花场景检测

    // 添加：判断是否为新地图
    const isNewMap = currentMap === "newMap";
    
    if (isNewMap) {
        // 手动设置颜色
        let primaryColor = '#D0D0D0';  // 默认浅灰色
        let secondaryColor = '#B0B0B0'; // 默认深灰色
        
        // 根据当前背景选择颜色
        if (currentBackgroundState && currentBackgroundState.current) {
            switch(currentBackgroundState.current) {
                case 'bg1':
                    primaryColor = '#161c37';  // 您指定的颜色 - 深蓝色
                    secondaryColor = '#12162c'; // 稍暗一些
                    break;
                case 'bg2':
                    primaryColor = '#16212d';  // 您指定的颜色 - 深青色
                    secondaryColor = '#121a24'; // 稍暗一些
                    break;
                case 'bg3': 
                    primaryColor = '#172d57';  // 您指定的颜色 - 蓝色
                    secondaryColor = '#132446'; // 稍暗一些
                    break;
                case 'bg4':
                    primaryColor = '#0f1137';  // 您指定的颜色 - 深紫色
                    secondaryColor = '#0f1137'; // 稍暗一些
                    break;
                case 'bg5':
                    primaryColor = '#17072d';  // 您指定的颜色 - 紫色
                    secondaryColor = '#130624'; // 稍暗一些
                    break;
                default:
                    // 若未知背景，使用默认深蓝色
                    primaryColor = '#161c37';
                    secondaryColor = '#12162c';
            }
        }
        
        // 创建从背景底部到跑道的渐变
        const trackGradient = ctx.createLinearGradient(0, canvas.height - 30, 0, canvas.height);
        trackGradient.addColorStop(0, primaryColor);   // 主色调
        trackGradient.addColorStop(1, secondaryColor); // 次色调
        
        // 绘制主要跑道
        ctx.fillStyle = trackGradient;
        ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
        
        // 添加跑道标记 - 纯白色线条，在深色背景上更加明显
        ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
    }
    else if (isPirateShipScene) {
        // 创建从暴风雨海面到跑道的渐变
        const trackGradient = ctx.createLinearGradient(0, canvas.height - 30, 0, canvas.height);
        trackGradient.addColorStop(0, '#334759'); // 与海盗船场景底部颜色相匹配
        trackGradient.addColorStop(1, '#253545'); // 与海盗船跑道颜色相匹配
        
        // 绘制主要跑道
        ctx.fillStyle = trackGradient;
        ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
        
        // 添加雨夜跑道标记 - 更加明显的白色标记
        ctx.fillStyle = "rgba(220, 220, 220, 0.3)";
    }
    else if (isUnderwaterScene) {
        // 创建从深海蓝到跑道蓝的渐变
        const trackGradient = ctx.createLinearGradient(0, canvas.height - 30, 0, canvas.height);
        trackGradient.addColorStop(0, '#0d4a6e'); // 与海底背景底部颜色相匹配
        trackGradient.addColorStop(1, '#1a3a5e'); // 原始跑道颜色
        
        // 绘制主要跑道
        ctx.fillStyle = trackGradient;
        ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
        
        // 添加水下跑道标记 - 半透明白色，模拟水下效果
        ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
    }
    else if (isCherryBlossomScene) {
        // 创建樱花场景的跑道渐变
        const trackGradient = ctx.createLinearGradient(0, canvas.height - 30, 0, canvas.height);
        trackGradient.addColorStop(0, '#513B65'); // 与樱花背景底部颜色相匹配
        trackGradient.addColorStop(1, '#443A68'); // 原始樱花场景跑道颜色
        
        // 绘制主要跑道
        ctx.fillStyle = trackGradient;
        ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
        
        // 添加樱花场景跑道标记 - 淡粉色标记
        ctx.fillStyle = "rgba(255, 220, 230, 0.4)";
    } else {
        // 非水下场景正常绘制
        // 绘制主要的地面/轨道
        ctx.fillStyle = bg.groundColor;
        ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
        
        // 添加轨道标记线 - 普通场景用白色
        ctx.fillStyle = "#FFFFFF";
    }
    
    // 更新和绘制轨道标记线
    for (let i = 0; i < trackMarkings.length; i++) {
        // 移动标记线
        trackMarkings[i] -= gameSpeed;
        
        // 如果标记线移出屏幕，将其重新放置到屏幕右侧
        if (trackMarkings[i] < -markingWidth) {
            trackMarkings[i] = canvas.width + (trackMarkings[i] + markingWidth) % (markingWidth + markingGap);
        }
        
        // 绘制标记线 - 根据场景调整样式
        if (isUnderwaterScene || isPirateShipScene || isCherryBlossomScene || isNewMap) {
            ctx.fillRect(trackMarkings[i], canvas.height - 28, markingWidth, 4);
        } else {
            ctx.fillRect(trackMarkings[i], canvas.height - 28, markingWidth, 3);
        }
    }
    
    // 轨道边缘高光效果 - 使地面看起来更有深度
    if (isPirateShipScene) {
        ctx.fillStyle = "rgba(180, 210, 230, 0.15)";
    } 
    else if (isUnderwaterScene) {
        ctx.fillStyle = "rgba(160, 210, 230, 0.15)";
    } 
    else if (isCherryBlossomScene) {
        ctx.fillStyle = "rgba(255, 220, 230, 0.15)";
    }
    else if (isNewMap) {
        // 新地图使用亮灰色高光，与所有深色跑道都有良好对比
        ctx.fillStyle = "rgba(220, 220, 220, 0.2)";
    } else {
        ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
    }
    ctx.fillRect(0, canvas.height - 30, canvas.width, 2);
    
    // 海底场景特有的水波效果
    if (isUnderwaterScene) {
        // 水波纹动画
        ctx.fillStyle = "rgba(160, 210, 230, 0.1)";
        ctx.beginPath();
        ctx.moveTo(0, canvas.height - 27);
        
        for (let x = 0; x < canvas.width; x += 20) {
            const y = canvas.height - 27 + Math.sin((x + frameCount * 2) * 0.05) * 2;
            ctx.lineTo(x, y);
        }
        
        ctx.lineTo(canvas.width, canvas.height - 27);
        ctx.lineTo(canvas.width, canvas.height - 24);
        ctx.lineTo(0, canvas.height - 24);
        ctx.closePath();
        ctx.fill();
        
        // 偶尔生成气泡从地面升起
        if (Math.random() < 0.03) {
            const bubbleX = Math.random() * canvas.width;
            pirateElements.push({
                type: 'bubble',
                x: bubbleX,
                y: canvas.height - 10,
                size: 1 + Math.random() * 3,
                speed: 0.3 + Math.random() * 0.8,
                wobble: 0.3 + Math.random() * 0.8,
                phase: Math.random() * Math.PI * 2
            });
        }
    }
}

// 添加：检查是否需要切换背景
function checkBackgroundChange() {
    if (currentMap !== "newMap") return; // 只在新地图中执行 【说明】：确保只在新地图中切换背景
    
    // 计算当前应该显示哪个背景
    const currentCycle = Math.floor(distance / BACKGROUND_CHANGE_DISTANCE); // 【说明】：计算当前距离对应的循环位置
    const cyclePosition = currentCycle % (BACKGROUNDS_SEQUENCE.length + 1); // 【说明】：计算在一个完整循环中的位置
    
    // 确定应该显示的背景
    let targetBackground;
    if (cyclePosition === BACKGROUNDS_SEQUENCE.length) {
        targetBackground = 'bg5'; // 最后一个3000米区间保持显示bg5 【说明】：特殊处理最后一个区间
    } else {
        targetBackground = BACKGROUNDS_SEQUENCE[cyclePosition]; // 【说明】：根据循环位置选择对应背景
    }
    
    // 检查是否需要开始新的过渡
    if (!currentBackgroundState.isFading && 
        targetBackground !== currentBackgroundState.current && 
        Math.floor(distance / BACKGROUND_CHANGE_DISTANCE) !== currentBackgroundState.lastChangeDistance) {
        
        // 开始新的背景过渡
        startBackgroundTransition(targetBackground);
        
        // 记录当前切换距离
        currentBackgroundState.lastChangeDistance = Math.floor(distance / BACKGROUND_CHANGE_DISTANCE);
        
        // 显示切换提示 - 使用自定义场景名称
        const backgroundNames = {
            'bg1': '落日穹顶',
            'bg2': '赛博黄昏',
            'bg3': '投奔怒海',
            'bg4': '深海迷航',
            'bg5': '异海洋'
    };
    
        const sceneName = backgroundNames[targetBackground] || `场景${BACKGROUNDS_SEQUENCE.indexOf(targetBackground) + 1}`;
        showMilestoneNotification(sceneName, "#4682B4");
        } // 【说明】：检查当前距离，决定是否需要切换背景
    }
// 添加：开始背景过渡效果
function startBackgroundTransition(nextBackground) {
    currentBackgroundState.next = nextBackground; // 【说明】：设置目标背景
    currentBackgroundState.fadeProgress = 0; // 【说明】：重置过渡进度
    currentBackgroundState.isFading = true; // 【说明】：标记正在过渡中
} // 【说明】：初始化背景过渡状态

// 添加：更新背景过渡效果
function updateBackgroundTransition() {
    if (!currentBackgroundState.isFading) return; // 【说明】：如果没有正在进行的过渡，直接返回
    
    // 更新过渡进度
    currentBackgroundState.fadeProgress += 1 / currentBackgroundState.fadeDuration; // 【说明】：增加过渡进度
    
    // 检查过渡是否完成
    if (currentBackgroundState.fadeProgress >= 1) {
        // 过渡完成，更新当前背景
        currentBackgroundState.current = currentBackgroundState.next; // 【说明】：更新当前背景
        currentBackgroundState.next = null; // 【说明】：清除下一个背景
        currentBackgroundState.isFading = false; // 【说明】：标记过渡结束
        currentBackgroundState.fadeProgress = 0; // 【说明】：重置过渡进度
    }
} // 【说明】：处理背景过渡动画的进度更新

// 添加缺失的drawSky函数
function drawSky() {
    // Use the current background stage colors
    const bg = bgStages[currentBgStage];
    
    // 检查当前地图
    if (currentMap === "newMap") {  // 如果是新地图
        // 检查并更新背景切换
        checkBackgroundChange();
        updateBackgroundTransition();
        
        // 根据当前状态绘制背景
        if (currentBackgroundState.isFading && currentBackgroundState.next) {
            // 绘制过渡效果
            const currentBgImage = newMapBackgrounds[currentBackgroundState.current].image;
            const nextBgImage = newMapBackgrounds[currentBackgroundState.next].image;
            
            // 确保图片已加载
            if (currentBgImage.complete && nextBgImage.complete) {
                // 先绘制当前背景
                ctx.globalAlpha = 1;
                ctx.drawImage(currentBgImage, 0, 0, canvas.width, canvas.height);
                
                // 再绘制下一个背景（带透明度）
                ctx.globalAlpha = currentBackgroundState.fadeProgress;
                ctx.drawImage(nextBgImage, 0, 0, canvas.width, canvas.height);
                
                // 重置透明度
                ctx.globalAlpha = 1;
            } else {
                // 备选方案：使用渐变背景
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#0F0618');
                gradient.addColorStop(0.4, '#160D36');
                gradient.addColorStop(0.7, '#1E0A40');
                gradient.addColorStop(1, '#2A0A44');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        } else {
            // 正常绘制当前背景
            const currentBgImage = newMapBackgrounds[currentBackgroundState.current].image;
            if (currentBgImage.complete) {
                ctx.drawImage(currentBgImage, 0, 0, canvas.width, canvas.height);
            } else {
                // 备选方案：使用渐变背景
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#0F0618');
                gradient.addColorStop(0.4, '#160D36');
                gradient.addColorStop(0.7, '#1E0A40');
                gradient.addColorStop(1, '#2A0A44');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }
        
        // 绘制星星
        for (let star of stars) {
            const twinkle = Math.sin(frameCount * 0.05 + star.twinkle) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + twinkle * 0.7})`;
            ctx.fillRect(star.x, star.y, star.size, star.size);
        }
        
        // 绘制UFO
        drawUFO();
        return;  // 提前返回，不执行后面的场景绘制代码
    }
    
    // 以下是原有代码，保持不变
    // Create a dark gradient background
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, bg.color1);
    gradient.addColorStop(1, bg.color2);
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw stars in the background
    for (let star of stars) {
        // Make stars twinkle
        const twinkle = Math.sin(frameCount * 0.05 + star.twinkle) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + twinkle * 0.7})`;
        ctx.fillRect(star.x, star.y, star.size, star.size);
    }
    
    // 处理场景过渡
    if (sceneFade.active) {
        // 更新过渡进度
        sceneFade.progress++;
        
        // 绘制旧场景和新场景，使用透明度来创建过渡效果
        const opacity = sceneFade.progress / sceneFade.duration;
        
        // 绘制前一个场景（淡出）
        if (sceneFade.fromScene) {
            ctx.globalAlpha = 1 - opacity;
            for (const element of bgElements) {
                if (element.name === sceneFade.fromScene) {
                    element.draw();
                    break;
                }
            }
        }
        
        // 绘制新场景（淡入）
        ctx.globalAlpha = opacity;
        for (const element of bgElements) {
            if (element.name === sceneFade.toScene) {
                element.draw();
                break;
            }
        }
        
        // 重置透明度
        ctx.globalAlpha = 1;
        
        // 当过渡完成时
        if (sceneFade.progress >= sceneFade.duration) {
            sceneFade.active = false;
        }
    } 
    // 正常绘制当前场景
    else if (activeSceneName) {
        for (const element of bgElements) {
            if (element.name === activeSceneName) {
                element.draw();
                break;
            }
        }
    }
    // 修改这里 - 如果在初始夜空场景，绘制背景图片和UFO
    else if (!activeSceneName) {
        // 使用原来的渐变背景
        const bg = bgStages[currentBgStage];
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, bg.color1);
        gradient.addColorStop(1, bg.color2);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // 绘制星星
        for (let star of stars) {
            const twinkle = Math.sin(frameCount * 0.05 + star.twinkle) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + twinkle * 0.7})`;
            ctx.fillRect(star.x, star.y, star.size, star.size);
        }
        
        // 绘制UFO
        drawUFO();
    }
}
        
        // 绘制障碍物函数
        function drawObstacles() {
            for (const obstacle of obstacles) {
                const type = obstacle.type;
                
                switch (type) {
                    case obstacleTypes.HORSE:
                        // Draw horse obstacle
                        // Horse base
                        ctx.fillStyle = palette.obstacleColors.horse;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        
                        // Horse padding on top
                        ctx.fillStyle = palette.obstacleColors.horsePadding;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 10);
                        
                        // Horse legs
                        ctx.fillStyle = palette.obstacleColors.horseLeg;
                        ctx.fillRect(obstacle.x + 10, obstacle.y + obstacle.height - 25, 8, 25);
                        ctx.fillRect(obstacle.x + obstacle.width - 18, obstacle.y + obstacle.height - 25, 8, 25);
                        
                        // Horse handles on each side
                        ctx.fillStyle = palette.obstacleColors.horseHandle;
                        ctx.fillRect(obstacle.x - 5, obstacle.y + 5, 5, 20);
                        ctx.fillRect(obstacle.x + obstacle.width, obstacle.y + 5, 5, 20);
                        break;
                    
                    case obstacleTypes.POOL:
                        // Draw pool obstacle
                        ctx.fillStyle = palette.obstacleColors.pool;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        
                        // Pool edge
                        ctx.fillStyle = palette.obstacleColors.poolEdge;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 3);
                        ctx.fillRect(obstacle.x, obstacle.y + obstacle.height - 3, obstacle.width, 3);
                        
                        // Pool waves
                        ctx.fillStyle = palette.obstacleColors.poolWave;
                        for (let i = 0; i < 5; i++) {
                            const waveX = obstacle.x + 10 + i * 20;
                            const waveHeight = 3 + Math.sin(frameCount * 0.1 + i) * 2;
                            ctx.fillRect(waveX, obstacle.y + 5, 10, waveHeight);
                        }
                        break;
                    
                    case obstacleTypes.HURDLE:
                        // Draw hurdle obstacle
                        // Hurdle supporting legs
                        ctx.fillStyle = palette.obstacleColors.hurdleSupport;
                        ctx.fillRect(obstacle.x, obstacle.y + 15, 5, obstacle.height - 15);
                        ctx.fillRect(obstacle.x + obstacle.width - 5, obstacle.y + 15, 5, obstacle.height - 15);
                        
                        // Main hurdle top
                        ctx.fillStyle = palette.obstacleColors.hurdleTop;
                        ctx.fillRect(obstacle.x - 2, obstacle.y, obstacle.width + 4, 15);
                        
                        // Hurdle stripes
                        ctx.fillStyle = palette.obstacleColors.hurdleStripe;
                        for (let i = 0; i < 3; i++) {
                            ctx.fillRect(obstacle.x + 5 + i * ((obstacle.width - 10) / 2), obstacle.y + 5, 5, 5);
                        }
                        break;
                    
                    case obstacleTypes.RAIL:
                        // Draw rail obstacle
                        // Rail base
                        ctx.fillStyle = palette.obstacleColors.rail;
                        ctx.fillRect(obstacle.x, obstacle.y + obstacle.height - 15, obstacle.width, 15);
                        
                        // Rail posts
                        ctx.fillStyle = palette.obstacleColors.railPost;
                        for (let i = 0; i < 3; i++) {
                            const postX = obstacle.x + i * (obstacle.width / 2);
                            ctx.fillRect(postX, obstacle.y, 6, obstacle.height);
                        }
                        
                        // Rail top
                        ctx.fillStyle = palette.obstacleColors.railTop;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 5);
                        
                        // Rail lines
                        ctx.fillStyle = palette.obstacleColors.railLine;
                        ctx.fillRect(obstacle.x, obstacle.y + 15, obstacle.width, 2);
                        break;
                    
                    case obstacleTypes.BALANCE_BEAM:
                        // Draw balance beam
                        // Beam base
                        ctx.fillStyle = palette.obstacleColors.beam;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 10);
                        
                        // Beam supports
                        ctx.fillStyle = palette.obstacleColors.beamSupport;
                        ctx.fillRect(obstacle.x + 20, obstacle.y + 10, 15, obstacle.height - 10);
                        ctx.fillRect(obstacle.x + obstacle.width - 35, obstacle.y + 10, 15, obstacle.height - 10);
                        
                        // Beam padding
                        ctx.fillStyle = palette.obstacleColors.beamPad;
                        for (let i = 0; i < 3; i++) {
                            ctx.fillRect(obstacle.x + 10 + i * 40, obstacle.y - 3, 20, 3);
                        }
                        break;
                    
                    case obstacleTypes.POMMEL_HORSE:
                        // Draw pommel horse
                        // Horse body
                        ctx.fillStyle = palette.obstacleColors.pommelHorse;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height - 10);
                        
                        // Horse legs
                        ctx.fillStyle = palette.obstacleColors.horseLeg;
                        ctx.fillRect(obstacle.x + 10, obstacle.y + obstacle.height - 10, 10, 10);
                        ctx.fillRect(obstacle.x + obstacle.width - 20, obstacle.y + obstacle.height - 10, 10, 10);
                        
                        // Pommel handles
                        ctx.fillStyle = palette.obstacleColors.pommelHandles;
                        ctx.fillRect(obstacle.x + 15, obstacle.y - 10, 8, 15);
                        ctx.fillRect(obstacle.x + obstacle.width - 23, obstacle.y - 10, 8, 15);
                        break;
                    
                    case obstacleTypes.DIVING_BOARD:
                        // Draw diving board
                        // Board
                        ctx.fillStyle = palette.obstacleColors.divingBoard;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 8);
                        
                        // Spring support
                        ctx.fillStyle = palette.obstacleColors.divingSpring;
                        ctx.fillRect(obstacle.x + 10, obstacle.y + 8, 30, obstacle.height - 8);
                        break;
                    
                    case obstacleTypes.RINGS:
                        // Draw rings
                        // Top bar
                        ctx.fillStyle = palette.obstacleColors.bar;
                        ctx.fillRect(obstacle.x - 20, obstacle.y, obstacle.width + 40, 5);
                        
                        // Ring chains
                        ctx.strokeStyle = '#CCCCCC';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x, obstacle.y + 5);
                        ctx.lineTo(obstacle.x, obstacle.y + 25);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + obstacle.width, obstacle.y + 5);
                        ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + 25);
                        ctx.stroke();
                        
                        // Rings
                        ctx.strokeStyle = palette.obstacleColors.ring;
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.arc(obstacle.x, obstacle.y + 35, 10, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.arc(obstacle.x + obstacle.width, obstacle.y + 35, 10, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    
                    case obstacleTypes.BARREL:
                        // 绘制木桶
                        ctx.fillStyle = '#8B4513'; // 木桶颜色
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        
                        // 木桶环
                        ctx.strokeStyle = '#5D4037';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(obstacle.x, obstacle.y + 5, obstacle.width, 3);
                        ctx.strokeRect(obstacle.x, obstacle.y + obstacle.height - 8, obstacle.width, 3);
                        break;
                    
                    case obstacleTypes.BIRD:
                        // 更新鸟的翅膀位置
                        obstacle.wingPosition = (obstacle.wingPosition || 0) + 0.2;
                        const wingOffset = Math.sin(obstacle.wingPosition) * 5;
                        
                        // 绘制鸟的身体
                        ctx.fillStyle = '#4D7ABF'; // 鸟的颜色
                        ctx.beginPath();
                        ctx.ellipse(
                            obstacle.x + obstacle.width/2, 
                            obstacle.y + obstacle.height/2, 
                            obstacle.width/2, 
                            obstacle.height/2, 
                            0, 0, Math.PI * 2
                        );
                        ctx.fill();
                        
                        // 绘制翅膀
                        ctx.fillStyle = '#3A5D9C';
                        
                        // 左翅膀
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + 5, obstacle.y + obstacle.height/2);
                        ctx.lineTo(obstacle.x - 10, obstacle.y + obstacle.height/2 - wingOffset);
                        ctx.lineTo(obstacle.x - 5, obstacle.y + obstacle.height/2 + 5);
                        ctx.closePath();
                        ctx.fill();
                        
                        // 右翅膀
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + obstacle.width - 5, obstacle.y + obstacle.height/2);
                        ctx.lineTo(obstacle.x + obstacle.width + 10, obstacle.y + obstacle.height/2 - wingOffset);
                        ctx.lineTo(obstacle.x + obstacle.width + 5, obstacle.y + obstacle.height/2 + 5);
                        ctx.closePath();
                        ctx.fill();
                        
                        // 绘制眼睛
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(obstacle.x + obstacle.width * 0.7, obstacle.y + obstacle.height * 0.4, 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.arc(obstacle.x + obstacle.width * 0.7, obstacle.y + obstacle.height * 0.4, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // 绘制嘴巴
                        ctx.fillStyle = '#FF9900';
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + obstacle.width * 0.8, obstacle.y + obstacle.height * 0.5);
                        ctx.lineTo(obstacle.x + obstacle.width + 5, obstacle.y + obstacle.height * 0.6);
                        ctx.lineTo(obstacle.x + obstacle.width * 0.8, obstacle.y + obstacle.height * 0.7);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    
                    case obstacleTypes.CRATE:
                        // 绘制木箱
                        ctx.fillStyle = '#A86032'; // 木箱颜色
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        
                        // 木箱边缘
                        ctx.strokeStyle = '#5D4037';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        
                        // 木箱纹理
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x, obstacle.y + obstacle.height/2);
                        ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height/2);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + obstacle.width/2, obstacle.y);
                        ctx.lineTo(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height);
                        ctx.stroke();
                        break;
                    
                    case obstacleTypes.CACTUS:
                        // 仙人掌基本部分
                        ctx.fillStyle = '#2E8B57'; // 仙人掌绿色
                        ctx.fillRect(obstacle.x + 5, obstacle.y, obstacle.width - 10, obstacle.height);
                        
                        // 仙人掌分支
                        ctx.fillRect(obstacle.x, obstacle.y + 10, obstacle.width/3, obstacle.height/3);
                        ctx.fillRect(obstacle.x + obstacle.width - obstacle.width/3, obstacle.y + 20, obstacle.width/3, obstacle.height/3);
                        
                        // 仙人掌刺
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 6; i++) {
                            const y = obstacle.y + 5 + i * (obstacle.height/6);
                            
                            // 左侧刺
                            ctx.beginPath();
                            ctx.moveTo(obstacle.x + 5, y);
                            ctx.lineTo(obstacle.x, y - 2);
                            ctx.stroke();
                            
                            // 右侧刺
                            ctx.beginPath();
                            ctx.moveTo(obstacle.x + obstacle.width - 5, y);
                            ctx.lineTo(obstacle.x + obstacle.width, y - 2);
                            ctx.stroke();
                        }
                        break;
                    
                    case obstacleTypes.SNAKE:
                        // 蛇的身体 - 使用正弦波来创建蠕动效果
                        const snakeLength = obstacle.width;
                        const amplitude = 5; // 蠕动幅度
                        const frequency = 0.2; // 频率
                        
                        ctx.fillStyle = '#6B8E23'; // 橄榄绿色调
                        
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x, obstacle.y + obstacle.height/2);
                        
                        // 绘制蠕动的蛇
                        for (let i = 0; i <= snakeLength; i += 5) {
                            const x = obstacle.x + i;
                            const y = obstacle.y + obstacle.height/2 + 
                                     Math.sin((frameCount * 0.1) + (i * frequency)) * amplitude;
                            ctx.lineTo(x, y);
                        }
                        
                        // 完成蛇的轮廓
                        for (let i = snakeLength; i >= 0; i -= 5) {
                            const x = obstacle.x + i;
                            const y = obstacle.y + obstacle.height/2 + 
                                     Math.sin((frameCount * 0.1) + (i * frequency)) * amplitude + 5;
                            ctx.lineTo(x, y);
                        }
                        
                        ctx.closePath();
                        ctx.fill();
                        
                        // 蛇的头部
                        ctx.fillStyle = '#556B2F'; // 深橄榄绿
                        const headX = obstacle.x + snakeLength;
                        const headY = obstacle.y + obstacle.height/2 + 
                                     Math.sin((frameCount * 0.1) + (snakeLength * frequency)) * amplitude;
                        
                        ctx.beginPath();
                        ctx.arc(headX, headY, 6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // 蛇的眼睛
                        ctx.fillStyle = '#FF0000'; // 红色眼睛
                        ctx.beginPath();
                        ctx.arc(headX + 3, headY - 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    
                    case obstacleTypes.PARALLEL_BARS:
                        // 绘制平行杠
                        // 底座支撑
                        ctx.fillStyle = '#5D4037'; // 深棕色
                        ctx.fillRect(obstacle.x + 10, obstacle.y + 35, 10, obstacle.height - 35);
                        ctx.fillRect(obstacle.x + obstacle.width - 20, obstacle.y + 35, 10, obstacle.height - 35);
                        
                        // 横杠
                        ctx.fillStyle = '#8D6E63'; // 浅棕色
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 5);
                        ctx.fillRect(obstacle.x, obstacle.y + 20, obstacle.width, 5);
                        break;
                    
                    case obstacleTypes.WATER_JUMP:
                        // 绘制水坑跳
                        // 水坑
                        ctx.fillStyle = '#4FC3F7'; // 浅蓝色
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        
                        // 水波效果
                        ctx.fillStyle = '#81D4FA'; // 更浅的蓝色
                        for (let i = 0; i < 4; i++) {
                            const waveX = obstacle.x + 10 + i * 20;
                            const waveY = obstacle.y + Math.sin(frameCount * 0.1 + i * 0.5) * 3;
                            ctx.fillRect(waveX, waveY, 10, 2);
                        }
                        
                        // 边缘
                        ctx.strokeStyle = '#0288D1'; // 深蓝色
                        ctx.lineWidth = 2;
                        ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        break;
                    
                    case obstacleTypes.HIGH_JUMP:
                        // 绘制跳高杆
                        // 支柱
                        ctx.fillStyle = '#455A64'; // 蓝灰色
                        ctx.fillRect(obstacle.x, obstacle.y, 5, obstacle.height);
                        ctx.fillRect(obstacle.x + obstacle.width - 5, obstacle.y, 5, obstacle.height);
                        
                        // 横杆
                        ctx.fillStyle = '#FFFFFF'; // 白色
                        ctx.fillRect(obstacle.x - 5, obstacle.y, obstacle.width + 10, 3);
                        break;
                    
                    case obstacleTypes.UNEVEN_BARS:
                        // 绘制高低杠
                        // 支柱
                        ctx.fillStyle = '#795548'; // 棕色
                        ctx.fillRect(obstacle.x + 5, obstacle.y + 20, 10, obstacle.height - 20);
                        ctx.fillRect(obstacle.x + obstacle.width - 15, obstacle.y + 35, 10, obstacle.height - 35);
                        
                        // 横杠
                        ctx.fillStyle = '#FCB900'; // 金色
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 5); // 高杠
                        ctx.fillRect(obstacle.x, obstacle.y + 25, obstacle.width - 20, 5); // 低杠
                        break;
                }
            }
        }

        // 绘制金牌和茶杯
        function drawMedals() {
            for (const medal of medals) {
                if (medal.type === collectibleTypes.GOLD) {
                    // 金牌绘制
                    ctx.beginPath();
                    ctx.arc(medal.x + medal.width / 2, medal.y + medal.height / 2, medal.width / 2, 0, Math.PI * 2);
                    ctx.fillStyle = palette.gold;
                    ctx.fill();
                    
                    // 金牌上的图案
                    ctx.beginPath();
                    ctx.arc(medal.x + medal.width / 2, medal.y + medal.height / 2, medal.width / 3, 0, Math.PI * 2);
                    ctx.fillStyle = palette.goldShine;
                    ctx.fill();
                    
                    // 金牌的光晕 - 使用正弦波创建呼吸光效
                    const glowSize = 3 + Math.sin(frameCount * 0.1) * 2;
                    ctx.beginPath();
                    ctx.arc(medal.x + medal.width / 2, medal.y + medal.height / 2, medal.width / 2 + glowSize, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                    ctx.fill();
                    
                    // 金牌丝带
                    ctx.beginPath();
                    ctx.moveTo(medal.x + medal.width / 2, medal.y);
                    ctx.lineTo(medal.x + medal.width / 2 - 3, medal.y - 5);
                    ctx.lineTo(medal.x + medal.width / 2 + 3, medal.y - 5);
                    ctx.closePath();
                    ctx.fillStyle = palette.goldRibbon;
                    ctx.fill();
                    
                } else if (medal.type === collectibleTypes.TEA) {
                    // 添加光晕效果
                    const glowSize = 20 + Math.sin(frameCount * 0.1) * 5; // 脉动效果
                    const gradient = ctx.createRadialGradient(
                        medal.x + medalSize/2, medal.y + medalSize/2, 0,
                        medal.x + medalSize/2, medal.y + medalSize/2, glowSize
                    );
                    gradient.addColorStop(0, 'rgba(102, 255, 102, 0.3)');
                    gradient.addColorStop(1, 'rgba(102, 255, 102, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(medal.x - glowSize/2, medal.y - glowSize/2, 
                                medalSize + glowSize, medalSize + glowSize);

                    // 添加漂浮效果
                    const floatOffset = Math.sin(frameCount * 0.05) * 3;
                    
                    // 绘制茶杯
                    ctx.fillStyle = palette.teaCup;
                    ctx.fillRect(medal.x, medal.y + floatOffset, medalSize, medalSize * 0.7);
                    
                    // 绘制茶水
                    ctx.fillStyle = palette.teaColor;
                    ctx.fillRect(medal.x + 2, medal.y + floatOffset + 2, medalSize - 4, medalSize * 0.4);
                    
                    // 添加闪烁星星效果
                    const starAngle = frameCount * 0.1;
                    const starRadius = 2;
                    ctx.fillStyle = '#FFFFFF';
                    for (let i = 0; i < 4; i++) {
                        const angle = starAngle + (Math.PI * 2 * i / 4);
                        const starX = medal.x + medalSize/2 + Math.cos(angle) * 15;
                        const starY = medal.y + medalSize/2 + Math.sin(angle) * 15 + floatOffset;
                        ctx.beginPath();
                        ctx.arc(starX, starY, starRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // 为收集品添加浮动效果
                medal.y += Math.sin(frameCount * 0.1) * 0.3;
            }
        }
        
        // Background elements functions
        function createMountains() {
            mountains = [];
            const mountainCount = 5;
            
            for (let i = 0; i < mountainCount; i++) {
                const mountainHeight = 80 + Math.random() * 100;
                mountains.push({
                    x: (i * canvas.width / mountainCount) + Math.random() * 50,
                    height: mountainHeight,
                    width: 100 + Math.random() * 150
                });
            }
        }
        
        function drawMountains() {
            for (const mountain of mountains) {
                // Move mountain with background parallax
                mountain.x -= gameSpeed * 0.2; // Slower than foreground for parallax effect
                
                if (mountain.x + mountain.width < 0) {
                    mountain.x = canvas.width;
                }
                
                // Draw mountain
                ctx.fillStyle = '#1A2C50'; // Dark blue for distant mountains
                ctx.beginPath();
                ctx.moveTo(mountain.x, canvas.height - 30); // Base at ground
                ctx.lineTo(mountain.x + mountain.width / 2, canvas.height - 30 - mountain.height);
                ctx.lineTo(mountain.x + mountain.width, canvas.height - 30);
                ctx.closePath();
                ctx.fill();
                
                // Snow caps
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.moveTo(mountain.x + mountain.width * 0.4, canvas.height - 30 - mountain.height * 0.85);
                ctx.lineTo(mountain.x + mountain.width / 2, canvas.height - 30 - mountain.height);
                ctx.lineTo(mountain.x + mountain.width * 0.6, canvas.height - 30 - mountain.height * 0.85);
                ctx.closePath();
                ctx.fill();
            }
        }

        // 完全替换原有的createPirateScene函数
        function createPirateScene() {
            pirateElements = [];
            
            // 添加深海光束 - 增强氛围感
            for (let i = 0; i < 8; i++) {
                pirateElements.push({
                    type: 'oceanRay',
                    x: Math.random() * canvas.width,
                    y: 0,
                    width: 80 + Math.random() * 100,
                    height: canvas.height,
                    opacity: 0.05 + Math.random() * 0.08
                });
            }
            
            // 添加海草和珊瑚
            for (let i = 0; i < 10; i++) {
                pirateElements.push({
                    type: 'seaweed',
                    x: i * (canvas.width / 10) + Math.random() * 20 - 10,
                    y: canvas.height - 30,
                    height: 40 + Math.random() * 50,
                    width: 15 + Math.random() * 10,
                    segments: 3 + Math.floor(Math.random() * 3),
                    swaySpeed: 0.01 + Math.random() * 0.02,
                    swayAmount: 3 + Math.random() * 8,
                    phase: Math.random() * Math.PI * 2,
                    color: Math.random() > 0.7 ? '#5d936a' : '#3a7e68'
                });
            }
            
            // 添加气泡
            for (let i = 0; i < 25; i++) {
                pirateElements.push({
                    type: 'bubble',
                    x: Math.random() * canvas.width,
                    y: canvas.height - Math.random() * 50,
                    size: 2 + Math.random() * 7,
                    speed: 0.5 + Math.random() * 1.5,
                    wobble: 0.5 + Math.random() * 1,
                    phase: Math.random() * Math.PI * 2
                });
            }
            
            // 添加鱼群
            for (let i = 0; i < 3; i++) {
                const fishCount = 3 + Math.floor(Math.random() * 5);
                const direction = Math.random() > 0.5 ? 1 : -1;
                
                pirateElements.push({
                    type: 'fishSchool',
                    x: direction > 0 ? -50 : canvas.width + 50,
                    y: 100 + Math.random() * (canvas.height - 200),
                    direction: direction,
                    speed: 0.3 + Math.random() * 0.8,
                    fish: Array.from({length: fishCount}, () => ({
                        offsetX: (Math.random() - 0.5) * 60,
                        offsetY: (Math.random() - 0.5) * 30,
                        size: 8 + Math.random() * 7,
                        tailPhase: Math.random() * Math.PI * 2
                    }))
                });
            }
            
            // 添加主潜艇
            pirateElements.push({
                type: 'submarine',
                x: canvas.width * 0.3,
                y: canvas.height - 70,
                width: 180,
                height: 70,
                bobAmount: 2,
                bobSpeed: 0.01,
                windows: Array.from({length: 4}, (_, i) => ({
                    x: canvas.width * 0.3 + 45 + i * 25,
                    y: canvas.height - 70 + 25,
                    radius: 7,
                    glow: 0.8 + Math.random() * 0.2
                }))
            });
            
            // 添加小潜艇
            pirateElements.push({
                type: 'smallSubmarine',
                x: canvas.width * 0.7,
                y: canvas.height - 55,
                width: 90,
                height: 40,
                bobAmount: 1.5,
                bobSpeed: 0.015
            });
            
            // 放置轻雾层次
            for (let i = 0; i < 4; i++) {
                pirateElements.push({
                    type: 'mist',
                    y: canvas.height - 30 - i * 70,
                    opacity: 0.04 + i * 0.02,
                    speed: 0.1 + i * 0.05
                });
            }
        }

        // 完全替换原有的drawPirateScene函数
        function drawPirateScene() {
            // 绘制海底渐变背景
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#071526');  // 深蓝色顶部
            skyGradient.addColorStop(0.4, '#0c2440'); // 中深蓝
            skyGradient.addColorStop(0.7, '#0e3757'); // 中蓝绿
            skyGradient.addColorStop(1, '#0d4a6e');   // 底部更亮蓝绿
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制光束 - 创造深海神秘氛围
            for (const element of pirateElements) {
                if (element.type === 'oceanRay') {
                    const gradient = ctx.createLinearGradient(
                        element.x, 0, 
                        element.x, canvas.height
                    );
                    gradient.addColorStop(0, `rgba(120, 180, 210, ${element.opacity})`);
                    gradient.addColorStop(1, 'rgba(120, 180, 210, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(element.x, 0);
                    ctx.lineTo(element.x - element.width/2, canvas.height);
                    ctx.lineTo(element.x + element.width/2, canvas.height);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // 绘制海草
            for (const element of pirateElements) {
                if (element.type === 'seaweed') {
                    // 摇摆动画
                    element.phase += element.swaySpeed;
                    const sway = Math.sin(element.phase) * element.swayAmount;
                    
                    // 绘制弯曲的海草
                    ctx.fillStyle = element.color;
                    ctx.beginPath();
                    ctx.moveTo(element.x, element.y);
                    
                    // 用贝塞尔曲线创建自然弯曲
                    ctx.bezierCurveTo(
                        element.x + sway, element.y - element.height * 0.4,
                        element.x + sway * 1.5, element.y - element.height * 0.7,
                        element.x + sway * 0.8, element.y - element.height
                    );
                    
                    ctx.bezierCurveTo(
                        element.x + sway * 1.2, element.y - element.height * 0.7,
                        element.x + sway * 0.6, element.y - element.height * 0.4,
                        element.x + element.width, element.y
                    );
                    
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            // 绘制气泡
            for (const element of pirateElements) {
                if (element.type === 'bubble') {
                    // 更新气泡位置
                    element.y -= element.speed;
                    element.x += Math.sin(element.phase) * element.wobble * 0.2;
                    element.phase += 0.03;
                    
                    // 重置离开屏幕的气泡
                    if (element.y < 0) {
                        element.y = canvas.height;
                        element.x = Math.random() * canvas.width;
                    }
                    
                    // 绘制气泡
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 0.8;
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.size, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // 气泡内部渐变
                    const gradient = ctx.createRadialGradient(
                        element.x - element.size/3, element.y - element.size/3, 0,
                        element.x, element.y, element.size
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // 气泡高光点
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(element.x - element.size/3, element.y - element.size/3, element.size/6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // 绘制鱼群
            for (const element of pirateElements) {
                if (element.type === 'fishSchool') {
                    // 更新鱼群位置
                    element.x += element.speed * element.direction;
                    
                    // 重置离开屏幕的鱼群
                    if ((element.direction > 0 && element.x > canvas.width + 100) || 
                        (element.direction < 0 && element.x < -100)) {
                        element.x = element.direction > 0 ? -100 : canvas.width + 100;
                        element.y = 100 + Math.random() * (canvas.height - 200);
                    }
                    
                    // 绘制每条鱼
                    for (const fish of element.fish) {
                        // 更新鱼尾摆动
                        fish.tailPhase += 0.1;
                        const tailWag = Math.sin(fish.tailPhase) * fish.size/2;
                        
                        const fishX = element.x + fish.offsetX;
                        const fishY = element.y + fish.offsetY;
                        
                        // 鱼身体
                        ctx.fillStyle = 'rgba(150, 180, 200, 0.8)';
                        ctx.beginPath();
                        ctx.ellipse(fishX, fishY, fish.size, fish.size/2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // 鱼尾
                        ctx.beginPath();
                        if (element.direction > 0) {
                            ctx.moveTo(fishX - fish.size, fishY - fish.size/4);
                            ctx.lineTo(fishX - fish.size*1.5, fishY + tailWag);
                            ctx.lineTo(fishX - fish.size, fishY + fish.size/4);
                        } else {
                            ctx.moveTo(fishX + fish.size, fishY - fish.size/4);
                            ctx.lineTo(fishX + fish.size*1.5, fishY + tailWag);
                            ctx.lineTo(fishX + fish.size, fishY + fish.size/4);
                        }
                        ctx.fill();
                        
                        // 鱼眼
                        const eyeX = fishX + (element.direction > 0 ? fish.size/2 : -fish.size/2);
                        
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(eyeX, fishY - fish.size/4, fish.size/5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(eyeX, fishY - fish.size/4, fish.size/10, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // 绘制潜水艇
            for (const element of pirateElements) {
                if (element.type === 'submarine' || element.type === 'smallSubmarine') {
                    const bob = Math.sin(frameCount * element.bobSpeed) * element.bobAmount;
                    const isSmall = element.type === 'smallSubmarine';
                    
                    // 潜艇主体
                    const gradient = ctx.createLinearGradient(0, element.y + bob, 0, element.y + element.height + bob);
                    gradient.addColorStop(0, isSmall ? '#4a6a85' : '#5a7a95');
                    gradient.addColorStop(1, isSmall ? '#2a4a65' : '#3a5a75');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(
                        element.x + element.width/2,
                        element.y + bob,
                        element.width/2,
                        element.height/2,
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                    
                    // 潜艇顶部
                    if (!isSmall) {
                        ctx.fillStyle = '#3a5a75';
                        ctx.beginPath();
                        ctx.ellipse(
                            element.x + element.width*0.5,
                            element.y - element.height*0.2 + bob,
                            element.width*0.2,
                            element.height*0.2,
                            0, 0, Math.PI, true
                        );
                        ctx.fill();
                        
                        // 潜望镜
                        ctx.fillStyle = '#2a4a65';
                        ctx.fillRect(
                            element.x + element.width * 0.4 - 3,
                            element.y - element.height * 0.2 - 30 + bob,
                            6,
                            30
                        );
                        
                        // 潜望镜顶部
                        ctx.fillRect(
                            element.x + element.width * 0.4 - 5,
                            element.y - element.height * 0.2 - 33 + bob,
                            10,
                            3
                        );
                        
                        // 绘制窗户
                        for (const window of element.windows) {
                            // 窗户发光效果
                            const glow = ctx.createRadialGradient(
                                window.x, window.y + bob, 0,
                                window.x, window.y + bob, window.radius * 2
                            );
                            glow.addColorStop(0, `rgba(162, 220, 240, ${window.glow})`);
                            glow.addColorStop(1, 'rgba(162, 220, 240, 0)');
                            
                            ctx.fillStyle = glow;
                            ctx.beginPath();
                            ctx.arc(window.x, window.y + bob, window.radius * 2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // 窗户本体
                            ctx.fillStyle = 'rgba(200, 230, 250, 0.8)';
                            ctx.beginPath();
                            ctx.arc(window.x, window.y + bob, window.radius, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // 窗户边框
                            ctx.strokeStyle = '#2a4a65';
                            ctx.lineWidth = 1.5;
                            ctx.stroke();
                        }
                    } else {
                        // 小潜艇窗户
                        const windowX = element.x + element.width * 0.3;
                        const windowY = element.y + bob;
                        
                        ctx.fillStyle = 'rgba(162, 220, 240, 0.5)';
                        ctx.beginPath();
                        ctx.arc(windowX, windowY, element.width * 0.15, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'rgba(200, 230, 250, 0.8)';
                        ctx.beginPath();
                        ctx.arc(windowX, windowY, element.width * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.strokeStyle = '#2a4a65';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                    }
                }
            }
            
            // 绘制轻雾层次 - 增强深度感
            for (const element of pirateElements) {
                if (element.type === 'mist') {
                    // 绘制半透明浅蓝雾层
                    ctx.fillStyle = `rgba(120, 180, 210, ${element.opacity})`;
                    ctx.fillRect(0, element.y, canvas.width, 70);
                }
            }
        }

        // 添加新的辅助函数
        function drawRainClouds() {
            // ... 您提供的drawRainClouds代码 ...
        }

        function drawRainOverlay() {
            // ... 您提供的drawRainOverlay代码 ...
        }

        function createLightningBolt(lightning, startX, startY, length, angle, generation) {
            if (generation > 3) return;
            
            const endX = startX + Math.cos(angle) * length;
            const endY = startY + Math.sin(angle) * length;
            
            lightning.branches.push({
                startX: startX,
                startY: startY,
                endX: endX,
                endY: endY
            });
            
            if (Math.random() < 0.6 && generation < 2) {
                const newAngle = angle + (Math.random() * 0.5 - 0.25) * Math.PI;
                const newLength = length * (0.3 + Math.random() * 0.4);
                
                const branchStartPos = 0.3 + Math.random() * 0.5;
                const branchStartX = startX + (endX - startX) * branchStartPos;
                const branchStartY = startY + (endY - startY) * branchStartPos;
                
                createLightningBolt(
                    lightning,
                    branchStartX,
                    branchStartY,
                    newLength,
                    newAngle,
                    generation + 1
                );
            }
        }

        // 创建樱花庭院场景元素
        function createCherryBlossom() {
            // 清空樱花场景元素
            cherrySakura = [];
            
            // 背景远山 - 多层次的山脉
            cherrySakura.push({
                type: 'mountains',
                layers: [
                    {color: '#3A2D4D', height: 100, offset: 0},
                    {color: '#4D3A65', height: 80, offset: 20},
                    {color: '#5E477D', height: 60, offset: 40}
                ]
            });
            
            // 添加静态樱花树 - 多种形态
            const treeCount = 5;
            for (let i = 0; i < treeCount; i++) {
                // 位置随树的大小和类型变化
                const treeType = i % 3;
                const x = i * (canvas.width / (treeCount - 0.5)) - 50;
                
                // 不同大小的树
                let height, width, style;
                if (treeType === 0) {
                    // 高大的树
                    height = 190 + (i % 2) * 20;
                    width = 35 + (i % 2) * 5;
                    style = 'full';
                } else if (treeType === 1) {
                    // 小点的树
                    height = 140 + (i % 2) * 15;
                    width = 25 + (i % 2) * 4;
                    style = 'curved';
                } else {
                    // 中等的树
                    height = 160 + (i % 2) * 15;
                    width = 30 + (i % 2) * 5;
                    style = 'split';
                }
                
                cherrySakura.push({
                    type: 'tree',
                    x: x,
                    y: canvas.height - 30,
                    height: height,
                    width: width,
                    style: style,
                    blossomIntensity: 0.7 + (i % 3) * 0.1 // 花朵密度
                });
            }
            
            // 添加庭院装饰元素
            
            // 传统石灯笼
            cherrySakura.push({
                type: 'stone-lantern',
                x: canvas.width * 0.25,
                y: canvas.height - 30,
                height: 60,
                glowing: true
            });
            
            // 小桥
            cherrySakura.push({
                type: 'bridge',
                x: canvas.width * 0.6,
                y: canvas.height - 35,
                width: 120,
                height: 30
            });
            
            // 池塘
            cherrySakura.push({
                type: 'pond',
                x: canvas.width * 0.5,
                y: canvas.height - 20,
                width: 180,
                height: 15
            });
            
            // 装饰石头
            for (let i = 0; i < 8; i++) {
                const size = 8 + (i % 4) * 3;
                const stoneType = i % 3;
                let x, y;
                
                // 根据石头类型放置在不同位置
                if (stoneType === 0) {
                    // 池塘边的石头
                    x = canvas.width * 0.5 + (i - 4) * 20;
                    y = canvas.height - 25;
                } else if (stoneType === 1) {
                    // 灯笼旁的石头
                    x = canvas.width * 0.25 + (i - 2) * 10 - 20;
                    y = canvas.height - 15 + (i % 2) * 2;
                } else {
                    // 小桥附近的石头
                    x = canvas.width * 0.65 + (i - 4) * 15;
                    y = canvas.height - 18 + (i % 2) * 3;
                }
                
                cherrySakura.push({
                    type: 'stone',
                    x: x,
                    y: y,
                    size: size,
                    shape: stoneType
                });
            }
            
            // 日式庭院栅栏
            for (let i = 0; i < 2; i++) {
                cherrySakura.push({
                    type: 'fence',
                    x: i === 0 ? 50 : canvas.width - 200,
                    y: canvas.height - 40,
                    width: 120,
                    height: 25
                });
            }
            
            // 远处的鸟居
            cherrySakura.push({
                type: 'torii',
                x: canvas.width * 0.8,
                y: canvas.height - 80,
                width: 70,
                height: 60
            });
            
            // 添加飘落的花瓣 - 大幅增加数量使场景更加生动
            const petalCount = 120; // 大幅增加花瓣数量
            for (let i = 0; i < petalCount; i++) {
                cherrySakura.push({
                    type: 'petal',
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height - 60),
                    size: 1.5 + Math.random() * 1.8, // 增大尺寸，更加多样化
                    speed: 0.05 + Math.random() * 0.12, // 稍微增加速度但仍然保持缓慢
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.01, // 增加旋转速度
                    swayAmount: 0.15 + Math.random() * 0.25, // 增加摆动幅度
                    swaySpeed: 0.001 + Math.random() * 0.002, // 增加摆动速度
                    opacity: 0.5 + Math.random() * 0.4, // 增加不透明度
                    color: Math.random() > 0.7 ? 
                        (Math.random() > 0.5 ? '#FFC8D8' : '#FFDBF1') : '#FFB7C5' // 更多色彩变化
                });
            }
        }
        
        // 绘制樱花庭院场景
        function drawCherryBlossom() {
            // 绘制天空背景渐变 - 柔和的黄昏色调
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height - 30);
            skyGradient.addColorStop(0, '#4A3B65'); // 深紫色顶部
            skyGradient.addColorStop(0.5, '#7E5A9B'); // 中间色调
            skyGradient.addColorStop(1, '#CF99CC'); // 粉紫色底部
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制远处的月亮
            ctx.fillStyle = 'rgba(255, 255, 240, 0.8)';
            ctx.beginPath();
            ctx.arc(canvas.width * 0.8, canvas.height * 0.2, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // 月亮光晕
            const moonGlowGradient = ctx.createRadialGradient(
                canvas.width * 0.8, canvas.height * 0.2, 25,
                canvas.width * 0.8, canvas.height * 0.2, 70
            );
            moonGlowGradient.addColorStop(0, 'rgba(255, 255, 240, 0.3)');
            moonGlowGradient.addColorStop(1, 'rgba(255, 255, 240, 0)');
            ctx.fillStyle = moonGlowGradient;
            ctx.beginPath();
            ctx.arc(canvas.width * 0.8, canvas.height * 0.2, 70, 0, Math.PI * 2);
            ctx.fill();
            
            // 绘制静态星星
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            for (let i = 0; i < 30; i++) {
                const x = (i * 37) % canvas.width;
                const y = ((i * 29) % 150) + 20;
                const size = 0.5 + (i % 3) * 0.5;
                ctx.fillRect(x, y, size, size);
            }
            
            // 绘制所有静态场景元素
            for (const element of cherrySakura) {
                if (element.type === 'mountains') {
                    // 绘制多层次的远山
                    for (const layer of element.layers) {
                        // 山脉轮廓
                        ctx.fillStyle = layer.color;
                        ctx.beginPath();
                        ctx.moveTo(0, canvas.height);
                        
                        // 创建山脉曲线
                        const segmentCount = 10;
                        for (let i = 0; i <= segmentCount; i++) {
                            const x = i * (canvas.width / segmentCount);
                            // 使用正弦函数创建自然的山脉形状
                            const height = layer.height + Math.sin(i * 0.8) * 20 + Math.sin(i * 0.3) * 15;
                            const y = canvas.height - height - layer.offset;
                            
                            if (i === 0) {
                                ctx.lineTo(x, y);
                            } else {
                                const prevX = (i - 1) * (canvas.width / segmentCount);
                                const prevHeight = layer.height + Math.sin((i - 1) * 0.8) * 20 + Math.sin((i - 1) * 0.3) * 15;
                                const prevY = canvas.height - prevHeight - layer.offset;
                                
                                // 使用贝塞尔曲线创建平滑的山脉
                                const cpX = (prevX + x) / 2;
                                ctx.quadraticCurveTo(cpX, prevY, x, y);
                            }
                        }
                        
                        ctx.lineTo(canvas.width, canvas.height);
                        ctx.closePath();
                        ctx.fill();
                        
                        // 山上的积雪/光效
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.beginPath();
                        ctx.moveTo(0, canvas.height - layer.height - layer.offset);
                        
                        for (let i = 0; i <= segmentCount; i++) {
                            const x = i * (canvas.width / segmentCount);
                            const height = layer.height + Math.sin(i * 0.8) * 20 + Math.sin(i * 0.3) * 15;
                            const y = canvas.height - height - layer.offset;
                            
                            if (i === 0) {
                                ctx.lineTo(x, y);
                            } else {
                                const prevX = (i - 1) * (canvas.width / segmentCount);
                                const prevHeight = layer.height + Math.sin((i - 1) * 0.8) * 20 + Math.sin((i - 1) * 0.3) * 15;
                                const prevY = canvas.height - prevHeight - layer.offset;
                                
                                const cpX = (prevX + x) / 2;
                                ctx.quadraticCurveTo(cpX, prevY, x, y);
                            }
                        }
                        
                        ctx.lineTo(canvas.width, canvas.height - layer.height - layer.offset + 20);
                        ctx.lineTo(0, canvas.height - layer.height - layer.offset + 20);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
                else if (element.type === 'tree') {
                    // 绘制樱花树干
                    const trunkGradient = ctx.createLinearGradient(
                        element.x, element.y - element.height,
                        element.x + element.width, element.y
                    );
                    trunkGradient.addColorStop(0, '#6D4C41'); // 深褐色
                    trunkGradient.addColorStop(1, '#8D6E63'); // 浅褐色
                    
                    ctx.fillStyle = trunkGradient;
                    
                    // 根据树的样式绘制不同形状的树干
                    if (element.style === 'full') {
                        // 完整挺拔的树干
                        ctx.beginPath();
                        ctx.moveTo(element.x, element.y);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.1, 
                            element.y - element.height * 0.5,
                            element.x + element.width * 0.2, 
                            element.y - element.height * 0.9
                        );
                        ctx.lineTo(element.x + element.width * 0.2, element.y - element.height * 0.9);
                        ctx.lineTo(element.x + element.width * 0.8, element.y - element.height * 0.9);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.9, 
                            element.y - element.height * 0.5,
                            element.x + element.width, element.y
                        );
                        ctx.closePath();
                        ctx.fill();
                        
                        // 添加主要分枝
                        ctx.strokeStyle = '#6D4C41';
                        ctx.lineWidth = 3;
                        
                        // 左侧主分枝
                        ctx.beginPath();
                        ctx.moveTo(element.x + element.width * 0.3, element.y - element.height * 0.5);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.1, 
                            element.y - element.height * 0.6,
                            element.x, element.y - element.height * 0.7
                        );
                        ctx.stroke();
                        
                        // 右侧主分枝
                        ctx.beginPath();
                        ctx.moveTo(element.x + element.width * 0.7, element.y - element.height * 0.6);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.9, 
                            element.y - element.height * 0.7,
                            element.x + element.width + 10, element.y - element.height * 0.75
                        );
                        ctx.stroke();
                        
                        // 绘制樱花
                        ctx.fillStyle = '#FFCFD5';
                        
                        // 主树冠
                        drawTreeBlossoms(
                            element.x + element.width * 0.5, 
                            element.y - element.height * 0.8,
                            element.width * 2.5,
                            element.height * 0.4,
                            element.blossomIntensity
                        );
                        
                        // 左侧树冠
                        drawTreeBlossoms(
                            element.x + element.width * 0.15, 
                            element.y - element.height * 0.6,
                            element.width * 1.2,
                            element.height * 0.3,
                            element.blossomIntensity
                        );
                        
                        // 右侧树冠
                        drawTreeBlossoms(
                            element.x + element.width * 0.85, 
                            element.y - element.height * 0.7,
                            element.width * 1.2,
                            element.height * 0.3,
                            element.blossomIntensity
                        );
                    }
                    else if (element.style === 'curved') {
                        // 弯曲的树干
                        ctx.beginPath();
                        ctx.moveTo(element.x, element.y);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.3, 
                            element.y - element.height * 0.5,
                            element.x + element.width * 0.7, 
                            element.y - element.height * 0.9
                        );
                        ctx.lineTo(element.x + element.width * 0.8, element.y - element.height * 0.85);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.5, 
                            element.y - element.height * 0.4,
                            element.x + element.width, element.y
                        );
                        ctx.closePath();
                        ctx.fill();
                        
                        // 添加分枝
                        ctx.strokeStyle = '#6D4C41';
                        ctx.lineWidth = 2;
                        
                        // 上部分枝
                        ctx.beginPath();
                        ctx.moveTo(element.x + element.width * 0.6, element.y - element.height * 0.7);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.8, 
                            element.y - element.height * 0.8,
                            element.x + element.width * 0.9, element.y - element.height * 0.95
                        );
                        ctx.stroke();
                        
                        // 中部分枝
                        ctx.beginPath();
                        ctx.moveTo(element.x + element.width * 0.4, element.y - element.height * 0.5);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.2, 
                            element.y - element.height * 0.55,
                            element.x, element.y - element.height * 0.6
                        );
                        ctx.stroke();
                        
                        // 绘制樱花
                        ctx.fillStyle = '#FFCFD5';
                        
                        // 主树冠
                        drawTreeBlossoms(
                            element.x + element.width * 0.7, 
                            element.y - element.height * 0.85,
                            element.width * 1.8,
                            element.height * 0.3,
                            element.blossomIntensity
                        );
                        
                        // 下部树冠
                        drawTreeBlossoms(
                            element.x + element.width * 0.2, 
                            element.y - element.height * 0.5,
                            element.width * 1.5,
                            element.height * 0.25,
                            element.blossomIntensity
                        );
                    }
                    else if (element.style === 'split') {
                        // 分叉的树干
                        ctx.beginPath();
                        ctx.moveTo(element.x, element.y);
                        ctx.lineTo(element.x + element.width/2, element.y - element.height * 0.4);
                        ctx.lineTo(element.x + element.width, element.y);
                        ctx.closePath();
                        ctx.fill();
                        
                        // 左主干
                        ctx.beginPath();
                        ctx.moveTo(element.x + element.width * 0.35, element.y - element.height * 0.35);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.2, 
                            element.y - element.height * 0.6,
                            element.x + element.width * 0.1, 
                            element.y - element.height * 0.85
                        );
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.15, 
                            element.y - element.height * 0.7,
                            element.x + element.width * 0.3, 
                            element.y - element.height * 0.45
                        );
                        ctx.closePath();
                        ctx.fill();
                        
                        // 右主干
                        ctx.beginPath();
                        ctx.moveTo(element.x + element.width * 0.65, element.y - element.height * 0.35);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.8, 
                            element.y - element.height * 0.65,
                            element.x + element.width * 0.95, 
                            element.y - element.height * 0.8
                        );
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.85, 
                            element.y - element.height * 0.65,
                            element.x + element.width * 0.7, 
                            element.y - element.height * 0.45
                        );
                        ctx.closePath();
                        ctx.fill();
                        
                        // 绘制樱花
                        ctx.fillStyle = '#FFCFD5';
                        
                        // 左侧树冠
                        drawTreeBlossoms(
                            element.x + element.width * 0.2, 
                            element.y - element.height * 0.75,
                            element.width * 1.4,
                            element.height * 0.25,
                            element.blossomIntensity
                        );
                        
                        // 右侧树冠
                        drawTreeBlossoms(
                            element.x + element.width * 0.8, 
                            element.y - element.height * 0.7,
                            element.width * 1.4,
                            element.height * 0.25,
                            element.blossomIntensity
                        );
                    }
                }
                else if (element.type === 'stone-lantern') {
                    // 绘制传统日式石灯笼
                    const baseWidth = 20;
                    
                    // 底座
                    ctx.fillStyle = '#8C8C8C';
                    ctx.fillRect(
                        element.x - baseWidth, 
                        element.y - 10, 
                        baseWidth * 2, 
                        10
                    );
                    
                    // 中柱
                    ctx.fillRect(
                        element.x - baseWidth/2,
                        element.y - 25,
                        baseWidth,
                        15
                    );
                    
                    // 灯笼主体
                    ctx.fillStyle = '#7A7A7A';
                    ctx.beginPath();
                    ctx.moveTo(element.x - baseWidth, element.y - 30);
                    ctx.lineTo(element.x + baseWidth, element.y - 30);
                    ctx.lineTo(element.x + baseWidth - 5, element.y - 45);
                    ctx.lineTo(element.x - baseWidth + 5, element.y - 45);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 灯笼顶部
                    ctx.fillStyle = '#686868';
                    ctx.beginPath();
                    ctx.moveTo(element.x - baseWidth + 3, element.y - 45);
                    ctx.lineTo(element.x + baseWidth - 3, element.y - 45);
                    ctx.lineTo(element.x + baseWidth/2, element.y - 55);
                    ctx.lineTo(element.x - baseWidth/2, element.y - 55);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 灯笼窗口 - 发光效果
                    if (element.glowing) {
                        // 窗口
                        ctx.fillStyle = 'rgba(255, 220, 150, 0.7)';
                        ctx.fillRect(
                            element.x - baseWidth/2,
                            element.y - 40,
                            baseWidth,
                            10
                        );
                        
                        // 光晕
                        const glowGradient = ctx.createRadialGradient(
                            element.x, element.y - 35, 5,
                            element.x, element.y - 35, 25
                        );
                        glowGradient.addColorStop(0, 'rgba(255, 220, 150, 0.4)');
                        glowGradient.addColorStop(1, 'rgba(255, 220, 150, 0)');
                        
                        ctx.fillStyle = glowGradient;
                        ctx.beginPath();
                        ctx.arc(element.x, element.y - 35, 25, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.fillStyle = '#555555';
                        ctx.fillRect(
                            element.x - baseWidth/2,
                            element.y - 40,
                            baseWidth,
                            10
                        );
                    }
                }
                else if (element.type === 'bridge') {
                    // 绘制小桥
                    ctx.fillStyle = '#8B5A2B';
                    
                    // 桥的弧形
                    ctx.beginPath();
                    ctx.moveTo(element.x, element.y);
                    ctx.quadraticCurveTo(
                        element.x + element.width/2, 
                        element.y - element.height,
                        element.x + element.width, 
                        element.y
                    );
                    ctx.lineTo(element.x + element.width, element.y + 5);
                    ctx.lineTo(element.x, element.y + 5);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 桥栏杆
                    ctx.fillStyle = '#6D4C41';
                    
                    // 左栏杆柱
                    ctx.fillRect(
                        element.x + 10,
                        element.y - 10,
                        3,
                        14
                    );
                    
                    // 右栏杆柱
                    ctx.fillRect(
                        element.x + element.width - 13,
                        element.y - 10,
                        3,
                        14
                    );
                    
                    // 桥栏杆横条
                    ctx.fillRect(
                        element.x + 5,
                        element.y - 7,
                        element.width - 10,
                        2
                    );
                    
                    // 桥板纹理
                    ctx.strokeStyle = '#5D4037';
                    ctx.lineWidth = 1;
                    
                    for (let i = 1; i < 10; i++) {
                        const x = element.x + (element.width * i) / 10;
                        
                        // 计算桥面高度
                        const boardY = element.y - Math.sin((i / 10) * Math.PI) * element.height;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, boardY);
                        ctx.lineTo(x, boardY + 5);
                        ctx.stroke();
                    }
                }
                else if (element.type === 'pond') {
                    // 绘制池塘
                    const pondGradient = ctx.createLinearGradient(
                        element.x, element.y - element.height, 
                        element.x, element.y
                    );
                    pondGradient.addColorStop(0, '#5B88A5');
                    pondGradient.addColorStop(1, '#3A6980');
                    
                    ctx.fillStyle = pondGradient;
                    
                    // 绘制池塘形状 - 椭圆
                    ctx.beginPath();
                    ctx.ellipse(
                        element.x + element.width/2, 
                        element.y, 
                        element.width/2, 
                        element.height, 
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                    
                    // 池塘边缘
                    ctx.strokeStyle = '#4A7890';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.ellipse(
                        element.x + element.width/2, 
                        element.y, 
                        element.width/2, 
                        element.height, 
                        0, 0, Math.PI * 2
                    );
                    ctx.stroke();
                    
                    // 池塘静态反光
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.beginPath();
                    ctx.ellipse(
                        element.x + element.width/2 + 15, 
                        element.y - 2, 
                        element.width/3, 
                        element.height/1.5, 
                        0, 0, Math.PI
                    );
                    ctx.fill();
                    
                    // 池塘静态倒影 - 樱花树的倒影
                    ctx.fillStyle = 'rgba(255, 182, 193, 0.1)';
                    for (let i = 0; i < 3; i++) {
                        const reflectionX = element.x + element.width/2 + (i-1) * 30;
                        const reflectionY = element.y;
                        const reflectionSize = 10 + i * 5;
                        
                        ctx.beginPath();
                        ctx.moveTo(reflectionX - reflectionSize, reflectionY);
                        ctx.quadraticCurveTo(
                            reflectionX, 
                            reflectionY + 8,
                            reflectionX + reflectionSize, 
                            reflectionY
                        );
                        ctx.fill();
                    }
                }
                else if (element.type === 'stone') {
                    // 绘制装饰石头
                    const stoneGradient = ctx.createRadialGradient(
                        element.x, element.y - element.size/3, 0,
                        element.x, element.y - element.size/3, element.size
                    );
                    stoneGradient.addColorStop(0, '#A0A0A0');
                    stoneGradient.addColorStop(1, '#707070');
                    
                    ctx.fillStyle = stoneGradient;
                    
                    // 根据石头形状绘制不同样式
                    if (element.shape === 0) {
                        // 圆形石头
                        ctx.beginPath();
                        ctx.arc(
                            element.x, 
                            element.y, 
                            element.size/2, 
                            0, Math.PI * 2
                        );
                        ctx.fill();
                    } 
                    else if (element.shape === 1) {
                        // 椭圆形石头
                        ctx.beginPath();
                        ctx.ellipse(
                            element.x, 
                            element.y, 
                            element.size * 0.7, 
                            element.size * 0.4, 
                            0, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                    else {
                        // 不规则石头
                        ctx.beginPath();
                        ctx.moveTo(element.x - element.size/2, element.y);
                        ctx.quadraticCurveTo(
                            element.x - element.size/2, element.y - element.size/2,
                            element.x, element.y - element.size/2
                        );
                        ctx.quadraticCurveTo(
                            element.x + element.size/2, element.y - element.size/2,
                            element.x + element.size/2, element.y
                        );
                        ctx.quadraticCurveTo(
                            element.x + element.size/3, element.y + element.size/3,
                            element.x, element.y + element.size/4
                        );
                        ctx.quadraticCurveTo(
                            element.x - element.size/3, element.y + element.size/3,
                            element.x - element.size/2, element.y
                        );
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // 石头高光
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.beginPath();
                    ctx.ellipse(
                        element.x - element.size * 0.2, 
                        element.y - element.size * 0.1, 
                        element.size * 0.15, 
                        element.size * 0.1, 
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
                else if (element.type === 'fence') {
                    // 绘制日式庭院栅栏
                    const postCount = 6;
                    const postWidth = 3;
                    const postSpacing = element.width / (postCount - 1);
                    
                    ctx.fillStyle = '#8B5A2B';
                    
                    // 绘制栅栏柱子
                    for (let i = 0; i < postCount; i++) {
                        const postX = element.x + i * postSpacing;
                        
                        ctx.fillRect(
                            postX - postWidth/2,
                            element.y - element.height,
                            postWidth,
                            element.height
                        );
                    }
                    
                    // 绘制栅栏横条
                    for (let i = 0; i < 2; i++) {
                        const barY = element.y - element.height * 0.8 + i * element.height * 0.5;
                        
                        ctx.fillRect(
                            element.x,
                            barY,
                            element.width,
                            2
                        );
                    }
                }
                else if (element.type === 'torii') {
                    // 绘制远处的鸟居
                    ctx.fillStyle = '#E53935'; // 传统朱红色
                    
                    // 顶部横梁
                    ctx.beginPath();
                    ctx.moveTo(element.x - 5, element.y - element.height * 0.9);
                    ctx.lineTo(element.x + element.width + 5, element.y - element.height * 0.9);
                    ctx.lineTo(element.x + element.width + 10, element.y - element.height * 0.85);
                    ctx.lineTo(element.x + element.width + 10, element.y - element.height * 0.8);
                    ctx.lineTo(element.x - 10, element.y - element.height * 0.8);
                    ctx.lineTo(element.x - 10, element.y - element.height * 0.85);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 次横梁
                    ctx.fillRect(
                        element.x - 5,
                        element.y - element.height * 0.75,
                        element.width + 10,
                        element.height * 0.05
                    );
                    
                    // 左立柱
                    ctx.fillRect(
                        element.x,
                        element.y - element.height,
                        element.width * 0.1,
                        element.height
                    );
                    
                    // 右立柱
                    ctx.fillRect(
                        element.x + element.width * 0.9,
                        element.y - element.height,
                        element.width * 0.1,
                        element.height
                    );
                }
                else if (element.type === 'petal') {
                    // 绘制飘落的花瓣
                    ctx.save();
                    ctx.translate(element.x, element.y);
                    ctx.rotate(element.rotation);
                    
                    ctx.fillStyle = `${element.color}${Math.floor(element.opacity * 255).toString(16).padStart(2, '0')}`;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, element.size, element.size * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                    
                    // 每6帧更新一次花瓣位置，适当加快动画速度
                    if (frameCount % 6 === 0) {
                        // 花瓣下落和摇摆动作 - 适当加快
                        element.y += element.speed * 1.3; // 增加下落速度
                        element.x += Math.sin(frameCount * element.swaySpeed * 1.2) * element.swayAmount;
                        element.rotation += element.rotSpeed * 1.2;
                        
                        // 重置超出屏幕的花瓣
                        if (element.y > canvas.height) {
                            element.y = -10 - Math.random() * 50;
                            element.x = Math.random() * canvas.width;
                        }
                    }
                }
            }
            
            // 绘制地面
            const groundGradient = ctx.createLinearGradient(0, canvas.height - 30, 0, canvas.height);
            groundGradient.addColorStop(0, '#4A367A');
            groundGradient.addColorStop(1, '#3A2963');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
            
            // 绘制静态前景薄雾
            const mistGradient = ctx.createLinearGradient(0, canvas.height - 60, 0, canvas.height - 30);
            mistGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
            mistGradient.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
            
            ctx.fillStyle = mistGradient;
            ctx.fillRect(0, canvas.height - 60, canvas.width, 30);
        }
        
        function drawTreeBlossoms(centerX, centerY, width, height, intensity) {
            const clusterCount = Math.floor(width / 20);
            const petalCount = Math.floor(15 * intensity);
            
            // 为不同位置选择不同的粉色调
            const pinkColors = ['#FFCFD5', '#FFD6DE', '#FFB7C5', '#FFC8D8'];
            
            for (let i = 0; i < clusterCount; i++) {
                const clusterX = centerX + (i - clusterCount/2) * (width / clusterCount);
                const clusterY = centerY + Math.sin(i * 0.7) * height * 0.5;
                const clusterSize = 12 + Math.sin(i) * 4;
                
                const colorIndex = Math.floor(i % pinkColors.length);  // 确定性选择颜色，不使用随机
                ctx.fillStyle = pinkColors[colorIndex];
                
                for (let j = 0; j < petalCount; j++) {
                    // 创建自然分布的花朵簇 - 完全确定性，不使用随机
                    const angle = j * (Math.PI * 2 / petalCount);
                    const distance = ((j % 5) / 5) * clusterSize;
                    const petalX = clusterX + Math.cos(angle) * distance;
                    const petalY = clusterY + Math.sin(angle) * distance * 0.7;
                    const petalSize = 2 + (j % 3);
                    
                    ctx.beginPath();
                    ctx.arc(petalX, petalY, petalSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function createMeteorShower() {
            meteors = [];
            // Initial meteors
            for (let i = 0; i < 3; i++) {
                addMeteor();
            }
        }
        
        function addMeteor() {
            meteors.push({
                x: Math.random() * canvas.width,
                y: -10,
                speed: 3 + Math.random() * 5,
                length: 20 + Math.random() * 30,
                width: 2 + Math.random() * 2,
                color: `hsl(${Math.random() * 60 + 10}, 100%, 70%)`, // Varying meteor colors
                active: true
            });
        }
        
        function drawMeteors() {
            // 绘制更梦幻的流星雨背景
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#0D0221'); // 深紫色顶部
            skyGradient.addColorStop(0.3, '#170B3B'); // 深靛紫色
            skyGradient.addColorStop(0.6, '#1D1160'); // 蓝紫色
            skyGradient.addColorStop(0.8, '#2A1B67'); // 靛蓝色
            skyGradient.addColorStop(1, '#380E61'); // 暗紫色底部
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        
            // 绘制远山
            // 第一层山脉（远） - 增加高度和可见度
            ctx.fillStyle = 'rgba(48, 25, 90, 0.7)'; // 更深、更不透明的紫色
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 35);
            for (let x = 0; x < canvas.width; x += 60) {
                const height = 45 + Math.sin(x * 0.008) * 20; // 显著增加高度和振幅
                ctx.lineTo(x, canvas.height - height);
            }
            ctx.lineTo(canvas.width, canvas.height - 40);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();
            
            // 第二层山脉（近） - 增加高度和对比度
            ctx.fillStyle = 'rgba(38, 20, 75, 0.8)'; // 更不透明的近景山脉
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 25);
            for (let x = 0; x < canvas.width; x += 50) {
                const height = 30 + Math.sin(x * 0.015 + 30) * 15; // 增加高度和起伏
                ctx.lineTo(x, canvas.height - height);
            }
            ctx.lineTo(canvas.width, canvas.height - 20);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();
            
            // 绘制背景中闪烁的恒星
            for (let i = 0; i < 100; i++) {
                const x = (i * 17 + frameCount * 0.01) % canvas.width;
                const y = (i * 23) % canvas.height;
                const size = (Math.sin(frameCount * 0.01 + i) * 0.5 + 0.5) * 2 + 0.5;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + Math.sin(frameCount * 0.02 + i * 0.1) * 0.3})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // 偶尔添加光晕
                if (size > 2) {
                    const glow = ctx.createRadialGradient(x, y, 0, x, y, size * 3);
                    glow.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    glow.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(x, y, size * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // 绘制远处的星系
            ctx.save();
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            const galaxyX = canvas.width * 0.3;
            const galaxyY = canvas.height * 0.3;
            const galaxyRadius = 80;
            const spiralArms = 3;
            
            for (let t = 0; t < 30; t += 0.1) {
                const scale = 1 - Math.pow(t / 30, 0.5);
                for (let arm = 0; arm < spiralArms; arm++) {
                    const angle = t + (Math.PI * 2 * arm / spiralArms);
                    const x = galaxyX + Math.cos(angle) * t * scale * galaxyRadius / 30;
                    const y = galaxyY + Math.sin(angle) * t * scale * galaxyRadius / 30;
                    const size = 1.5 - (t / 30);
                    
                    if (size > 0) {
                        ctx.fillStyle = `rgba(255, 240, 220, ${0.7 * (1 - t/30)})`;
                        ctx.fillRect(x, y, size, size);
                    }
                }
            }
            ctx.restore();
            
            // Update meteor positions and draw them
            for (let i = meteors.length - 1; i >= 0; i--) {
                const meteor = meteors[i];
                
                if (meteor.active) {
                    meteor.x += meteor.speed;
                    meteor.y += meteor.speed;
                    
                    // Draw meteor with improved gradient and glow effect
                    const gradient = ctx.createLinearGradient(
                        meteor.x, meteor.y, 
                        meteor.x - meteor.length, meteor.y - meteor.length
                    );
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(0.2, meteor.color);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    // Draw glow effect
                    ctx.save();
                    ctx.shadowColor = meteor.color;
                    ctx.shadowBlur = 15; // 增强发光效果
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = meteor.width;
                    ctx.lineCap = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(meteor.x, meteor.y);
                    ctx.lineTo(meteor.x - meteor.length, meteor.y - meteor.length);
                    ctx.stroke();
                    
                    ctx.restore();
                    
                    // Add enhanced particle trail
                    if (frameCount % 2 === 0) {
                        createParticles(meteor.x - Math.random() * 10, meteor.y - Math.random() * 10, meteor.color, 2);
                        
                        // 添加白色核心粒子
                        createParticles(meteor.x - Math.random() * 5, meteor.y - Math.random() * 5, "#FFFFFF", 1);
                    }
                    
                    // Check if meteor is out of view
                    if (meteor.x > canvas.width || meteor.y > canvas.height) {
                        meteor.active = false;
                    }
                }
            }
            
            // Remove inactive meteors and add new ones
            meteors = meteors.filter(m => m.active);
            
            if (meteors.length < 4 && Math.random() < 0.05) { // 增加流星生成概率
                addMeteor();
            }
            
            // Occasionally add a really bright/large meteor
            if (meteors.length < 6 && Math.random() < 0.003) { // 略微增加大流星概率
                const bigMeteor = {
                    x: Math.random() * canvas.width / 2,
                    y: -20,
                    speed: 2 + Math.random() * 3,
                    length: 60 + Math.random() * 60, // 更长的流星尾迹
                    width: 6 + Math.random() * 6, // 更粗的流星
                    color: `hsl(${Math.random() * 60}, 100%, 80%)`, // 随机暖色调
                    active: true
                };
                meteors.push(bigMeteor);
                
                // Create a more subtle flash effect
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)'; // 更柔和的闪光
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Add distant stars/meteors as background elements
            if (Math.random() < 0.15) { // 增加小流星频率
                const smallMeteor = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height / 2),
                    speed: 0.3 + Math.random() * 0.8,
                    length: 4 + Math.random() * 8,
                    width: 1,
                    color: `rgba(${150 + Math.random() * 105}, ${150 + Math.random() * 105}, 255, 0.6)`, // 蓝色调小流星
                    active: true
                };
                meteors.push(smallMeteor);
            }
        }
        
        function createFireworks() {
            fireworks = [];
            
            // Launch initial fireworks
            for (let i = 0; i < 5; i++) {
                launchFirework();
            }
            
            // 创建静态背景元素
            // 城市或神社剪影 - 放在底部
            const cityElements = [];
            const buildingCount = 8;
            
            for (let i = 0; i < buildingCount; i++) {
                const width = 30 + Math.random() * 50;
                const height = 40 + Math.random() * 80;
                const x = i * (canvas.width / buildingCount);
                
                cityElements.push({
                    type: 'building',
                    x: x,
                    y: canvas.height - 30,
                    width: width,
                    height: height,
                    windows: []
                });
                
                // 建筑物上的窗户
                const windowsPerRow = 3 + Math.floor(Math.random() * 2);
                const windowRows = Math.floor(height / 15);
                for (let row = 0; row < windowRows; row++) {
                    for (let col = 0; col < windowsPerRow; col++) {
                        if (Math.random() > 0.3) { // 不是所有窗户都亮着
                            const windowX = x + col * (width / windowsPerRow) + 5;
                            const windowY = canvas.height - 30 - height + row * 15 + 5;
                            cityElements.push({
                                type: 'window',
                                x: windowX,
                                y: windowY,
                                width: 5,
                                height: 8,
                                lit: Math.random() > 0.5
                            });
                        }
                    }
                }
            }
            
            // 神社或特殊建筑
            cityElements.push({
                type: 'shrine',
                x: canvas.width * 0.7,
                y: canvas.height - 30,
                width: 100,
                height: 70
            });
            
            // 存储到全局变量中
            fireworksCity = cityElements;
        }
        
        function launchFirework() {
            // 创建多样化的烟花，但减少特殊形状的频率（适当减少心形和圆形的出现频次）
            const specialEffects = ["starburst", "ring", "heart", "willow", "chrysanthemum"];
            // 降低特殊效果概率从0.3降到0.15
            const specialEffect = Math.random() < 0.15 ? 
                specialEffects[Math.floor(Math.random() * specialEffects.length)] : null;
            
            // 更多烟花颜色选择
            const colors = [
                { hue: 0, sat: 100, lig: 60 },      // 红色
                { hue: 30, sat: 100, lig: 60 },     // 橙色
                { hue: 60, sat: 100, lig: 60 },     // 黄色
                { hue: 120, sat: 100, lig: 60 },    // 绿色
                { hue: 180, sat: 100, lig: 60 },    // 青色
                { hue: 240, sat: 100, lig: 60 },    // 蓝色
                { hue: 280, sat: 100, lig: 70 },    // 紫色
                { hue: 300, sat: 100, lig: 70 },    // 粉色
                { hue: 330, sat: 100, lig: 70 }     // 粉红色
            ];
            
            const selectedColor = colors[Math.floor(Math.random() * colors.length)];
            
            // Create a new firework rocket
            const rocket = {
                x: Math.random() * canvas.width,
                y: canvas.height,
                targetY: 50 + Math.random() * 150,
                speed: 3 + Math.random() * 4,
                size: 2 + Math.random() * 2,
                color: `hsl(${selectedColor.hue}, ${selectedColor.sat}%, ${selectedColor.lig}%)`,
                exploded: false,
                particles: [],
                trailTimer: 0,
                specialEffect: specialEffect,
                baseHue: selectedColor.hue
            };
            
            fireworks.push(rocket);
        }
        
        function drawFireworks() {
            // 绘制美丽的夜空背景
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#0F0618');  // 深暗蓝紫色顶部
            skyGradient.addColorStop(0.4, '#160D36');  // 深蓝紫色
            skyGradient.addColorStop(0.7, '#1E0A40');  // 中间深紫色
            skyGradient.addColorStop(1, '#2A0A44');  // 底部紫色
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制月亮
            ctx.fillStyle = 'rgba(255, 255, 240, 0.9)';
            ctx.beginPath();
            ctx.arc(canvas.width * 0.15, canvas.height * 0.15, 30, 0, Math.PI * 2);
            ctx.fill();
            
            // 月亮光晕
            const moonGlow = ctx.createRadialGradient(
                canvas.width * 0.15, canvas.height * 0.15, 30,
                canvas.width * 0.15, canvas.height * 0.15, 100
            );
            moonGlow.addColorStop(0, 'rgba(255, 255, 240, 0.3)');
            moonGlow.addColorStop(1, 'rgba(255, 255, 240, 0)');
            ctx.fillStyle = moonGlow;
            ctx.beginPath();
            ctx.arc(canvas.width * 0.15, canvas.height * 0.15, 100, 0, Math.PI * 2);
            ctx.fill();
            
            // 绘制星星
            for (let i = 0; i < 100; i++) {
                const x = (i * 19) % canvas.width;
                const y = ((i * 17) % 200) + 5;
                const starSize = 0.5 + Math.random() * 1.5;
                const twinkle = Math.sin(frameCount * 0.05 + i) * 0.5 + 0.5;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + twinkle * 0.7})`;
                ctx.beginPath();
                ctx.arc(x, y, starSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // 绘制城市/神社剪影
            if (fireworksCity && fireworksCity.length > 0) {
                for (const element of fireworksCity) {
                    if (element.type === 'building') {
                        // 建筑物剪影
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(element.x, element.y - element.height, element.width, element.height);
                    }
                    else if (element.type === 'window') {
                        // 窗户
                        if (element.lit) {
                            ctx.fillStyle = 'rgba(255, 244, 214, 0.7)';
                        } else {
                            ctx.fillStyle = 'rgba(40, 40, 70, 0.9)';
                        }
                        ctx.fillRect(element.x, element.y, element.width, element.height);
                    }
                    else if (element.type === 'shrine') {
                        // 神社屋顶
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.moveTo(element.x, element.y - element.height * 0.7);
                        ctx.lineTo(element.x + element.width, element.y - element.height * 0.7);
                        ctx.lineTo(element.x + element.width * 0.75, element.y - element.height);
                        ctx.lineTo(element.x + element.width * 0.25, element.y - element.height);
                        ctx.closePath();
                        ctx.fill();
                        
                        // 神社底部
                        ctx.fillRect(
                            element.x + element.width * 0.15, 
                            element.y - element.height * 0.7, 
                            element.width * 0.7, 
                            element.height * 0.7
                        );
                        
                        // 神社鸟居
                        ctx.fillStyle = '#400000';
                        // 顶部横梁
                        ctx.fillRect(
                            element.x + element.width * 0.05,
                            element.y - element.height * 0.6,
                            element.width * 0.9,
                            5
                        );
                        // 底部横梁
                        ctx.fillRect(
                            element.x + element.width * 0.15,
                            element.y - element.height * 0.5,
                            element.width * 0.7,
                            4
                        );
                        // 左侧柱子
                        ctx.fillRect(
                            element.x + element.width * 0.2,
                            element.y - element.height * 0.5,
                            5,
                            element.height * 0.5 - 5
                        );
                        // 右侧柱子
                        ctx.fillRect(
                            element.x + element.width * 0.8 - 5,
                            element.y - element.height * 0.5,
                            5,
                            element.height * 0.5 - 5
                        );
                    }
                }
            }
            
            // Update and draw each firework
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const fw = fireworks[i];
                
                if (!fw.exploded) {
                    // Draw rocket in upward trajectory
                    fw.y -= fw.speed;
                    
                    // Create rocket trail
                    fw.trailTimer++;
                    if (fw.trailTimer > 2) {
                        fw.trailTimer = 0;
                        // Add trail particles
                        for (let j = 0; j < 4; j++) {
                            fw.particles.push({
                                x: fw.x + (Math.random() * 2 - 1),
                                y: fw.y + (Math.random() * 2 - 1) + 5,
                                vx: Math.random() * 1.5 - 0.75,
                                vy: Math.random() * 1.5 + 1.5,
                                size: Math.random() * 3 + 1,
                                color: '#FFA500',
                                alpha: 1,
                                isTrail: true
                            });
                        }
                    }
                    
                    // Draw the rocket body with glow effect
                    ctx.save();
                    ctx.shadowColor = fw.color;
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(fw.x, fw.y, 2, 6);
                    ctx.restore();
                    
                    // Check if rocket should explode
                    if (fw.y <= fw.targetY) {
                        fw.exploded = true;
                        
                        // 烟花爆炸音效
                        // (如果需要添加音效，可以在这里)
                        
                        // 根据特殊效果创建粒子
                        if (fw.specialEffect === "starburst") {
                            // 星爆效果 - 放射状
                            const particleCount = 120;
                            const arms = 16;
                            
                            for (let arm = 0; arm < arms; arm++) {
                                const baseAngle = (arm / arms) * Math.PI * 2;
                                
                                for (let j = 0; j < particleCount / arms; j++) {
                                    const angle = baseAngle + (Math.random() * 0.1 - 0.05);
                                    const speed = 1 + Math.random() * 4;
                                    
                                    const hueVariation = (Math.random() * 20) - 10;
                                    const particleColor = `hsla(${fw.baseHue + hueVariation}, 100%, 60%, 1)`;
                                    
                                    fw.particles.push({
                                        x: fw.x,
                                        y: fw.y,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed,
                                        size: Math.random() * 3 + 2,
                                        color: particleColor,
                                        alpha: 1,
                                        isTrail: false,
                                        decay: 0.01 + Math.random() * 0.01
                                    });
                                }
                            }
                        }
                        else if (fw.specialEffect === "ring") {
                            // 环形效果
                            const particleCount = 150;
                            const ringRadius = 3 + Math.random() * 2;
                            
                            for (let j = 0; j < particleCount; j++) {
                                const angle = (j / particleCount) * Math.PI * 2;
                                const speed = ringRadius;
                                
                                const hueVariation = (j / particleCount) * 30;
                                const particleColor = `hsla(${fw.baseHue + hueVariation}, 100%, 60%, 1)`;
                                
                                fw.particles.push({
                                    x: fw.x,
                                    y: fw.y,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed,
                                    size: Math.random() * 2.5 + 1.5,
                                    color: particleColor,
                                    alpha: 1,
                                    isTrail: false,
                                    decay: 0.005 + Math.random() * 0.005
                                });
                            }
                        }
                        else if (fw.specialEffect === "heart") {
                            // 心形效果
                            const particleCount = 160;
                            const heartSize = 8;
                            
                            for (let j = 0; j < particleCount; j++) {
                                const t = (j / particleCount) * Math.PI * 2;
                                
                                // 心形方程
                                const x = 16 * Math.sin(t) * Math.sin(t) * Math.sin(t);
                                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                                
                                const hueVariation = Math.abs(t) * 5;
                                const particleColor = `hsla(${fw.baseHue + hueVariation}, 100%, 70%, 1)`;
                                
                                fw.particles.push({
                                    x: fw.x,
                                    y: fw.y,
                                    vx: x * heartSize * 0.08,
                                    vy: -y * heartSize * 0.08,
                                    size: Math.random() * 3 + 1.5,
                                    color: particleColor,
                                    alpha: 1,
                                    isTrail: false,
                                    decay: 0.007 + Math.random() * 0.005
                                });
                            }
                        }
                        else if (fw.specialEffect === "willow") {
                            // 柳树效果 - 下垂的粒子
                            const particleCount = 200;
                            
                            for (let j = 0; j < particleCount; j++) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 1 + Math.random() * 5;
                                
                                // 黄色到白色的渐变
                                const brightness = 70 + Math.random() * 30;
                                const particleColor = `hsla(${fw.baseHue}, 100%, ${brightness}%, 1)`;
                                
                                fw.particles.push({
                                    x: fw.x,
                                    y: fw.y,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed,
                                    gravity: 0.05 + Math.random() * 0.05, // 更高的重力
                                    size: Math.random() * 3 + 1,
                                    color: particleColor,
                                    alpha: 1,
                                    isTrail: false,
                                    decay: 0.003 + Math.random() * 0.002
                                });
                            }
                        }
                        else if (fw.specialEffect === "chrysanthemum") {
                            // 菊花效果 - 多层次爆炸
                            const layers = 3 + Math.floor(Math.random() * 2);
                            const particlesPerLayer = 50;
                            
                            for (let layer = 0; layer < layers; layer++) {
                                const speed = 1 + layer * 1.5;
                                const hueOffset = layer * 15;
                                
                                for (let j = 0; j < particlesPerLayer; j++) {
                                    const angle = (j / particlesPerLayer) * Math.PI * 2;
                                    const particleColor = `hsla(${fw.baseHue + hueOffset}, 100%, 60%, 1)`;
                                    
                                    fw.particles.push({
                                        x: fw.x,
                                        y: fw.y,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed,
                                        size: Math.random() * 3 + 1.5,
                                        color: particleColor,
                                        alpha: 1,
                                        isTrail: false,
                                        decay: 0.007 + Math.random() * 0.005
                                    });
                                }
                            }
                        }
                        else {
                            // 标准爆炸效果 - 但更加丰富
                            const particleCount = 120 + Math.floor(Math.random() * 80);
                            
                            for (let j = 0; j < particleCount; j++) {
                                // 创建360度图案的爆炸粒子
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 1 + Math.random() * 4;
                                
                                // 在同一烟花内部的颜色变化
                                const hueVariation = (Math.random() * 30) - 15;
                                const brightness = 60 + Math.random() * 20;
                                const particleColor = `hsla(${fw.baseHue + hueVariation}, 100%, ${brightness}%, 1)`;
                                
                                fw.particles.push({
                                    x: fw.x,
                                    y: fw.y,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed,
                                    size: Math.random() * 3 + 1.5,
                                    color: particleColor,
                                    alpha: 1,
                                    isTrail: false,
                                    decay: 0.01 + Math.random() * 0.01
                                });
                            }
                        }
                    }
                }
                
                // Update and draw particle effects
                for (let j = fw.particles.length - 1; j >= 0; j--) {
                    const p = fw.particles[j];
                    
                    // Update particle position
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    // Apply gravity to explosion particles
                    if (!p.isTrail) {
                        p.vy += p.gravity || 0.05; // 默认重力或自定义重力
                    }
                    
                    // Fade particles
                    p.alpha -= p.isTrail ? 0.1 : (p.decay || 0.01);
                    
                    // Draw particle with glow effect
                    ctx.save();
                    ctx.globalAlpha = p.alpha;
                    if (!p.isTrail) {
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = 5;
                    }
                    ctx.fillStyle = p.isTrail ? 'rgba(255, 165, 0, ' + p.alpha + ')' : p.color;
                    
                    // 不同形状的粒子
                    if (Math.random() > 0.9 && !p.isTrail) {
                        // 偶尔绘制星形粒子
                        const size = p.size * 1.2;
                        drawStar(p.x, p.y, 5, size, size / 2);
                    } else {
                        // 圆形粒子
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                    
                    // Remove faded particles
                    if (p.alpha <= 0) {
                        fw.particles.splice(j, 1);
                    }
                }
                
                // Remove fireworks with no particles left and that have exploded
                if (fw.particles.length === 0 && fw.exploded) {
                    fireworks.splice(i, 1);
                }
            }
            
            // 绘制全场景光照效果
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const fw = fireworks[i];
                if (fw.exploded) {
                    // 为爆炸的烟花添加整体光照
                    const particleCount = fw.particles.length;
                    if (particleCount > 0) {
                        // 计算爆炸中心
                        let centerX = 0;
                        let centerY = 0;
                        for (const p of fw.particles) {
                            centerX += p.x;
                            centerY += p.y;
                        }
                        centerX /= particleCount;
                        centerY /= particleCount;
                        
                        // 增加整体光晕
                        const glow = ctx.createRadialGradient(
                            centerX, centerY, 0,
                            centerX, centerY, 150
                        );
                        // 从烟花颜色到透明
                        glow.addColorStop(0, `hsla(${fw.baseHue}, 100%, 60%, 0.2)`);
                        glow.addColorStop(1, `hsla(${fw.baseHue}, 100%, 60%, 0)`);
                        
                        ctx.fillStyle = glow;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, 150, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // Randomly launch new fireworks - 降低发射频率和最大数量
            if (Math.random() < 0.03 && fireworks.length < 10) {
                launchFirework();
            }
            
            // Add overall glow effect to the scene
            ctx.fillStyle = 'rgba(255, 200, 100, 0.005)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // 绘制星形函数
        function drawStar(x, y, points, outerRadius, innerRadius) {
            ctx.beginPath();
            
            for (let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i * Math.PI) / points;
                
                ctx.lineTo(
                    x + radius * Math.sin(angle),
                    y + radius * Math.cos(angle)
                );
            }
            
            ctx.closePath();
            ctx.fill();
        }
        
        // 辅助函数 - 绘制月亮和星星
        function drawMoonAndStars() {
            // 绘制月亮
            ctx.fillStyle = 'rgba(255, 255, 240, 0.9)';
            ctx.beginPath();
            ctx.arc(canvas.width * 0.85, canvas.height * 0.15, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // 月亮光晕
            const moonGlow = ctx.createRadialGradient(
                canvas.width * 0.85, canvas.height * 0.15, 25,
                canvas.width * 0.85, canvas.height * 0.15, 80
            );
            moonGlow.addColorStop(0, 'rgba(255, 255, 240, 0.3)');
            moonGlow.addColorStop(1, 'rgba(255, 255, 240, 0)');
            ctx.fillStyle = moonGlow;
            ctx.beginPath();
            ctx.arc(canvas.width * 0.85, canvas.height * 0.15, 80, 0, Math.PI * 2);
            ctx.fill();
            
            // 绘制星星
            for (let i = 0; i < 80; i++) {
                const x = (i * 21) % canvas.width;
                const y = ((i * 31) % 180) + 5;
                const starSize = 0.5 + Math.random() * 1.5;
                const twinkle = Math.sin(frameCount * 0.02 + i) * 0.5 + 0.5;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + twinkle * 0.7})`;
                ctx.beginPath();
                
                // 有时绘制闪亮的星星
                if (i % 12 === 0) {
                    drawStar(x, y, 4, starSize * 1.5, starSize * 0.6);
                } else {
                    ctx.arc(x, y, starSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Event listeners
        startBtn.addEventListener('click', function() {
            startScreen.style.display = 'none';
            resetGame();
            gameLoop();
        });

        restartBtn.addEventListener('click', () => {
            gameOverScreen.style.display = 'none';
            gameRunning = true;
            score = 0;
            scoreDisplay.textContent = '0';  // 添加这行来更新显示的金牌数量
            teaCount = 2;
            document.getElementById('tea-count').textContent = teaCount;
            distance = 0;
            distanceDisplay.textContent = '0';
            gameSpeed = 5;
            obstacles = [];
            medals = [];
            player.y = GROUND_Y;
            player.yVelocity = 0;
            player.jumping = false;
            player.invincible = false;
            player.invincibleTimer = 0;
            frameCount = 0;
            lastMilestone = 0;
            currentBgStage = 0;
            activeSceneName = null;
            gameLoop();
        });

        jumpBtn.addEventListener('touchstart', jump);
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameRunning) {
                jump();
            } else if (e.code === 'Space' && !gameRunning && !gameOverScreen.style.display === 'flex') {
                startGame();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                endJump();
            }
        });
        
        canvas.addEventListener('mousedown', () => {
            if (gameRunning) {
                jump();
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            endJump();
        });
        
        // Mobile touch events
        jumpBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameRunning) {
                jump();
            }
        });
        
        jumpBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            endJump();
        });

        // Jump variables
        let jumpKeyPressed = false;
        let jumpPressTime = 0;
        let maxJumpHoldTime = 350; // Maximum time in ms to hold for full jump power
        let minJumpForce = 12;
        let maxJumpForce = 18;
        let jumpFeedbackActive = false;
        let jumpFeedbackTime = 0;

        function jump() {
            if (!player.jumping) {
                player.jumping = true;
                player.jumpTimeStart = Date.now();
                player.yVelocity = -player.jumpForce;
                player.jumpPower = 0;
            }
        }

        function endJump() {
            if (jumpKeyPressed) {
                jumpKeyPressed = false;
                
                // Calculate how long the jump button was held
                const holdTime = Math.min(Date.now() - player.jumpTimeStart, player.maxJumpHoldTime);
                const jumpPower = minJumpForce + ((maxJumpForce - minJumpForce) * (holdTime / player.maxJumpHoldTime));
                
                // Apply the calculated jump force (only if it's more powerful than current velocity)
                if (-jumpPower < player.yVelocity) {
                    player.yVelocity = -jumpPower;
                }
            }
        }

        // 当前场景过渡变量
        let sceneFade = {
            active: false,
            fromScene: null,
            toScene: null,
            progress: 0,
            duration: 60  // 场景过渡持续60帧（约1秒）
        };
        
        // 改进的场景激活函数，添加过渡效果
        function activateScene(sceneName) {
            // 如果已经是当前场景，不做任何处理
            if (activeSceneName === sceneName) return;
            
            // 设置场景过渡
            sceneFade.active = true;
            sceneFade.fromScene = activeSceneName;
            sceneFade.toScene = sceneName;
            sceneFade.progress = 0;
            
            // 设置新的激活场景
            activeSceneName = sceneName;
            
            // 设置新场景的初始状态
            for (const element of bgElements) {
                if (element.name === sceneName) {
                    element.setup();
                }
            }
        }

        // 切换场景
        function switchScene(newScene) {
            // 只有在场景真正变化时才执行
            if (gameScene !== newScene) {
                gameScene = newScene;
                
                // 重置背景位置
                let bgX = 0;
                
                // 重置障碍物
                obstacles = [];
                
                // 根据场景创建背景云朵
                createClouds();
            }
        }
        
        // 场景检查和切换
        function checkAndSwitchScene() {
            // 基于分数切换场景 - 调整为3000米切换
            if (distance < 3000) {
                switchScene('sakura');
            } else if (distance < 6000) {
                switchScene('pirate');
            } else {
                switchScene('egypt');
            }
        }
        
        // 外星人飞船
        let ufo = {
            x: -80, // 从屏幕左侧开始
            y: 120,
            width: 60,
            height: 30,
            speed: 0.8,
            beamActive: false,
            beamTimer: 0,
            beamDuration: 150,
            beamCooldown: 0,
            lights: [],
            direction: 1, // 1向右移动，-1向左移动
            hover: 0
        };
        
        // 初始化飞船的灯光
        for (let i = 0; i < 8; i++) {
            ufo.lights.push({
                angle: i * (Math.PI * 2 / 8),
                color: `hsl(${i * 45}, 100%, 60%)`,
                phase: Math.random() * Math.PI * 2
            });
        }
        
        // 绘制UFO
        function drawUFO() {
            if (activeSceneName) return; // 只在初始夜空显示
            
            // 更新UFO位置
            ufo.hover = Math.sin(frameCount * 0.05) * 5; // 悬浮效果
            ufo.x += ufo.speed * ufo.direction;
            ufo.y = 120 + ufo.hover;
            
            // 检查是否需要改变方向
            if (ufo.x > canvas.width + 80) {
                ufo.direction = -1; // 向左移动
            } else if (ufo.x < -80) {
                ufo.direction = 1; // 向右移动
            }
            
            // 控制光束
            if (ufo.beamCooldown > 0) {
                ufo.beamCooldown--;
            } else if (!ufo.beamActive && Math.random() < 0.005) {
                ufo.beamActive = true;
                ufo.beamTimer = ufo.beamDuration;
            }
            
            if (ufo.beamActive) {
                ufo.beamTimer--;
                if (ufo.beamTimer <= 0) {
                    ufo.beamActive = false;
                    ufo.beamCooldown = 300; // 冷却时间
                }
            }
            
            // 绘制飞碟主体
            ctx.save();
            ctx.translate(ufo.x + ufo.width/2, ufo.y + ufo.height/2);
            if (ufo.direction === -1) {
                ctx.scale(-1, 1); // 左右翻转
            }
            
            // 舱体 - 椭圆形底部
            ctx.fillStyle = '#3A478F';
            ctx.beginPath();
            ctx.ellipse(0, 10, ufo.width/2, ufo.height/3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 舱体上部 - 圆顶
            ctx.fillStyle = '#596BB3';
            ctx.beginPath();
            ctx.ellipse(0, 0, ufo.width/3, ufo.height/3, 0, 0, Math.PI, true);
            ctx.fill();
            
            // 机舱窗户 - 透明圆顶
            ctx.fillStyle = 'rgba(144, 238, 255, 0.7)';
            ctx.beginPath();
            ctx.ellipse(0, 0, ufo.width/4, ufo.height/4, 0, 0, Math.PI, true);
            ctx.fill();
            
            // 舱体中部分隔线
            ctx.strokeStyle = '#252A52';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-ufo.width/2, 10);
            ctx.lineTo(ufo.width/2, 10);
            ctx.stroke();
            
            // 绘制灯光
            for (const light of ufo.lights) {
                const flickerIntensity = Math.sin(frameCount * 0.2 + light.phase) * 0.5 + 0.5;
                ctx.fillStyle = light.color;
                
                const radius = ufo.width/2 - 3;
                const x = Math.cos(light.angle) * radius;
                const y = Math.sin(light.angle) * (ufo.height/3 - 2) + 10;
                
                ctx.beginPath();
                ctx.arc(x, y, 2 + flickerIntensity * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // 灯光发光效果
                ctx.fillStyle = `${light.color}${Math.floor(flickerIntensity * 90).toString(16).padStart(2, '0')}`;
                ctx.beginPath();
                ctx.arc(x, y, 4 + flickerIntensity * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
            
            // 绘制光束
            if (ufo.beamActive) {
                const beamStartX = ufo.x + ufo.width/2;
                const beamStartY = ufo.y + ufo.height/2 + 5;
                const beamEndY = canvas.height - 30;
                const beamWidth = 25 + Math.sin(frameCount * 0.1) * 5;
                
                // 创建光束渐变
                const beamGradient = ctx.createLinearGradient(beamStartX, beamStartY, beamStartX, beamEndY);
                beamGradient.addColorStop(0, 'rgba(144, 238, 255, 0.8)');
                beamGradient.addColorStop(1, 'rgba(144, 238, 255, 0)');
                
                // 绘制光束
                ctx.fillStyle = beamGradient;
                ctx.beginPath();
                ctx.moveTo(beamStartX - beamWidth/2, beamStartY);
                ctx.lineTo(beamStartX + beamWidth/2, beamStartY);
                ctx.lineTo(beamStartX + beamWidth, beamEndY);
                ctx.lineTo(beamStartX - beamWidth, beamEndY);
                ctx.closePath();
                ctx.fill();
                
                // 光束内部线条
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    const linePos = beamStartY + (i * (beamEndY - beamStartY) / 5);
                    const lineWidth = beamWidth/2 + (i * beamWidth / 5);
                    
                    ctx.beginPath();
                    ctx.moveTo(beamStartX - lineWidth, linePos);
                    ctx.lineTo(beamStartX + lineWidth, linePos);
                    ctx.stroke();
                }
                
                // 光束粒子效果
                if (frameCount % 3 === 0) {
                    for (let i = 0; i < 2; i++) {
                        const particleX = beamStartX + (Math.random() - 0.5) * beamWidth;
                        const particleY = beamStartY + Math.random() * (beamEndY - beamStartY);
                        createParticles(particleX, particleY, 'rgba(144, 238, 255, 0.8)', 1);
                    }
                }
            }
        }

        // 创建云朵
        function createClouds() {
            clouds = [];
            const cloudCount = 5 + Math.floor(Math.random() * 3);
            
            for (let i = 0; i < cloudCount; i++) {
                // 创建更美观的云朵
                const cloud = {
                    x: Math.random() * canvas.width,
                    y: 50 + Math.random() * 100,
                    width: 80 + Math.random() * 120,
                    height: 30 + Math.random() * 20,
                    speed: (Math.random() * 0.5 + 0.2) * gameSpeed * 0.2,
                    puffs: [] // 云朵组成部分
                };
                
                // 为每朵云创建多个绒毛状的部分
                const puffCount = 4 + Math.floor(Math.random() * 3);
                for (let j = 0; j < puffCount; j++) {
                    // 让每个部分按照比例分布
                    const puffSize = cloud.height * (0.6 + Math.random() * 0.7);
                    // 给每个部分一个合理的初始位置，形成自然的云形状
                    cloud.puffs.push({
                        x: cloud.x + (j / (puffCount - 1)) * cloud.width,
                        y: cloud.y + Math.sin(j * 0.8) * (cloud.height * 0.2),
                        size: puffSize
                    });
                }
                
                clouds.push(cloud);
            }
        }

        function drawClouds() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            
            for (const cloud of clouds) {
                // 移动云朵
                cloud.x -= cloud.speed;
                
                // 重置离开屏幕的云朵
                if (cloud.x + cloud.width < 0) {
                    cloud.x = canvas.width;
                    cloud.y = 50 + Math.random() * 100;
                    // 重新计算云朵绒毛部分的位置
                    for (let i = 0; i < cloud.puffs.length; i++) {
                        cloud.puffs[i].y = cloud.y + Math.sin(i * 0.8) * (cloud.height * 0.2);
                    }
                }
                
                // 绘制改进的多绒毛状云朵
                for (const puff of cloud.puffs) {
                    // 绘制圆形绒毛
                    ctx.beginPath();
                    ctx.arc(puff.x, puff.y, puff.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function startGame() {
            try {
                gameRunning = true;
                gameOverScreen.style.display = 'none';
                startScreen.style.display = 'none';
            // 重置游戏状态
                distance = 0;
                gameSpeed = 5;
                score = 0;
                obstacles = [];
                medals = [];
                teaCount = 2;
        
        // 重置背景状态
                if (currentMap === "newMap") {
                currentBackgroundState.current = 'bg1';
                currentBackgroundState.next = null;
                currentBackgroundState.fadeProgress = 0;
                currentBackgroundState.isFading = false;
                currentBackgroundState.lastChangeDistance = 0;
                }
        
        // 重置玩家状态
                player.x = 50;
                player.y = GROUND_Y;
                player.jumping = false;
                player.yVelocity = 0;
                player.invincible = false;
                player.invincibleTimer = 0;
        
                requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error("启动游戏错误:", error);
                gameRunning = false;
            }
        }

        function restartGame() {
            startGame();
        }

        function gameOver() {
            gameRunning = false;
            gameoverSound.currentTime = 0;
            gameoverSound.play();
            
            // 检查角色解锁条件
            if (score >= UNLOCK_SCORE && !window.characterUnlocked.sprite02) {
                window.characterUnlocked.sprite02 = true;
                saveUnlockStatus();

                setTimeout(() => {
                    showUnlockNotification('小嘎小哞已解锁！');
                }, 1000);
            }

            // 添加：检查地图解锁条件
            if (score >= MAP_UNLOCK_SCORE && !mapUnlocked.newMap) {
                mapUnlocked.newMap = true;
                saveMapUnlockStatus();
                
                setTimeout(() => {
                    showUnlockNotification('地图：末日旅行已解锁！');
                }, 1500);  // 延迟显示，避免与角色解锁提示重叠
    }
            if (score > highScore) {
                highScore = score;
            }
            
            finalScoreDisplay.textContent = `金牌数量: ${score}`;
            highScoreDisplay.textContent = `最高金牌数量: ${highScore}`;
            finalDistanceDisplay.textContent = `距离: ${distance}米`;
            
            updateCharacterSelectionUI(); 
            // 移除游戏结束界面中的所有元素，以便重新排列
            const restartBtn = document.getElementById('restart-btn');
            const authorCredit = gameOverScreen.querySelector('.author-credit') || gameOverScreen.querySelector('div[style*="margin-top: 15px"]');
    
    // 临时保存这些元素
            if (restartBtn) restartBtn.remove();
            if (authorCredit) authorCredit.remove();

            // 添加：移除之前的地图选择区域（如果存在）
            const existingMapSelection = gameOverScreen.querySelector('.map-selection-container');
            if (existingMapSelection) {
                existingMapSelection.remove();
    }
    
    // 添加：创建地图选择区域
            const mapSelectionContainer = document.createElement('div');
            mapSelectionContainer.className = 'map-selection-container';
            mapSelectionContainer.style.marginTop = '3px';
            mapSelectionContainer.style.marginBottom = '3px'; // 添加底部间距
            mapSelectionContainer.style.display = 'flex';
            mapSelectionContainer.style.flexDirection = 'column';
            mapSelectionContainer.style.alignItems = 'center';
    
    // 添加：创建标题
            const mapSelectionTitle = document.createElement('div');
            mapSelectionTitle.textContent = '选择地图';
            mapSelectionTitle.style.fontSize = '16px';
            mapSelectionTitle.style.marginBottom = '3px';
            mapSelectionTitle.style.color = 'var(--accent-light)'; // 与角色选择标题颜色一致
            mapSelectionContainer.appendChild(mapSelectionTitle);
    
    // 添加：创建按钮容器
            const mapButtonsContainer = document.createElement('div');
            mapButtonsContainer.style.display = 'flex';
            mapButtonsContainer.style.gap = '8px';
    
    // 添加：创建地图按钮
            Object.keys(mapConfigs).forEach(mapKey => {
                const mapConfig = mapConfigs[mapKey];
                const mapButton = document.createElement('div');
                mapButton.className = 'map-button';
                mapButton.textContent = mapConfig.name;
                mapButton.style.padding = '8px 15px';
                mapButton.style.position = 'relative';  // 添加：设置相对定位，用于添加解锁提示

                // 添加：检查地图是否解锁
                const isUnlocked = mapUnlocked[mapKey];
    
                if (isUnlocked) {
        // 已解锁地图样式
                    mapButton.style.backgroundColor = currentMap === mapKey ? 'var(--primary-color)' : 'var(--background-light)';
                    mapButton.style.cursor = 'pointer';
                } else {
        // 未解锁地图样式
                    mapButton.style.backgroundColor = 'rgba(80, 80, 80, 0.5)';
                    mapButton.style.cursor = 'not-allowed';
                    mapButton.style.color = 'rgba(255, 255, 255, 0.6)';
        
        // 添加解锁提示
                    const unlockHint = document.createElement('div');
                    unlockHint.textContent = `收集${mapConfig.unlockScore}块金牌解锁`;
                    unlockHint.style.position = 'absolute';
                    unlockHint.style.bottom = '-20px';
                    unlockHint.style.left = '0';
                    unlockHint.style.width = '100%';
                    unlockHint.style.fontSize = '12px';
                    unlockHint.style.color = 'var(--accent-light)';
                    mapButton.appendChild(unlockHint);
    }
                mapButton.style.backgroundColor = currentMap === mapKey ? 'var(--primary-color)' : 'var(--background-light)';
                mapButton.style.borderRadius = '5px';
                mapButton.style.cursor = 'pointer';
                mapButton.style.transition = 'all 0.2s';
        
        // 添加：添加地图描述提示
                mapButton.title = mapConfig.description;
        
        // 添加：添加点击事件
                mapButton.addEventListener('click', () => {
                // 添加：检查地图是否解锁
                    if (!isUnlocked) {
                // 未解锁时添加抖动效果
                        mapButton.classList.add('shake');
                        setTimeout(() => {
                            mapButton.classList.remove('shake');
                        }, 500);
            
            // 显示未解锁提示
                        showMilestoneNotification(`收集${mapConfig.unlockScore}块金牌解锁此地图`, '#FF6B6B');
                        return;
                    }
            
            // 添加：更新当前选择的地图
                    currentMap = mapKey;
            
            // 添加：更新按钮样式
                    document.querySelectorAll('.map-button').forEach(btn => {
                        if (btn.classList.contains('map-button')) {
                        btn.style.backgroundColor = 'var(--background-light)';
                        }
                    });
                mapButton.style.backgroundColor = 'var(--primary-color)';
            
            // 添加：显示地图切换提示
                showMilestoneNotification(`已切换到${mapConfig.name}！`, '#FFD700');
        });
        
        mapButtonsContainer.appendChild(mapButton);
    });
    
    mapSelectionContainer.appendChild(mapButtonsContainer);
    gameOverScreen.appendChild(mapSelectionContainer);
     // 重新添加"再玩一次"按钮和作者署名
    if (restartBtn) gameOverScreen.appendChild(restartBtn);
    if (authorCredit) gameOverScreen.appendChild(authorCredit);
    
            gameOverScreen.style.display = 'flex';
            
            cancelAnimationFrame(animationId);
            animationId = null;
        }

        function updateCharacterSelection() {
            const characterOptions = document.querySelectorAll('.character-option');
            characterOptions.forEach(option => {
                const characterType = option.getAttribute('data-character');
                option.classList.toggle('selected', characterType === currentCharacter);
            });
        }

        function spawnObstacle() {
            // Select obstacle type based on score, randomness, and current distance
            let availableTypes = [];
            let obstacleType, obstacleWidth, obstacleHeight, requiresJump;
            
            // 基于场景选择障碍物类型
            if (gameScene === 'sakura') {
                const types = [
                    obstacleTypes.HURDLE, 
                    obstacleTypes.POOL, 
                    obstacleTypes.PARALLEL_BARS, 
                    obstacleTypes.WATER_JUMP,
                    obstacleTypes.BALANCE_BEAM
                ];
                obstacleType = types[Math.floor(Math.random() * types.length)];
                
                if (obstacleType === obstacleTypes.HURDLE) {
                    obstacleWidth = 20;
                    obstacleHeight = 40;
                    requiresJump = true;
                } else if (obstacleType === obstacleTypes.POOL) {
                    obstacleWidth = 100;
                    obstacleHeight = 20;
                    requiresJump = Math.random() > 0.3; // 有些可以滑行穿过
                } else if (obstacleType === obstacleTypes.PARALLEL_BARS) {
                    obstacleWidth = 60;
                    obstacleHeight = 50;
                    requiresJump = true;
                } else if (obstacleType === obstacleTypes.WATER_JUMP) {
                    obstacleWidth = 80;
                    obstacleHeight = 25;
                    requiresJump = true;
                } else if (obstacleType === obstacleTypes.BALANCE_BEAM) {
                    obstacleWidth = 120;
                    obstacleHeight = 30;
                    requiresJump = true;
                }
            } 
            else if (gameScene === 'pirate') {
                const types = [
                    obstacleTypes.BARREL, 
                    obstacleTypes.BIRD, 
                    obstacleTypes.CRATE,
                    obstacleTypes.UNEVEN_BARS
                ];
                obstacleType = types[Math.floor(Math.random() * types.length)];
                
                if (obstacleType === obstacleTypes.BARREL) {
                    obstacleWidth = 35;
                    obstacleHeight = 35;
                    requiresJump = true;
                } else if (obstacleType === obstacleTypes.CRATE) {
                    obstacleWidth = 40;
                    obstacleHeight = 40;
                    requiresJump = true;
                } else if (obstacleType === obstacleTypes.UNEVEN_BARS) {
                    obstacleWidth = 70;
                    obstacleHeight = 60;
                    requiresJump = true;
                } else { // BIRD
                    obstacleWidth = 30;
                    obstacleHeight = 20;
                    // 鸟的高度是随机的
                    const birdY = canvas.height - 30 - (50 + Math.random() * 100);
                    requiresJump = birdY < canvas.height - 30 - player.height;
                    
                    // 创建飞鸟障碍
                    obstacles.push({
                        x: canvas.width,
                        y: birdY,
                        width: obstacleWidth,
                        height: obstacleHeight,
                        type: obstacleType,
                        requiresJump: requiresJump,
                        wingPosition: 0
                    });
                    
                    return; // 已经创建了鸟障碍，直接返回
                }
            } 
            else { // 埃及场景
                const types = [
                    obstacleTypes.CACTUS, 
                    obstacleTypes.SNAKE,
                    obstacleTypes.HIGH_JUMP,
                    obstacleTypes.POMMEL_HORSE
                ];
                obstacleType = types[Math.floor(Math.random() * types.length)];
                
                if (obstacleType === obstacleTypes.CACTUS) {
                    obstacleWidth = 25;
                    obstacleHeight = 40;
                    requiresJump = true;
                } else if (obstacleType === obstacleTypes.SNAKE) {
                    obstacleWidth = 40;
                    obstacleHeight = 15;
                    requiresJump = Math.random() > 0.4; // 有些可以滑行穿过
                } else if (obstacleType === obstacleTypes.HIGH_JUMP) {
                    obstacleWidth = 10;
                    obstacleHeight = 50;
                    requiresJump = true;
                } else if (obstacleType === obstacleTypes.POMMEL_HORSE) {
                    obstacleWidth = 70;
                    obstacleHeight = 50;
                    requiresJump = true;
                }
            }
            
            // 创建标准的地面障碍物
            obstacles.push({
                x: canvas.width,
                y: canvas.height - 30 - obstacleHeight,
                width: obstacleWidth,
                height: obstacleHeight,
                type: obstacleType,
                requiresJump: requiresJump
            });
        }

        function spawnMedal(forceGold = false) {
            // Check if there's already a gold medal in play - if so, don't spawn another one
            const goldMedalExists = medals.some(medal => medal.type === collectibleTypes.GOLD);
            const teaMedalExists = medals.some(medal => medal.type === collectibleTypes.TEA);
            
            // Only spawn if there's no gold medal and no tea medal already on screen
            // or if we're forcing a gold medal for game start
            if ((goldMedalExists && !forceGold) || (teaMedalExists && !forceGold)) {
                return; // Don't spawn anything if medals already exist
            }
            
            const lastObstacle = obstacles.length > 0 ? obstacles[obstacles.length - 1] : null;
            let medalX = canvas.width;
            let medalY = canvas.height - Math.random() * 120 - 80; // Higher position to make it more accessible
            
            // 15000米后的金牌放在更高、更难获取的位置
            if (distance > 15000 && Math.random() < 0.4 && !forceGold) {
                medalY = canvas.height - Math.random() * 180 - 120; // 更高的位置
            }
            
            // If there's an obstacle, make sure medal isn't too close to it
            if (lastObstacle) {
                // If the last obstacle is close to where we want to spawn the medal
                if (Math.abs(lastObstacle.x - medalX) < 180) {
                    // Either place it before or after the obstacle with enough gap
                    if (Math.random() > 0.5) {
                        medalX = lastObstacle.x - 100; // Before obstacle
                    } else {
                        medalX = lastObstacle.x + lastObstacle.width + 100; // After obstacle
                    }
                }
            }
            
            // 15000米后，偶尔在两个障碍物之间的空隙放置金牌
            if (distance > 15000 && obstacles.length >= 2 && Math.random() < 0.3 && !forceGold) {
                const prevObstacle = obstacles[obstacles.length - 2];
                const lastObstacle = obstacles[obstacles.length - 1];
                
                // 检查两个障碍物之间是否有足够空间
                if (lastObstacle && prevObstacle && 
                    lastObstacle.x - (prevObstacle.x + prevObstacle.width) > 200) {
                    // 在中间位置放置金牌
                    medalX = prevObstacle.x + prevObstacle.width + 
                             (lastObstacle.x - (prevObstacle.x + prevObstacle.width)) / 2;
                    // 偶尔在较高位置放置
                    if (Math.random() < 0.5) {
                        medalY = canvas.height - Math.random() * 180 - 120;
                    }
                }
            }
            
            // Decide what type of collectible to spawn
            // Tea is very rare (0.05 chance), only spawn if player has less than 2 teas,
            // we've traveled more than 500 meters, and no tea exists on screen
            if (!forceGold && teaCount < 2 && distance > 500 && Math.random() < 0.05 && !teaMedalExists) {
                // Tea should appear a bit higher for challenge
                medalY = Math.min(medalY, canvas.height - 150);
                
                medals.push({
                    x: medalX,
                    y: medalY,
                    width: medalSize,
                    height: medalSize,
                    type: collectibleTypes.TEA
                });
            } else if (forceGold || !goldMedalExists) {
                // Only spawn gold if no gold medal exists or we're forcing a gold medal
                medals.push({
                    x: medalX,
                    y: medalY,
                    width: medalSize,
                    height: medalSize,
                    type: collectibleTypes.GOLD
                });
            }
        }
        
        // 使用精灵图绘制玩家
        function drawPlayer() {
            ctx.save();
            
            const drawX = player.x;
            const drawY = player.y + cameraY;
            
            // 无敌状态特效
            if (player.invincible) {
                // 发光效果 - 使用茶绿色
                ctx.shadowColor = 'rgba(152, 251, 152, 0.7)'; // 改为淡绿色
                ctx.shadowBlur = 20 + Math.sin(Date.now() / 100) * 5;
                
                // 绘制光环 - 使用渐变色
                const glowSize = 2 + Math.sin(Date.now() / 200) * 0.5;
                ctx.globalAlpha = 0.3;
                
                // 创建径向渐变
                const gradient = ctx.createRadialGradient(
                    drawX + player.width/2, drawY + player.height/2, 0,
                    drawX + player.width/2, drawY + player.height/2, player.width/2 * glowSize
                );
                gradient.addColorStop(0, 'rgba(152, 251, 152, 0.5)');   // 内圈茶绿色
                gradient.addColorStop(0.6, 'rgba(173, 255, 47, 0.3)');  // 中间淡绿色
                gradient.addColorStop(1, 'rgba(50, 205, 50, 0)');       // 外圈深绿色
                
                ctx.beginPath();
                ctx.arc(drawX + player.width/2, drawY + player.height/2, 
                        player.width/2 * glowSize, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.globalAlpha = 1;
                
                // 生成星星粒子 - 使用茶绿色系
                if (Math.random() < 0.3) {
                    const colors = [
                        'rgba(152, 251, 152, ', // 淡绿色
                        'rgba(173, 255, 47, ',  // 黄绿色
                        'rgba(50, 205, 50, '    // 绿色
                    ];
                    player.sparkles.push({
                        x: drawX + Math.random() * player.width,
                        y: drawY + Math.random() * player.height,
                        size: 2 + Math.random() * 3,
                        speed: 1 + Math.random() * 2,
                        angle: Math.random() * Math.PI * 2,
                        life: 1,
                        color: colors[Math.floor(Math.random() * colors.length)] // 随机选择颜色
                    });
                }
            }
            
            // 收集茶道具时的闪光效果 - 添加绿色调
            if (player.teaCollectFlash > 0) {
                ctx.globalAlpha = player.teaCollectFlash;
                const flashGradient = ctx.createRadialGradient(
                    drawX + player.width/2, drawY + player.height/2, 0,
                    drawX + player.width/2, drawY + player.height/2, player.width
                );
                flashGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                flashGradient.addColorStop(0.5, 'rgba(152, 251, 152, 0.6)');
                flashGradient.addColorStop(1, 'rgba(50, 205, 50, 0)');
                
                ctx.fillStyle = flashGradient;
                ctx.fillRect(drawX - 20, drawY - 20, player.width + 40, player.height + 40);
                player.teaCollectFlash -= 0.05;
                ctx.globalAlpha = 1;
            }
            
            // 设置旋转中心点并应用倾斜
            ctx.translate(drawX + player.width/2, drawY + player.height/2);
            ctx.rotate(player.bodyTilt * Math.PI / 180);
            ctx.translate(-(drawX + player.width/2), -(drawY + player.height/2));
            
            // 更新动画帧
            if (player.jumping) {
                player.frameX = spriteConfig.jumpFrames.frames[2];
                player.frameY = spriteConfig.jumpFrames.row;
            } else {
                player.animationTimer += player.animationSpeed;
                player.runningPhase += player.animationSpeed;
                const runFrame = Math.floor(player.animationTimer) % spriteConfig.runFrames.frames.length;
                player.frameX = spriteConfig.runFrames.frames[runFrame];
                player.frameY = spriteConfig.runFrames.row;
            }
            
            // 绘制角色
            ctx.drawImage(
                characterSprite,
                player.frameX * spriteConfig.frameWidth,
                player.frameY * spriteConfig.frameHeight,
                spriteConfig.frameWidth,
                spriteConfig.frameHeight,
                drawX,
                drawY,
                player.width,
                player.height
            );
            
            // 绘制星星粒子
            player.sparkles = player.sparkles.filter(sparkle => {
                sparkle.y -= sparkle.speed;
                sparkle.x += Math.cos(sparkle.angle) * sparkle.speed;
                sparkle.life -= 0.02;
                
                if (sparkle.life > 0) {
                    ctx.beginPath();
                    ctx.arc(sparkle.x, sparkle.y, sparkle.size, 0, Math.PI * 2);
                    ctx.fillStyle = sparkle.color + sparkle.life + ')';
                    ctx.fill();
                    return true;
                }
                return false;
            });
            
            ctx.restore();
        }

        // 检测是否为竖屏模式
        function isPortraitMode() {
            return window.innerHeight > window.innerWidth || canvas.height > canvas.width;
        }

        // 获取当前跳跃速度方向（向上是负数）
        function getJumpDirection() {
            return Math.sign(player.yVelocity);
        }
        
        // 判断玩家是否在上升阶段
        function isPlayerRising() {
            return player.jumping && player.yVelocity < 0;
        }

        function updatePlayer() {
            // 保存上一帧的速度方向，用于检测方向变化
            const prevDirection = getJumpDirection();
            
            // Apply gravity
            player.yVelocity += gravity;
            player.y += player.yVelocity;
            
            // 动态相机系统，基于玩家状态的智能预测
            const isPortrait = isPortraitMode();
            
            // 根据屏幕方向设置不同的阈值
            // 竖屏模式下，使用更高的相机触发阈值（屏幕的30-40%）
            const cameraThreshold = isPortrait ? canvas.height * 0.4 : canvas.height / 3;
            
            // 预测性相机系统：根据玩家的速度和位置智能调整
            
            // 安全顶部边距调整 - 在竖屏模式下给予更多空间
            const topMargin = isPortrait ? 40 : 20;
            const currentDirection = getJumpDirection();
            
            // 预测下一帧的玩家位置，避免视觉延迟
            const predictedY = isPlayerRising() ? 
                player.y + player.yVelocity * 3 : // 向上移动时预测更多，减少延迟感
                player.y + player.yVelocity;
                
            // 极限情况处理：如果即将碰到顶部
            if (predictedY - cameraY < topMargin) {
                // 从顶部提供安全距离的相机位置
                const safeY = player.y - topMargin;
                // 平滑过渡
                cameraY = cameraY * 0.8 + safeY * 0.2;
                
                // 如果速度方向变化，额外施加缓冲，避免镜头抖动
                if (prevDirection !== currentDirection && currentDirection > 0) {
                    // 下落开始时稍微延迟相机下移
                    cameraY += player.yVelocity * 0.1;
                }
            }
            // 正常相机跟随逻辑 - 当玩家上升到阈值区域内
            else if (player.y < cameraThreshold) {
                // 计算目标相机位置，考虑竖屏模式的特殊因素
                const targetY = (cameraThreshold - player.y) * (isPortrait ? 1.15 : 1.0);
                
                // 平滑因子：在上升和下落阶段使用不同的平滑值，使动作更流畅
                const smoothFactor = isPlayerRising() ? 
                    (isPortrait ? 5 : 8) : // 上升阶段更快响应
                    (isPortrait ? 10 : 15); // 下落阶段更平缓
                
                // 更新相机位置
                cameraY += (targetY - cameraY) / smoothFactor;
            }
            // 如果玩家在阈值以下，逐渐回归原位
            else if (cameraY > 0) {
                // 如果已有相机偏移，则平滑返回
                const returnSpeed = isPortrait ? 0.05 : 0.03;
                cameraY *= (1 - returnSpeed);
                
                // 当相机接近零时，直接设为零以避免极小值抖动
                if (cameraY < 0.5) cameraY = 0;
            }
            
            // 地面碰撞检测
            if (player.y > canvas.height - player.height - groundHeight) {
                player.y = canvas.height - player.height - groundHeight;
                player.jumping = false;
                player.yVelocity = 0;
                
                // 落地时的粒子效果
                if (prevDirection > 0) { // 只在从空中落下时创建
                    const dustCount = Math.min(Math.abs(prevDirection) * 2, 8);
                    createParticles(player.x + player.width / 2, player.y + player.height, '#FFFFFF', dustCount);
                }
            }
        }

        function updateObstacles() {
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= gameSpeed;
                
                // Remove obstacles that are off screen
                if (obstacles[i].x + obstacles[i].width < 0) {
                    obstacles.splice(i, 1);
                    // Only adjust game speed based on distance
                    if (distance % 250 === 0 && gameSpeed < 10) { // Lower max speed from 12 to 10
                        gameSpeed += 0.2; // Even smaller increment for smoother difficulty
                    }
                }
            }
            
            // Spawn obstacles with difficulty progression
            if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - 300 - Math.random() * 200) {
                // Beginning easier stage (first 5 obstacles) - more time to learn
                if (score < 5) {
                    // Larger gaps between obstacles for beginners
                    if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - 600) {
                        spawnObstacle();
                    }
                } 
                // Mid-game difficulty
                else if (score < 25) {
                    if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - 500) {
                        spawnObstacle();
                    }
                }
                // Regular difficulty (still more space)
                else if (distance < 1000) {
                    if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - 400) {
                        spawnObstacle();
                    }
                }
                // Beyond 1000m, slightly easier for sustained play
                else {
                    if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - 450) {
                        spawnObstacle();
                    }
                }
                
                // Randomly spawn medals, with higher chance in the beginning
                const medalChance = score < 10 ? 0.6 : 0.35;
                if (Math.random() < medalChance) {
                    spawnMedal();
                }
            }
        }

        function updateMedals() {
            for (let i = medals.length - 1; i >= 0; i--) {
                medals[i].x -= gameSpeed;
                
                // Remove medals that are off screen
                if (medals[i].x + medals[i].width < 0) {
                    medals.splice(i, 1);
                }
            }
        }
        
        function checkMilestones() {
    // 计算当前所在的场景循环
    const cycleLength = 20700;
    const currentCycle = Math.floor(distance / cycleLength);
    const distanceInCycle = distance % cycleLength;

    // 统一的场景切换处理函数
    const switchScene = (newScene, sceneIndex) => {
        sceneFade.active = true;
        sceneFade.fromScene = activeSceneName;
        sceneFade.toScene = newScene;
        sceneFade.progress = 0;
        
        // 设置新场景
        if (newScene === null) {
            // 夜空体育场
            activeSceneName = null;
            currentBgStage = 0;
            showMilestoneNotification("回到体育场之夜！", "#FFD700");
        } else {
            const element = bgElements[sceneIndex];
            if (element.setup) element.setup();
            activeSceneName = element.name;
            currentBgStage = sceneIndex + 1;
            showMilestoneNotification(element.description, element.color);
        }
    };

    // 检查场景切换点
    if (currentMap === "initialMap") {  // 添加：检查当前地图
    if (distanceInCycle >= 17700 && distanceInCycle < 20700) {
        // 烟花场景
        if (activeSceneName !== 'fireworks') {
            switchScene('fireworks', 5);
        }
    } else if (distanceInCycle >= 21500 || distanceInCycle < 1200) {
        // 夜空体育场
        if (activeSceneName !== null) {
            switchScene(null, -1);
        }
    } else {
        // 检查其他场景里程碑
        for (let i = 0; i < bgElements.length; i++) {
            const element = bgElements[i];
            if (distanceInCycle >= element.distance && 
                distanceInCycle < element.distance + 100 && 
                activeSceneName !== element.name) {
                switchScene(element.name, i);
                break;
            }
        }
    }
    }
    // 更新场景过渡效果
    if (sceneFade.active) {
        sceneFade.progress++;
        if (sceneFade.progress >= sceneFade.duration) {
            sceneFade.active = false;
        }
    }
}
        
        function showMilestoneMessage(message, color) {
            milestoneNotification.textContent = message;
            milestoneNotification.style.color = color;
            milestoneNotification.style.opacity = 1;
            
            // Hide after 3 seconds
            setTimeout(() => {
                milestoneNotification.style.opacity = 0;
            }, 3000);
        }

        // Game difficulty levels
        const difficultyLevels = [
            { distance: 18000, speedMultiplier: 1.1, obstacleFrequency: 0.9, obstacleVarietyModifier: 1.2 }, 
            { distance: 26000, speedMultiplier: 1.15, obstacleFrequency: 0.8, obstacleVarietyModifier: 1.3 },
            { distance: 34000, speedMultiplier: 1.2, obstacleFrequency: 0.7, obstacleVarietyModifier: 1.4 },
            { distance: 42000, speedMultiplier: 1.25, obstacleFrequency: 0.65, obstacleVarietyModifier: 1.5 },
            { distance: 50000, speedMultiplier: 1.3, obstacleFrequency: 0.6, obstacleVarietyModifier: 1.6 }
        ];
        let currentDifficultyIndex = -1; // Start with base difficulty
        
        // Collision effects
        let collisionFlashActive = false;
        let collisionFlashTime = 0;
        let revivalEffectActive = false;
        let revivalParticles = [];

        function checkCollisions() {
            // 检查与收集物的碰撞
            for (let i = medals.length - 1; i >= 0; i--) {
                const medal = medals[i];
                if (
                    player.x < medal.x + medalSize &&
                    player.x + player.width > medal.x &&
                    player.y < medal.y + medalSize &&
                    player.y + player.height > medal.y
                ) {
                    collectSound.currentTime = 0;
                    collectSound.play();
                    
                    if (medal.type === collectibleTypes.GOLD) {
                        score++;
                        scoreDisplay.textContent = score;
                        createParticles(medal.x + medalSize/2, medal.y + medalSize/2, '#FFD700', 15);
                        
                        if (score >= UNLOCK_SCORE && !window.characterUnlocked.sprite02) {
                            window.characterUnlocked.sprite02 = true;
                            saveCharacterUnlockStatus();
        
        // 立即显示解锁提示
                            showUnlockNotification('恭喜！新角色"小嘎小哞"已解锁！');
                        }
                    // 添加：立即检查地图解锁条件
                    if (score >= MAP_UNLOCK_SCORE && !mapUnlocked.newMap) {
                        mapUnlocked.newMap = true;
                        saveMapUnlockStatus();
        
                    // 立即显示解锁提示
                        showUnlockNotification('地图：末日旅行已解锁！');
                    }
                    } else if (medal.type === collectibleTypes.TEA) {
                        teaCount++;
                        document.getElementById('tea-count').textContent = teaCount;
                        createParticles(medal.x + medalSize/2, medal.y + medalSize/2, '#66CC66', 15);
                    }
                    medals.splice(i, 1);
                }
            }

            // 如果玩家处于无敌状态，跳过碰撞检测
            if (player.invincible) {
                return;
            }

            // 检查与障碍物的碰撞
            for (const obstacle of obstacles) {
                const collisionMargin = 10;
                const playerHitbox = {
                    x: player.x + collisionMargin,
                    y: player.y + collisionMargin,
                    width: player.width - (collisionMargin * 2),
                    height: player.height - (collisionMargin * 2)
                };

                if (
                    playerHitbox.x < obstacle.x + obstacle.width &&
                    playerHitbox.x + playerHitbox.width > obstacle.x &&
                    playerHitbox.y < obstacle.y + obstacle.height &&
                    playerHitbox.y + playerHitbox.height > obstacle.y
                ) {
                    if (teaCount > 0) {
                        // 使用茶的效果
                        teaCount--;
                        
                        // 添加茶消耗的UI动画效果
                        const teaCountElement = document.getElementById('tea-container');
                        teaCountElement.style.transform = 'scale(1.3)';
                        teaCountElement.style.backgroundColor = 'rgba(102, 255, 102, 0.3)';
                        setTimeout(() => {
                            teaCountElement.style.transform = 'scale(1)';
                            teaCountElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                        }, 300);
                        
                        document.getElementById('tea-count').textContent = teaCount;
                        
                        // 创建更华丽的保护效果粒子
                        createTeaEffect(player.x + player.width/2, player.y + player.height/2);
                        
                        // 设置无敌状态
                        player.invincible = true;
                        setTimeout(() => {
                            player.invincible = false;
                        }, 2000);
                        
                        return;
                    } else {
                        // 没有茶就结束游戏
                        gameoverSound.currentTime = 0;
                        gameoverSound.play();
                        endGame();
                        return;
                    }
                }
            }
        }

        function endGame() {
             // 直接调用gameOver函数，而不是重复实现相同的功能
            gameOver();
        }

        function showRevivalMessage() {
            const message = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                text: "茶复活!",
                life: 60,
                yVelocity: -1,
                size: 30, // Starting size
                growing: true
            };
            
            // Create a temporary animation function to show the message
            const drawRevivalMessage = () => {
                if (message.life <= 0) return;
                
                // Pulse effect for text size
                if (message.growing) {
                    message.size += 0.5;
                    if (message.size >= 38) message.growing = false;
                } else {
                    message.size -= 0.5;
                    if (message.size <= 30) message.growing = true;
                }
                
                ctx.font = `${message.size}px Pixel, monospace`;
                ctx.textAlign = 'center';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 4;
                ctx.strokeText(message.text, message.x, message.y);
                ctx.fillStyle = '#00FF00';
                ctx.fillText(message.text, message.x, message.y);
                
                message.y += message.yVelocity;
                message.life--;
                
                if (message.life > 0) {
                    requestAnimationFrame(drawRevivalMessage);
                }
            };
            
            drawRevivalMessage();
        }

        function createRevivalEffect() {
            revivalEffectActive = true;
            
            // Create circular particles that expand outward
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                
                revivalParticles.push({
                    x: player.x + player.width / 2,
                    y: player.y + player.height / 2,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 5 + Math.random() * 5,
                    color: '#8AFF8A', // Light green
                    life: 60 + Math.random() * 20
                });
            }
            
            // Green glow around player (will be drawn separately)
        }

        function updateRevivalEffect() {
            if (!revivalEffectActive) return;
            
            // Update particles
            for (let i = revivalParticles.length - 1; i >= 0; i--) {
                const particle = revivalParticles[i];
                
                // Move particle
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // Decrease life
                particle.life--;
                
                // Remove dead particles
                if (particle.life <= 0) {
                    revivalParticles.splice(i, 1);
                }
            }
            
            // Check if all particles are gone
            if (revivalParticles.length === 0) {
                revivalEffectActive = false;
            }
        }

        function drawRevivalEffect() {
            if (!revivalEffectActive) return;
            
            // Draw particles
            for (const particle of revivalParticles) {
                ctx.globalAlpha = particle.life / 80; // Fade out as life decreases
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw glow around player when revival is active
            if (revivalEffectActive) {
                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#00FF00';
                ctx.beginPath();
                ctx.ellipse(
                    player.x + player.width / 2,
                    player.y + player.height / 2,
                    player.width * 0.8,
                    player.height * 0.8,
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                ctx.restore();
            }
            
            // Reset global alpha
            ctx.globalAlpha = 1;
        }

        // Collectible animation
        let pointsAnimations = [];
        
        function showCollectibleAnimation(x, y, text, color) {
            pointsAnimations.push({
                x: x,
                y: y,
                text: text,
                color: color,
                life: 30, // Frames the animation will last
                yVelocity: -2 // Animation moves upward
            });
        }
        
        function updatePointsAnimations() {
            for (let i = pointsAnimations.length - 1; i >= 0; i--) {
                const anim = pointsAnimations[i];
                // Move animation up
                anim.y += anim.yVelocity;
                // Decrease life
                anim.life--;
                // Remove dead animations
                if (anim.life <= 0) {
                    pointsAnimations.splice(i, 1);
                }
            }
        }
        
        function drawPointsAnimations() {
            for (const anim of pointsAnimations) {
                // Calculate opacity based on remaining life
                const opacity = anim.life / 30;
                ctx.globalAlpha = opacity;
                
                // Draw text with pixel art style
                ctx.font = '20px Pixel, monospace';
                ctx.textAlign = 'center';
                ctx.lineWidth = 2;
                
                // Draw outline for better visibility
                ctx.strokeStyle = 'black';
                ctx.strokeText(anim.text, anim.x, anim.y);
                
                // Draw text
                ctx.fillStyle = anim.color;
                ctx.fillText(anim.text, anim.x, anim.y);
            }
            
            ctx.globalAlpha = 1; // Reset alpha
        }
        
        let animationId = null;
        
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            drawSky();
            drawClouds();
            drawTrack();
            
            // 检查和应用难度设置
            let currentDifficulty = null;
            for (let i = 0; i < difficultyLevels.length; i++) {
                if (distance >= difficultyLevels[i].distance && 
                    (i > currentDifficultyIndex || currentDifficultyIndex === -1)) {
                    currentDifficultyIndex = i;
                    currentDifficulty = difficultyLevels[i];
                    
                    // 显示难度提升消息
                    showMilestoneMessage(`难度提升! 继续前进!`, '#FF5252');
                    break;
                }
            }
            
            // 如果有新的难度级别，应用它
            if (currentDifficulty && frameCount % 60 === 0) {
                gameSpeed = 5 * currentDifficulty.speedMultiplier;
            }
            
            // Update game objects
            updatePlayer();
            updateObstacles();
            updateMedals();
            updatePointsAnimations();
            updateRevivalEffect();
            updateParticles();
            
            // Check for milestone achievements
            checkMilestones();
            
            // Draw game objects
            drawObstacles();
            drawMedals();
            drawPlayer();
            
            // Draw effects
            drawRevivalEffect();
            drawPointsAnimations();
            drawParticles();
            
            // Draw collision flash if active
            if (collisionFlashActive) {
                ctx.fillStyle = `rgba(255, 0, 0, ${collisionFlashTime / 80})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                collisionFlashTime--;
                
                if (collisionFlashTime <= 0) {
                    collisionFlashActive = false;
                }
            }
            
            // Check collisions
            checkCollisions();
            
            // Update frame count and distance
            frameCount++;
            if (gameRunning) {
                // Update distance based on game speed and frame rate
                // Assuming approximately 60fps, distance increases proportionally to game speed
                distance += Math.round(gameSpeed / 5); // Convert game speed to approximate meters
                distanceDisplay.textContent = distance.toString();
            }
            
            if (gameRunning) {
                animationId = requestAnimationFrame(gameLoop);
            }
        }

        // Responsive canvas resizing
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // 在游戏重置时重置茶的数量
        function resetGame() {
            // 重置游戏状态
            gameRunning = true;
            score = 0;
            distance = 0;
            frameCount = 0;
            lastMilestone = 0;
            gameSpeed = 5;
            currentBgStage = 0;
            activeSceneName = null;
            
            // 重置玩家状态
            player.x = 50;
            player.y = GROUND_Y;
            player.jumping = false;
            player.yVelocity = 0;
            player.invincible = false;
            player.invincibleTimer = 0;
            player.sparkles = [];
            player.glowIntensity = 0;
            player.teaCollectFlash = 0;
            
            // 重置场景元素
            clouds = [];
            mountains = [];
            pirateElements = [];
            cherrySakura = [];
            gardenElements = [];
            meteors = [];
            fireworks = [];
            fireworksCity = [];
            
            // 重置障碍物和道具
            obstacles = [];
            teas = [];
            
            // 重置显示
            scoreDisplay.textContent = '0';
            distanceDisplay.textContent = '0';
            
             // 添加：根据当前地图设置初始场景
            if (currentMap === "newMap") {  // 添加：检查当前地图
        // 添加：新地图始终是夜空背景
                currentBackgroundState = {
                current: 'bg1',
                next: null,
                fadeProgress: 0,
                isFading: false,
                fadeDuration: 60,
                lastChangeDistance: 0
        }; // 【说明】：重置背景状态为初始值 
            } else {  // 添加：初始地图
        // 添加：初始地图从夜空体育场开始
                activeSceneName = null;  // 添加：设置活动场景为null（夜空）
                currentBgStage = 0;  // 添加：设置背景阶段为0
    }
            // 隐藏游戏结束界面
            gameOverScreen.style.display = 'none';
            
            // 重置背景场景
            gameScene = 'sakura'; // 重置为初始场景
            
            // 重新初始化第一个场景
            if (bgElements[0].setup) {
                bgElements[0].setup();
            }
            
            characterSprite.src = `${currentCharacter}.png`;
            updatePlayerAttributes();
        }

        // 添加茶特效函数
        function createTeaEffect(x, y) {
            // 创建绿色能量环
            for (let i = 0; i < 2; i++) {
                const ringParticles = 20;
                for (let j = 0; j < ringParticles; j++) {
                    const angle = (j / ringParticles) * Math.PI * 2;
                    const speed = 3 + i * 2;
                    particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 60,
                        maxLife: 60,
                        color: `rgba(102, 255, 102, ${0.8 - i * 0.3})`,
                        size: 8 - i * 2,
                        type: 'ring'
                    });
                }
            }

            // 创建上升的茶叶粒子
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -Math.random() * 4 - 2,
                    life: 45,
                    maxLife: 45,
                    color: '#90EE90',
                    size: 6,
                    type: 'leaf',
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2
                });
            }
        }

        // 更新粒子绘制函数
        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                
                if (p.type === 'ring') {
                    // 环形粒子
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / p.maxLife;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.type === 'leaf') {
                    // 茶叶粒子
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / p.maxLife;
                    
                    // 绘制茶叶形状
                    ctx.beginPath();
                    ctx.moveTo(0, -p.size);
                    ctx.quadraticCurveTo(p.size/2, 0, 0, p.size);
                    ctx.quadraticCurveTo(-p.size/2, 0, 0, -p.size);
                    ctx.fill();
                    
                    ctx.restore();
                    
                    // 更新茶叶旋转
                    p.rotation += p.rotationSpeed;
                } else {
                    // 普通粒子
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / p.maxLife;
                    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
                }
                
                // 更新粒子位置
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                // 移除死亡粒子
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            ctx.globalAlpha = 1;
        }

        // 更新茶道具收集逻辑
        function collectTea(tea) {
            teaCount++;
            teaCountDisplay.textContent = teaCount;
            player.invincible = true;
            player.invincibleTimer = Date.now();
            player.teaCollectFlash = 1; // 触发闪光效果
            
            // 播放收集音效
            collectSound.currentTime = 0;
            collectSound.play();
            
            // 创建收集特效
            createTeaCollectEffect(tea.x, tea.y);
        }

        // 添加茶道具收集特效
        function createTeaCollectEffect(x, y) {
            const colors = [
                'rgba(152, 251, 152, ', // 淡绿色
                'rgba(173, 255, 47, ',  // 黄绿色
                'rgba(50, 205, 50, '    // 绿色
            ];
            
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                player.sparkles.push({
                    x: x + 15,
                    y: y + 15,
                    size: 4,
                    speed: 3,
                    angle: angle,
                    life: 1,
                    color: colors[i % colors.length]
                });
            }
        }

        // 在updateGame中更新无敌状态
        function updateGame() {
            // ... existing code ...
            
            // 更新无敌状态
            if (player.invincible && Date.now() - player.invincibleTimer > player.invincibleDuration) {
                player.invincible = false;
                player.sparkles = []; // 清除所有特效粒子
            }
            
            // ... existing code ...
        }

        // 添加角色选择变量
        let currentCharacter = 'sprite';
        
        // 添加角色选择函数
        function setupCharacterSelection() {
            const characterOptions = document.querySelectorAll('.character-option');
            
            characterOptions.forEach(option => {
                option.addEventListener('click', function() {
                    characterOptions.forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                    
                    const characterType = this.getAttribute('data-character');
                    currentCharacter = characterType;
                    characterSprite.src = `${characterType}.png`;
                    
                    updatePlayerAttributes();
                });
            });
        }

        function updatePlayerAttributes() {
            if (currentCharacter === 'sprite02') {
                player.jumpForce = 12.5;
                player.maxJumpForce = 19;
            } else {
                player.jumpForce = 12;
                player.maxJumpForce = 18;
            }
        }

        // 初始化角色选择
        document.addEventListener('DOMContentLoaded', function() {
            // 我们的永久解决方案代码开始
    // 确保从localStorage加载解锁状态
    const savedStatus = localStorage.getItem('characterUnlocked');
    if (savedStatus) {
        try {
            window.characterUnlocked = JSON.parse(savedStatus);
            console.log('已加载解锁状态:', window.characterUnlocked);
        } catch (e) {
            console.error('解析解锁状态时出错:', e);
            window.characterUnlocked = {
                'sprite': true,
                'sprite02': false
            };
        }
    } else {
        window.characterUnlocked = {
            'sprite': true,
            'sprite02': false
        };
    }
    
    // 添加全局同步函数
    window.syncUnlockStatus = function() {
        localStorage.setItem('characterUnlocked', JSON.stringify(window.characterUnlocked));
        console.log('已同步解锁状态:', window.characterUnlocked);
    };
    
    // 覆盖原有的saveUnlockStatus函数
    window.saveUnlockStatus = function() {
        localStorage.setItem('characterUnlocked', JSON.stringify(window.characterUnlocked));
        console.log('已保存解锁状态:', window.characterUnlocked);
    };
    
    // 每隔一段时间自动同步一次
    setInterval(window.syncUnlockStatus, 10000);
    // 我们的永久解决方案代码结束
    
    // 原有的初始化代码
    // 注意：如果原代码中有loadUnlockStatus()调用，可以考虑注释掉，因为我们已经处理了加载逻辑
    // loadUnlockStatus(); // 可以注释掉，因为我们已经处理了加载逻辑
    updateCharacterSelectionUI();
    // ... 其他初始化代码 ...
            setupCharacterSelection();
        });

        // 角色解锁系统
        window.characterUnlocked = {
            'sprite': true,     // 初始角色默认解锁
            'sprite02': false   // 新角色默认未解锁
        };
        const UNLOCK_SCORE = 84;

        function updateCharacterSelectionUI() {
            const characterSelectionElement = document.getElementById('character-selection');
            
            if (characterSelectionElement) {

                characterSelectionElement.innerHTML = `
                    <h3 style="margin-bottom: 10px; color: var(--accent-light);">选择角色</h3>
                    <div class="character-options">
                        <div class="character-option ${currentCharacter === 'sprite' ? 'selected' : ''}" data-character="sprite">
                            <div class="character-preview">
                                <img src="chushiyulan.png" style="width: 100%; height: 100%; object-fit: contain;">
                            </div>
                            <div class="character-name">小乐小茶</div>
                        </div>
                        
                        <div class="character-option ${currentCharacter === 'sprite02' ? 'selected' : ''} ${!window.characterUnlocked.sprite02 ? 'locked' : ''}" data-character="sprite02">
                            <div class="character-preview">
                                ${window.characterUnlocked.sprite02 ? 
                                    `<img src="xinjueseyulan.png" style="width: 100%; height: 100%; object-fit: contain; filter: none;">` :
                                    `<div class="character-silhouette">
                                        <img src="xinjueseyulan.png" class="silhouette" style="width: 100%; height: 100%; object-fit: contain;">
                                        <div class="question-mark">?</div>
                                    </div>`
                                }
                            </div>
                            <div class="character-name">${window.characterUnlocked.sprite02 ? '小嘎小哞' : '未解锁'}</div>
                            ${!window.characterUnlocked.sprite02 ? '<div class="unlock-hint">收集84块金牌解锁</div>' : ''}
                        </div>
                    </div>
                `;
                
                setupCharacterSelection();
            }
        }

        function setupCharacterSelection() {
            const characterOptions = document.querySelectorAll('.character-option');
            
            characterOptions.forEach(option => {
                option.addEventListener('click', function() {
                    const characterType = this.getAttribute('data-character');
                    
                    if (window.characterUnlocked[characterType]) {
                        characterOptions.forEach(opt => opt.classList.remove('selected'));
                        this.classList.add('selected');
                        
                        currentCharacter = characterType;
                        characterSprite.src = `${characterType}.png`;
                        
                        updatePlayerAttributes();
                    } else {
                        this.classList.add('shake');
                        setTimeout(() => {
                            this.classList.remove('shake');
                        }, 500);
                    }
                });
            });
        }

        function showUnlockNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'unlock-notification';
            notification.innerHTML = `
                <div class="unlock-icon">🎁</div>
                <div class="unlock-message">${message}</div>
            `;
            
            const gameContainer = document.getElementById('game-container');
            gameContainer.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3500);
        }

        // 修改现有的handleGMCommand函数
        function handleGMCommand(key) {
            if (key === 'g' || key === 'G') {
                score += 300;
                scoreDisplay.textContent = score;
                
                if (score > highScore) {
                    highScore = score;
                    highScoreDisplay.textContent = "最高金牌数量: " + highScore;
                }
                
                if (score >= UNLOCK_SCORE && !characterUnlocked.sprite02) {
                    characterUnlocked.sprite02 = true;
                    saveUnlockStatus();
                    showUnlockNotification('小嘎小哞已解锁！');
                    
                    if (gameOverScreen.style.display === 'flex') {
                        updateCharacterSelectionUI();
                    }
                }
                
                console.log('GM Command: Added 300 to score');
            } else if (key === 'p' || key === 'P') {
                // 快速呼出海盗船场景
                console.log('GM Command: 切换到海盗船场景');
                
                // 设置距离到海盗船场景的里程碑
                distance = 4500;
                distanceDisplay.textContent = Math.floor(distance);
                
                // 手动触发场景切换
                checkMilestones();
                
                // 显示提示
                showMilestoneNotification("开发模式: 海盗船场景已加载", "#4682B4");
            }
            // [新增] 按R键重置角色解锁状态
            else if (key === 'r' || key === 'R') {
                // 重置角色解锁状态
                characterUnlocked = {
                    'sprite': true,     // 初始角色保持解锁
                    'sprite02': false   // 新角色重置为未解锁
                };
                // 保存到localStorage
                saveUnlockStatus();
                // 更新UI
                updateCharacterSelectionUI();
                // 显示提示
                showMilestoneNotification("已重置角色解锁状态", "#FF6B6B");
            }
            // [新增] 按L键查看当前解锁状态
            else if (key === 'l' || key === 'L') {
                const status = characterUnlocked.sprite02 ? "已解锁" : "未解锁";
                showMilestoneNotification(`小嘎小哞: ${status}`, "#4682B4");
            }
        }

        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            loadUnlockStatus();
            updateCharacterSelectionUI();
            // ... existing code ...
        });

// 保存地图解锁状态
        function saveMapUnlockStatus() {
            localStorage.setItem('mapUnlocked', JSON.stringify(mapUnlocked));
}

// 加载地图解锁状态
        function loadMapUnlockStatus() {
            const savedStatus = localStorage.getItem('mapUnlocked');
            if (savedStatus) {
                try {
                    mapUnlocked = JSON.parse(savedStatus);
                } catch (e) {
            // 如果解析出错，使用默认值
            mapUnlocked = {
                initialMap: true,
                newMap: false
            };
        }
    }
}

        function saveUnlockStatus() {
            // 使用localStorage保存角色解锁状态
            localStorage.setItem('characterUnlocked', JSON.stringify(window.characterUnlocked));
        }

        function loadUnlockStatus() {
            // 从localStorage加载角色解锁状态
            const savedStatus = localStorage.getItem('characterUnlocked');
            if (savedStatus) {
                try {
                    window.characterUnlocked = JSON.parse(savedStatus);
                } catch (e) {
                    // 如果解析出错，使用默认值
                    window.characterUnlocked = {
                        'sprite': true,
                        'sprite02': false
                    };
                }
            }
        }

        // 添加新的辅助函数
        function drawRainClouds() {
            // 绘制几个大型暗色云团
            const cloudColors = ['#1A2535', '#202D3E', '#283547'];
            // ... drawRainClouds代码 ...
        }

        function drawRainOverlay() {
            // 在画面上方添加更多的雨滴效果
            ctx.fillStyle = 'rgba(180, 210, 240, 0.05)';
            // ... drawRainOverlay代码 ...
        }

        function createLightningBolt(lightning, startX, startY, length, angle, generation) {
            if (generation > 3) return;
            
            const endX = startX + Math.cos(angle) * length;
            const endY = startY + Math.sin(angle) * length;
            
            lightning.branches.push({
                startX: startX,
                startY: startY,
                endX: endX,
                endY: endY
            });
            
            if (Math.random() < 0.6 && generation < 2) {
                const newAngle = angle + (Math.random() * 0.5 - 0.25) * Math.PI;
                const newLength = length * (0.3 + Math.random() * 0.4);
                
                const branchStartPos = 0.3 + Math.random() * 0.5;
                const branchStartX = startX + (endX - startX) * branchStartPos;
                const branchStartY = startY + (endY - startY) * branchStartPos;
                
                createLightningBolt(
                    lightning,
                    branchStartX,
                    branchStartY,
                    newLength,
                    newAngle,
                    generation + 1
                );
            }
        }

        // 添加场景切换功能
        window.addEventListener('keydown', function(e) {
            // 只响应主键盘上方的数字键（不包括小键盘）
            switch(e.key) {
                case '1': // 体育场（默认场景）
                    distance = 0;
                    currentBgStage = 0;
                    activeSceneName = null;
                    console.log('切换到：体育场场景');
                    break;
                case '2': // 山地场景
                    distance = 2000;
                    currentBgStage = 1;
                    activeSceneName = 'mountains';
                    createMountains();
                    console.log('切换到：山地场景');
                    break;
                case '3': // 海底两万里场景
                    distance = 11000;
                    currentBgStage = 2;
                    activeSceneName = 'pirate';
                    createPirateScene();
                    console.log('切换到：海底两万里场景');
                    break;
                case '4': // 樱花场景
                    distance = 15000;
                    currentBgStage = 3;
                    activeSceneName = 'cherryBlossom';
                    createCherryBlossom();
                    console.log('切换到：樱花场景');
                    break;
                case '5': // 流星雨场景
                    distance = 18500;
                    currentBgStage = 4;
                    activeSceneName = 'meteors';
                    createMeteorShower();
                    console.log('切换到：流星雨场景');
                    break;
                case '6': // 烟花场景
                    distance = 21500;
                    currentBgStage = 5;
                    activeSceneName = 'fireworks';
                    createFireworks();
                    console.log('切换到：烟花场景');
                    break;
                case '0': // 显示帮助信息
                    console.log(`
场景切换快捷键:
1 - 体育场（默认场景）
2 - 山地场景 (3000米)
3 - 海底两万里场景 (6000米)
4 - 樱花场景 (9000米)
5 - 流星雨场景 (12000米)
6 - 烟花场景 (15000米)
0 - 显示此帮助信息
                    `);
                    break;
            }
            
            // 更新距离显示
            if (distanceDisplay) {
                distanceDisplay.textContent = Math.floor(distance) + ' 米';
            }
        });

        // 添加提示信息
        console.log('按 0 查看场景切换快捷键');

        // 海盗船场景元素容器
        let pirateShipElements = [];

        function createPirateShipScene() {
            // 清空现有元素
            pirateElements = [];
            
            // 创建雨滴
            for (let i = 0; i < 200; i++) {
                pirateElements.push({
                    type: 'raindrop',
                    x: Math.random() * canvas.width* 1.5,
                    y: Math.random() * canvas.height,
                    length: 10 + Math.random() * 20,
                    speed: 15 + Math.random() * 5
                });
            }
            
            // 创建闪电 - 减少数量从3个到1个
            for (let i = 0; i < 1; i++) {
                pirateElements.push({
                    type: 'lightning',
                    x: Math.random() * canvas.width,
                    y: 0,
                    segments: 5 + Math.floor(Math.random() * 5),
                    width: 2 + Math.random() * 3,
                    alpha: 0,
                    maxAlpha: 0.6 + Math.random() * 0.4,
                    fadeSpeed: 0.01 + Math.random() * 0.02, // 降低淡入淡出速度，减少频率
                    state: 'fadein',
                    zigzag: 20 + Math.random() * 30,
                    cooldown: 0,
                    maxCooldown: 120 + Math.floor(Math.random() * 180) // 添加冷却时间，减少频率
                });
            }
            
            // 创建更酷炫的海盗船
            pirateElements.push({
                type: 'ship',
                x: canvas.width * 0.7,
                y: canvas.height - 80,
                width: 180,
                height: 120,
                mastHeight: 150,
                sailWidth: 70,
                sailHeight: 90,
                angle: 0,
                maxAngle: 5,
                direction: 1,
                speed: 0.05
            });
            
            // 创建波浪
            for (let i = 0; i < 8; i++) {
                pirateElements.push({
                    type: 'wave',
                    x: i * (canvas.width / 8),
                    y: canvas.height - 40,
                    width: canvas.width / 8,
                    height: 20,
                    speed: 0.05,
                    offset: i * 0.5
                });
            }
        }

        function drawPirateShipScene() {
            // 绘制暴风雨背景
            const stormGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            stormGradient.addColorStop(0, '#0A1B29');
            stormGradient.addColorStop(0.7, '#1A2C3E');
            stormGradient.addColorStop(1, '#334759');
            
            ctx.fillStyle = stormGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 更新和绘制所有元素
            for (let i = 0; i < pirateElements.length; i++) {
                const element = pirateElements[i];
                
                switch (element.type) {
                    case 'raindrop':
                        // 雨滴代码保持不变
                        element.y += element.speed;
                        element.x -= element.speed * 0.5;
                        
                        if (element.y > canvas.height || element.x < 0) {
                            element.y = Math.random() * -50;
                            element.x = Math.random() * canvas.width* 1.5;
                        }
                        
                        ctx.strokeStyle = 'rgba(180, 230, 255, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(element.x, element.y);
                        ctx.lineTo(element.x - element.length * 0.5, element.y + element.length);
                        ctx.stroke();
                        break;
                        
                    case 'lightning':
                        // 闪电代码保持不变
                        if (element.cooldown > 0) {
                            element.cooldown--;
                            break; // 跳过绘制
                        }
                        
                        if (element.state === 'fadein') {
                            element.alpha += element.fadeSpeed;
                            if (element.alpha >= element.maxAlpha) {
                                element.state = 'fadeout';
                                element.fadeSpeed *= 2;
                            }
                        } else if (element.state === 'fadeout') {
                            element.alpha -= element.fadeSpeed;
                            if (element.alpha <= 0) {
                                element.x = Math.random() * canvas.width;
                                element.segments = 5 + Math.floor(Math.random() * 5);
                                element.alpha = 0;
                                element.maxAlpha = 0.6 + Math.random() * 0.4;
                                element.fadeSpeed = 0.01 + Math.random() * 0.02;
                                element.state = 'fadein';
                                element.zigzag = 20 + Math.random() * 30;
                                element.cooldown = element.maxCooldown;
                            }
                        }
                        
                        if (element.alpha > 0) {
                            ctx.strokeStyle = `rgba(220, 240, 255, ${element.alpha})`;
                            ctx.lineWidth = element.width;
                            ctx.beginPath();
                            ctx.moveTo(element.x, element.y);
                            
                            let currentX = element.x;
                            let currentY = element.y;
                            const segmentLength = canvas.height / element.segments;
                            
                            for (let j = 0; j < element.segments; j++) {
                                currentY += segmentLength;
                                currentX += (Math.random() - 0.5) * element.zigzag;
                                ctx.lineTo(currentX, currentY);
                            }
                            
                            ctx.stroke();
                            
                            ctx.strokeStyle = `rgba(180, 225, 255, ${element.alpha * 0.3})`;
                            ctx.lineWidth = element.width * 3;
                            ctx.stroke();
                        }
                        break;
                        
                    case 'ship':
                        // 船的基本动画和位置代码保持不变
                        element.angle += element.speed * element.direction;
                        if (Math.abs(element.angle) > element.maxAngle) {
                            element.direction *= -1;
                        }
                        
                        ctx.save();
                        ctx.translate(element.x + element.width / 2, element.y + element.height / 2);
                        ctx.rotate(element.angle * Math.PI / 180);
                        
                        // 绘制船体
                        ctx.fillStyle = '#5D4037';
                        ctx.beginPath();
                        ctx.moveTo(-element.width / 2, -element.height / 2 + 30);
                        ctx.lineTo(element.width / 2, -element.height / 2 + 30);
                        ctx.lineTo(element.width / 2 + 20, 0);
                        ctx.lineTo(element.width / 2, element.height / 2);
                        ctx.lineTo(-element.width / 2, element.height / 2);
                        ctx.lineTo(-element.width / 2 - 20, 0);
                        ctx.closePath();
                        ctx.fill();
                        
                        // 船体装饰
                        ctx.fillStyle = '#8D6E63';
                        ctx.fillRect(-element.width / 2 - 5, -element.height / 2 + 30, element.width + 10, 10);
                        ctx.fillRect(-element.width / 2 - 5, element.height / 2 - 15, element.width + 10, 10);
                        
                        // 船舱
                        ctx.fillStyle = '#3E2723';
                        ctx.fillRect(-element.width / 4, -element.height / 2 + 45, element.width / 2, 30);
                        
                        // 船舱窗户
                        ctx.fillStyle = '#FFF59D';
                        for (let j = 0; j < 3; j++) {
                            ctx.fillRect(
                                -element.width / 4 + 10 + j * 20, 
                                -element.height / 2 + 55, 
                                10, 
                                10
                            );
                        }
                        
                        // 桅杆 - 稍微加粗
                        ctx.fillStyle = '#5D4037';
                        ctx.fillRect(-8, -element.height / 2 + 40, 16, -element.mastHeight);
                        
                        // 多个横杆，增加真实感
                        ctx.fillStyle = '#5D4037';
                        // 主横杆
                        ctx.fillRect(-element.sailWidth / 2 - 10, -element.height / 2 - 30, element.sailWidth + 20, 8);
                        // 次横杆
                        ctx.fillRect(-element.sailWidth / 2 - 5, -element.height / 2 - 80, element.sailWidth + 10, 6);
                        // 顶部横杆
                        ctx.fillRect(-element.sailWidth / 3, -element.height / 2 - element.sailHeight - 10, element.sailWidth * 2/3, 5);
                        
                        // 绘制更自然的主帆
                        ctx.fillStyle = '#E3D7C8'; // 略微米黄色的帆布色
                        
                        // 风吹动的帆形状 - 使用贝塞尔曲线创建更自然的弧度
                        ctx.beginPath();
                        // 帆的左上角
                        ctx.moveTo(-element.sailWidth / 2 - 5, -element.height / 2 - 30);
                        
                        // 帆的左侧曲线 - 模拟风吹起的弧度
                        ctx.bezierCurveTo(
                            -element.sailWidth / 2 + 10, -element.height / 2 - 60, // 控制点1
                            -element.sailWidth / 3, -element.height / 2 - 100,     // 控制点2
                            -element.sailWidth / 4, -element.height / 2 - element.sailHeight - 5 // 终点
                        );
                        
                        // 帆的顶部
                        ctx.lineTo(element.sailWidth / 4, -element.height / 2 - element.sailHeight - 5);
                        
                        // 帆的右侧曲线
                        ctx.bezierCurveTo(
                            element.sailWidth / 3, -element.height / 2 - 100,      // 控制点1
                            element.sailWidth / 2 - 10, -element.height / 2 - 60,  // 控制点2
                            element.sailWidth / 2 + 5, -element.height / 2 - 30    // 终点
                        );
                        
                        // 帆的底部
                        ctx.lineTo(-element.sailWidth / 2 - 5, -element.height / 2 - 30);
                        ctx.closePath();
                        ctx.fill();
                        
                        // 帆的阴影效果，增加立体感
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                        ctx.beginPath();
                        ctx.moveTo(-element.sailWidth / 2 - 5, -element.height / 2 - 30);
                        ctx.bezierCurveTo(
                            -element.sailWidth / 2 + 10, -element.height / 2 - 60,
                            -element.sailWidth / 3, -element.height / 2 - 100,
                            -element.sailWidth / 4, -element.height / 2 - element.sailHeight - 5
                        );
                        ctx.lineTo(0, -element.height / 2 - element.sailHeight + 10);
                        ctx.lineTo(0, -element.height / 2 - 30);
                        ctx.closePath();
                        ctx.fill();
                        
                        // 帆上的缝线
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                        ctx.lineWidth = 1;
                        for (let j = 1; j < 4; j++) {
                            const y = -element.height / 2 - 30 - (j * element.sailHeight / 4);
                            ctx.beginPath();
                            ctx.moveTo(-element.sailWidth / 2 + (j * 5), y);
                            ctx.lineTo(element.sailWidth / 2 - (j * 5), y);
                            ctx.stroke();
                        }
                        
                        // 绘制次帆
                        ctx.fillStyle = '#E3D7C8';
                        ctx.beginPath();
                        // 次帆的顶部连接点
                        ctx.moveTo(0, -element.height / 2 - 80);
                        // 次帆的右上角
                        ctx.lineTo(element.sailWidth / 3, -element.height / 2 - 80);
                        // 次帆的右下角
                        ctx.lineTo(element.sailWidth / 2, -element.height / 2 - 30);
                        // 次帆的左下角
                        ctx.lineTo(0, -element.height / 2 - 30);
                        ctx.closePath();
                        ctx.fill();
                        
                        // 次帆的阴影
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                        ctx.beginPath();
                        ctx.moveTo(0, -element.height / 2 - 80);
                        ctx.lineTo(element.sailWidth / 6, -element.height / 2 - 80);
                        ctx.lineTo(element.sailWidth / 4, -element.height / 2 - 30);
                        ctx.lineTo(0, -element.height / 2 - 30);
                        ctx.closePath();
                        ctx.fill();
                        
                        // 帆上的海盗标志 - 改为小乌龟
                        const turtleX = 0;
                        const turtleY = -element.height / 2 - element.sailHeight / 2 - 10;
                        
                        // 乌龟背景 - 使用渐变效果
                        const turtleBgGradient = ctx.createRadialGradient(
                            turtleX, turtleY, 0,
                            turtleX, turtleY, 22
                        );
                        turtleBgGradient.addColorStop(0, '#008B45');
                        turtleBgGradient.addColorStop(1, '#004D26');
                        ctx.fillStyle = turtleBgGradient;
                        ctx.beginPath();
                        ctx.arc(turtleX, turtleY, 22, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // 乌龟壳 - 使用更自然的形状和渐变
                        const shellGradient = ctx.createRadialGradient(
                            turtleX, turtleY, 0,
                            turtleX, turtleY, 16
                        );
                        shellGradient.addColorStop(0, '#32CD32');
                        shellGradient.addColorStop(0.7, '#228B22');
                        shellGradient.addColorStop(1, '#006400');
                        ctx.fillStyle = shellGradient;
                        
                        // 绘制更自然的六边形壳
                        ctx.beginPath();
                        ctx.moveTo(turtleX, turtleY - 16);  // 顶部
                        ctx.lineTo(turtleX + 14, turtleY - 8);  // 右上
                        ctx.lineTo(turtleX + 14, turtleY + 8);  // 右下
                        ctx.lineTo(turtleX, turtleY + 16);  // 底部
                        ctx.lineTo(turtleX - 14, turtleY + 8);  // 左下
                        ctx.lineTo(turtleX - 14, turtleY - 8);  // 左上
                        ctx.closePath();
                        ctx.fill();
                        
                        // 壳上的花纹 - 更复杂的图案
                        ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
                        ctx.lineWidth = 1.5;
                        
                        // 中心线
                        ctx.beginPath();
                        ctx.moveTo(turtleX, turtleY - 16);
                        ctx.lineTo(turtleX, turtleY + 16);
                        ctx.stroke();
                        
                        // 横向线
                        ctx.beginPath();
                        ctx.moveTo(turtleX - 14, turtleY);
                        ctx.lineTo(turtleX + 14, turtleY);
                        ctx.stroke();
                        
                        // 壳上的六边形图案
                        ctx.beginPath();
                        ctx.arc(turtleX, turtleY, 8, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // 壳上的小点装饰
                        ctx.fillStyle = 'rgba(255, 255, 150, 0.8)';
                        for (let i = 0; i < 6; i++) {
                            const angle = i * Math.PI / 3;
                            const dotX = turtleX + Math.cos(angle) * 12;
                            const dotY = turtleY + Math.sin(angle) * 12;
                            ctx.beginPath();
                            ctx.arc(dotX, dotY, 1.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // 乌龟头 - 更自然的形状
                        ctx.fillStyle = '#3CB371';
                        ctx.beginPath();
                        ctx.ellipse(turtleX + 16, turtleY, 6, 4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // 乌龟眼睛 - 添加白色部分
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(turtleX + 18, turtleY - 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(turtleX + 19, turtleY - 2, 1, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // 乌龟嘴巴
                        ctx.strokeStyle = '#663300';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(turtleX + 20, turtleY);
                        ctx.lineTo(turtleX + 22, turtleY);
                        ctx.stroke();
                        
                        // 乌龟四肢 - 更自然的椭圆形
                        ctx.fillStyle = '#3CB371';
                        
                        // 前肢
                        ctx.beginPath();
                        ctx.ellipse(turtleX + 10, turtleY - 12, 5, 3, Math.PI/4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.ellipse(turtleX + 10, turtleY + 12, 5, 3, -Math.PI/4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // 后肢
                        ctx.beginPath();
                        ctx.ellipse(turtleX - 10, turtleY - 12, 5, 3, -Math.PI/4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.ellipse(turtleX - 10, turtleY + 12, 5, 3, Math.PI/4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // 乌龟尾巴 - 更自然的曲线
                        ctx.strokeStyle = '#3CB371';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(turtleX - 14, turtleY);
                        ctx.quadraticCurveTo(
                            turtleX - 18, turtleY,
                            turtleX - 20, turtleY + 2
                        );
                        ctx.stroke();
                        
                        ctx.restore();
                        break;
                        
                    case 'wave':
                        // 波浪代码保持不变
                        element.offset += element.speed;
                        
                        ctx.fillStyle = 'rgba(65, 105, 140, 0.7)';
                        ctx.beginPath();
                        ctx.moveTo(element.x, element.y);
                        
                        for (let x = 0; x <= element.width; x += 5) {
                            const waveHeight = Math.sin(x * 0.05 + element.offset + frameCount * 0.05) * 5;
                            ctx.lineTo(element.x + x, element.y + waveHeight);
                        }
                        
                        ctx.lineTo(element.x + element.width, element.y + element.height);
                        ctx.lineTo(element.x, element.y + element.height);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.fillStyle = 'rgba(200, 230, 255, 0.5)';
                        for (let x = 0; x < element.width; x += 20) {
                            const foamX = element.x + x + Math.sin(frameCount * 0.05 + x) * 5;
                            const foamY = element.y + Math.sin(x * 0.05 + element.offset + frameCount * 0.05) * 5;
                            const foamSize = 2 + Math.sin(frameCount * 0.1 + x * 0.1) * 2;
                            
                            ctx.beginPath();
                            ctx.arc(foamX, foamY, foamSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                }
            }
        }

        // 在showMilestoneNotification函数附近添加或修改
        function showMilestoneNotification(text, color = "#ffcc00") {
            milestoneNotification.textContent = text;
            milestoneNotification.style.color = color;
            milestoneNotification.style.opacity = 1;
            
            
            // 3秒后隐藏通知
            setTimeout(() => {
                milestoneNotification.style.opacity = 0;
            }, 3000);
        }
    </script>

    <!-- 添加这个脚本到页面底部，用于调整文本内容 -->
    <script>
        // 等待DOM完全加载
        window.addEventListener('DOMContentLoaded', function() {
            // 添加：加载地图解锁状态
            const savedMapStatus = localStorage.getItem('mapUnlocked');
            if (savedMapStatus) {
                try {
                    mapUnlocked = JSON.parse(savedMapStatus);
                } catch (e) {
                    mapUnlocked = {
                    initialMap: true,
                    newMap: false
                    };
                }
            } else {
                mapUnlocked = {
                initialMap: true,
                newMap: false
                };
            }

            // 修改游戏说明文字内容和换行
            const instructionsElements = document.querySelectorAll('.instructions');
            instructionsElements.forEach(function(element) {
                if (element.innerHTML.includes('与小乐小茶一起奔跑')) {
                    element.innerHTML = '与小乐小茶一起奔跑，<br>跳过障碍，赢得金牌！<br><span style="color: var(--accent-light);">空格键/点击屏幕</span> 进行跳跃';
                }
            });
            
            // 确保开始按钮文本不会换行
            const startBtn = document.getElementById('start-btn');
            if (startBtn) {
                startBtn.style.whiteSpace = 'nowrap';
            }
            
            // 确保重新开始按钮文本不会换行
            const restartBtn = document.getElementById('restart-btn');
            if (restartBtn) {
                restartBtn.style.whiteSpace = 'nowrap';
            }
        });

        // 页面加载完成后检查署名
        window.addEventListener('load', function() {
            // 如果已经有游戏结束画面显示，修复其中的署名
            fixAuthorCredit();
            
            // 监听游戏结束事件（当游戏结束界面显示时）
            const gameOverObserver = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.attributeName === 'style' && 
                        mutation.target.style.display === 'flex') {
                        fixAuthorCredit();
                    }
                });
            });
            
            const gameOverElement = document.getElementById('game-over');
            if (gameOverElement) {
                gameOverObserver.observe(gameOverElement, { attributes: true });
            }
        });

        // 修复署名函数
        function fixAuthorCredit() {
            const gameOverScreen = document.getElementById('game-over');
            if (gameOverScreen) {
                // 查找所有可能是署名的元素
                const authorElements = gameOverScreen.querySelectorAll('div[style*="margin-top: 15px"], .author-credit');
                authorElements.forEach(function(element) {
                    if (element.textContent.includes('BY：刺')) {
                        element.className = 'author-credit';
                        element.style.marginTop = '20px';
                        element.style.marginBottom = '15px';
                        element.style.position = 'relative';
                        element.style.width = '100%';
                        element.style.textAlign = 'center';
                        element.style.padding = '5px 0';
                        element.style.whiteSpace = 'nowrap';
                        element.style.overflow = 'visible';
                    }
                });
            }
        }

// 确保localStorage和window.characterUnlocked同步，并实时更新UI
(function() {
    // 在页面加载时执行
    document.addEventListener('DOMContentLoaded', function() {
        // 从localStorage加载解锁状态
        const savedStatus = localStorage.getItem('characterUnlocked');
        if (savedStatus) {
            try {
                window.characterUnlocked = JSON.parse(savedStatus);
            } catch (e) {
                window.characterUnlocked = { 'sprite': true, 'sprite02': false };
            }
        } else {
            window.characterUnlocked = { 'sprite': true, 'sprite02': false };
        }
        
        // 覆盖保存函数
        window.saveUnlockStatus = function() {
            localStorage.setItem('characterUnlocked', JSON.stringify(window.characterUnlocked));
        };
    });
    
    // 强制更新UI函数
    function forceUpdateUI() {
        if (window.characterUnlocked && window.characterUnlocked.sprite02) {
            const characterElement = document.querySelector('.character-option[data-character="sprite02"]');
            if (!characterElement) return;
            
            characterElement.classList.remove('locked');
            
            const previewElement = characterElement.querySelector('.character-preview');
            if (previewElement) {
                previewElement.innerHTML = `<img src="xinjueseyulan.png" style="width: 100%; height: 100%; object-fit: contain; filter: none;">`;
            }
            
            const nameElement = characterElement.querySelector('.character-name');
            if (nameElement) nameElement.textContent = '小嘎小哞';
            
            const hintElement = characterElement.querySelector('.unlock-hint');
            if (hintElement) hintElement.remove();
        }
    }

    // 增强gameOver函数
    const originalGameOver = window.gameOver;
    window.gameOver = function() {
        originalGameOver.apply(this, arguments);
        if (window.characterUnlocked && window.characterUnlocked.sprite02) {
            setTimeout(forceUpdateUI, 500);
        }
    };

    // 增强handleGMCommand函数
    const originalHandleGMCommand = window.handleGMCommand;
    window.handleGMCommand = function(key) {
        originalHandleGMCommand.apply(this, arguments);
        if ((key === 'g' || key === 'G') && window.characterUnlocked && window.characterUnlocked.sprite02) {
            setTimeout(forceUpdateUI, 500);
        }
    };
})();
    </script>
</body>
</html>