<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>èŒ¶èŒ¶ä¹æ·˜é‡‘è®°</title>
    <style>
        @font-face {
            font-family: 'Pixel';
            src: url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
            font-weight: normal;
            font-style: normal;
        }

        :root {
            --primary-color: #FF7E5F;
            --secondary-color: #8A7CFF;
            --accent-color: #FFD86B;
            --background-light: #342D6E;
            --background-dark: #1E1A4A;
            --text-light: #FFFFFF;
            --text-dark: #FFE26A;
            --accent-light: #FFE34D;
            --accent-dark: #FFD12E;
            --track-light: #5578FF;
            --track-dark: #4251CF;
            --ui-highlight: #FB5EEE;
            --ui-shadow: #371E73;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            image-rendering: pixelated;
        }

        body {
            font-family: 'Pixel', 'Courier New', monospace;
            overflow: hidden;
            background-color: var(--background-dark);
            color: var(--text-light);
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            letter-spacing: 1px;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 480px;
            overflow: hidden;
            border: 4px solid var(--primary-color);
            border-radius: 8px;
            margin: 0 auto;
            image-rendering: pixelated;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
        }

        @media (max-width: 800px) and (orientation: landscape) {
            #game-container {
                height: 300px;
            }
        }
        
        /* ç«–å±æ¨¡å¼ä¸‹å¢åŠ æ¸¸æˆé«˜åº¦ï¼Œæä¾›æ›´å¤§çš„è·³è·ƒç©ºé—´ */
        @media (orientation: portrait) {
            #game-container {
                height: 70vh; /* ä½¿ç”¨è§†å£é«˜åº¦çš„70%ï¼Œæä¾›æ›´å¤§çš„æ¸¸æˆç©ºé—´ */
                max-height: 600px;
            }
            
            #mobile-controls {
                bottom: 10px;
            }
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #141432;
        }

        .ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            display: flex;
            gap: 15px;
        }

        .stats-box {
            background-color: rgba(0, 0, 0, 0.7);
            color: var(--text-light);
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            padding: 6px 12px;
            border: 2px solid var(--primary-color);
        }

        .stats-icon {
            margin-right: 10px;
        }

        #score-container {
            border: 2px solid var(--primary-color);
        }
        
        #tea-container {
            border: 2px solid var(--secondary-color);
        }
        
        #distance-container {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: var(--text-light);
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            z-index: 10;
            padding: 6px 12px;
            border: 2px solid var(--accent-color);
            min-width: 100px;
            text-align: center;
        }

        #milestone-notification {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: var(--accent-light);
            border: 2px solid var(--primary-color);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 18px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s;
            text-align: center;
            pointer-events: none;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(30, 30, 63, 0.9);
            z-index: 100;
            color: white;
            text-align: center;
            padding: 20px;
            font-family: 'Comic Sans MS', 'Courier New', monospace;
        }

        #game-title {
            font-size: 42px;
            margin-bottom: 30px;
            color: #f0f261; /* ä¿®æ”¹: æ˜äº®çš„é‡‘é»„è‰² */
            font-family: 'Pixel', 'Comic Sans MS', 'Courier New', monospace;
            font-weight: 800;
            position: relative;
            padding: 20px 0px;
            text-shadow: 3px 3px 0px rgba(226, 229, 216, 0.5); /* ä¿®æ”¹: æ›´æŸ”å’Œçš„é‡‘è‰²é˜´å½± */
            letter-spacing: 2px;
            animation: titlePulse 3s ease-in-out infinite;
            /* æ›´æ¸…æ–°å¯çˆ±çš„æè¾¹æ•ˆæœ */
            -webkit-text-stroke: 2px rgba(197, 216, 173, 0.6); /* ä¿®æ”¹: é‡‘è‰²æè¾¹ */
        }
        
        @keyframes titlePulse {
            0%, 100% {
                text-shadow: 3px 3px 0px rgba(204, 172, 13, 0.5); /* ä¿®æ”¹: é‡‘è‰²é˜´å½± */
                transform: scale(1);
            }
            50% {
                text-shadow: 4px 4px 0px rgba(204, 172, 13, 0.5); /* ä¿®æ”¹: é‡‘è‰²é˜´å½± */
                transform: scale(1.05);
            }
        }
        
        /* ç«–å±æ¨¡å¼ä¼˜åŒ– */
        @media (max-width: 480px), (max-height: 600px) {
            #game-title {
                font-size: 28px;
                margin-bottom: 15px;
                padding: 10px 0;
            }
            
            #start-screen .instructions,
            #game-over .score-box,
            .pixel-btn {
                font-size: 14px;
                padding: 10px 18px;
                max-width: 90%;
            }
            
            #final-score, 
            #high-score, 
            #final-distance {
                font-size: 16px;
            }
            
            h2 {
                font-size: 24px !important;
                margin-bottom: 5px !important;
            }
        }

        #game-logo {
            width: 120px;
            height: 120px;
            margin-bottom: 20px;
            image-rendering: pixelated;
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        .pixel-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 24px;
            margin-top: 20px;
            font-size: 18px;
            cursor: pointer;
            font-family: 'Pixel', 'Courier New', monospace;
            transition: transform 0.1s, box-shadow 0.1s, background-color 0.2s;
            position: relative;
            box-shadow: 0px 4px 0px 0px var(--ui-shadow);
            border-radius: 4px;
            letter-spacing: 1px;
            text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.3);
        }

        .pixel-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0px 6px 0px 0px var(--ui-shadow);
            background-color: var(--ui-highlight);
        }

        .pixel-btn:active {
            transform: translateY(2px);
            box-shadow: 0px 2px 0px 0px var(--ui-shadow);
        }

        /* æ–°å¢restart-btnç‰¹æ®Šæ ·å¼ */
        #restart-btn {
            margin-top: 5px;
            margin-bottom: 8px;
            background: linear-gradient(to right, #FF512F, #FF6B6B) !important;
            color: #FFFFFF !important;
            font-weight: bold;
            padding: 10px 28px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0px 4px 0px 0px rgba(178, 34, 34, 0.5),
                        0px 0px 10px rgba(255, 69, 0, 0.3);
            text-shadow: 0 2px 2px rgba(0, 0, 0, 0.3);
        }

        #game-over #restart-btn:hover {
            background: linear-gradient(to right, #FF512F, #FF6B6B) !important;
            transform: translateY(-2px);
            box-shadow: 0px 6px 0px 0px rgba(178, 34, 34, 0.5),
                        0px 0px 15px rgba(255, 69, 0, 0.4);
        }

        #game-over #restart-btn:active {
            transform: translateY(2px);
            box-shadow: 0px 2px 0px 0px rgba(178, 34, 34, 0.5),
                        0px 0px 5px rgba(255, 69, 0, 0.2);
        }

        #restart-btn:hover {
            background: linear-gradient(to right, #FF512F, #FF6B6B);
            transform: translateY(-2px);
            box-shadow: 0px 6px 0px 0px rgba(178, 34, 34, 0.5),
                        0px 0px 15px rgba(255, 69, 0, 0.4);
        }

        #restart-btn:active {
            transform: translateY(2px);
            box-shadow: 0px 2px 0px 0px rgba(178, 34, 34, 0.5),
                        0px 0px 5px rgba(255, 69, 0, 0.2);
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.15), 
                rgba(173, 216, 230, 0.25));
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
            padding: 20px 25px 30px 25px !important;  /* è°ƒæ•´å†…è¾¹è· */
            border-radius: 15px;
            text-align: center;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 8px;  /* å‡å°å…ƒç´ é—´è· */
            min-width: 250px;  /* ç¨å¾®å‡å°æœ€å°å®½åº¦ */
            max-width: 90%;  /* å‡å°æœ€å¤§å®½åº¦æ¯”ä¾‹ */
            max-height: 80vh;  /* é™åˆ¶æœ€å¤§é«˜åº¦ä¸ºè§†å£é«˜åº¦çš„75% */
            overflow-y: auto;
            margin: 0;
        }
        #character-selection {
            margin: 5px 0;
            margin-top: 50px;        /* æ–°å¢: å‡å°ä¸score-boxçš„é—´è· */
            margin-bottom: 10px;    /* æ–°å¢: å¢åŠ ä¸restartæŒ‰é’®çš„é—´è· */
        }
        #restart-btn {
            margin-top: 2px;        /* æ–°å¢: æ§åˆ¶ä¸è§’è‰²é€‰æ‹©çš„é—´è· */
            margin-bottom: 2px;            /* æ–°å¢: æ§åˆ¶ä¸ç½²åçš„é—´è· */
        }
        #game-over h2 {
            color: rgba(255, 255, 255, 0.9);
            margin: 5px 0 6px 0;  /* è°ƒæ•´æ ‡é¢˜è¾¹è· */
            font-size: 20px;  /* å‡å°æ ‡é¢˜å­—ä½“ */
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #game-over p {
            color: rgba(255, 255, 255, 0.8);
            margin: 5px 0;
            width: 100%;  /* ç¡®ä¿æ–‡å­—ä¸ä¼šè¶…å‡ºå®¹å™¨ */
            word-wrap: break-word;  /* é•¿æ–‡å­—è‡ªåŠ¨æ¢è¡Œ */
        }

        #game-over button {
            background: linear-gradient(to right, 
                rgba(255, 255, 255, 0.2), 
                rgba(173, 216, 230, 0.3));  /* æ›´æŸ”å’Œçš„æŒ‰é’®èƒŒæ™¯ */
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 25px;
            border-radius: 25px;
            color: rgba(255, 255, 255, 0.9);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.1);
            margin-bottom: 10px;
        }

        #game-over button:hover {
            transform: translateY(-2px);
            background: linear-gradient(to right, 
                rgba(255, 255, 255, 0.3), 
                rgba(173, 216, 230, 0.4));
            box-shadow: 0 6px 20px rgba(255, 255, 255, 0.15);
        }

        #game-over button:active {
            transform: translateY(0px);
        }

        /* ä¿®æ”¹ä½œè€…ç½²åæ ·å¼ */
        #game-over .author-credit,
        #game-over div[style*="margin-top: 10px"] {
            position: relative;
            width: 100%;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            padding: 5px 0;
            margin-top: 2px !important;  /* å‡å°ä¸Šè¾¹è· */
            margin-bottom: 5px !important;  /* å‡å°ä¸‹è¾¹è· */
            white-space: nowrap;
            overflow: visible;
        }
        
        .score-box {
            background-color: rgba(0, 0, 0, 0.6);
            padding: 5px 18px;  /* å‡å°å†…è¾¹è· */
            border-radius: 6px;
            margin: 6px 0;  /* å‡å°å¤–è¾¹è· */
            margin-top: 2px;       /* æ–°å¢: ç‰¹åˆ«æ§åˆ¶ä¸æ ‡é¢˜çš„è·ç¦» */
            margin-bottom: 5px;    /* æ–°å¢: å¢åŠ ä¸è§’è‰²é€‰æ‹©çš„é—´è· */
            border: 1px solid var(--accent-color);
            font-size: 12px;           /* æ–°å¢: æ§åˆ¶æ•´ä½“å­—ä½“å¤§å° */
        }

        #final-score {
            font-size: 20px;
            margin: 5px 0;
            color: var(--accent-light);
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5);
        }

        .instructions {
            font-size: 16px;
            margin-top: 15px;
            max-width: 300px;
            line-height: 1.8 !important; /* å¢åŠ è¡Œé«˜ */
            white-space: normal; /* å…è®¸æ­£å¸¸æ¢è¡Œ */
            background-color: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #c2a500; /* ä¿®æ”¹: é‡‘è‰²è¾¹æ¡† */
        }

        #game-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }

        #mobile-controls {
            display: none;
        }

        @media (max-width: 800px) {
            #mobile-controls {
                display: block;
                position: fixed;
                bottom: 20px;
                width: 100%;
                text-align: center;
                z-index: 50;
            }
            
            #jump-btn {
                background-color: var(--primary-color);
                color: white;
                border: none;
                padding: 15px 30px;
                font-size: 20px;
                border-radius: 50px;
                opacity: 0.9;
                box-shadow: 0px 4px 0px 0px #ad3f3a;
            }
            
            #jump-btn:active {
                transform: translateY(4px);
                box-shadow: 0px 0px 0px 0px #ad3f3a;
            }
        }
        
        /* Particle effects */
        @keyframes sparkle {
            0%, 100% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1); }
        }
        
        .sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: #FFFFFF;
            border-radius: 50%;
            animation: sparkle 1s ease-in-out infinite;
            pointer-events: none;
        }

        #tea-container {
            transition: all 0.3s ease;
        }

        /* æ·»åŠ è§’è‰²é€‰æ‹©æ ·å¼ */
        .character-options {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;  /* å‡å°ä¸‹è¾¹è· */
        }
        .character-option {
            cursor: pointer;
            padding: 8px;  /* å‡å°å†…è¾¹è· */
            border: 2px solid transparent;  /* å‡å°è¾¹æ¡†å®½åº¦ */
            border-radius: 6px;
            background-color: rgba(0, 0, 0, 0.5);
            transition: all 0.3s;
            text-align: center;
            position: relative;
        }
        .character-option:hover {
            background-color: rgba(0, 0, 0, 0.7);
            transform: translateY(-5px);
        }
        .character-option.selected {
            border-color: var(--accent-color);
            box-shadow: 0 0 15px var(--accent-color);
        }
        .character-name {
            color: white;
            margin-top: 6px;  /* å‡å°ä¸Šè¾¹è· */
            font-size: 12px;  /* å‡å°å­—ä½“å¤§å° */
        }
        .character-preview {
            width: 50px;  /* å‡å°é¢„è§ˆå›¾å°ºå¯¸ */
            height: 50px;  /* å‡å°é¢„è§ˆå›¾å°ºå¯¸ */
            margin: 0 auto;
            position: relative;
            overflow: hidden;
        }
        .sprite-preview {
            image-rendering: pixelated;
        }
        .character-silhouette {
            position: relative;
            width: 50px;  /* å‡å°å‰ªå½±å°ºå¯¸ */
            height: 50px;  /* å‡å°å‰ªå½±å°ºå¯¸ */
        }
        .silhouette {
            filter: brightness(0);
            opacity: 0;
        }
        .question-mark {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: var(--accent-color);
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.7);
        }
        .unlock-hint {
            position: absolute;
            bottom: -30px;  /* å¢åŠ åº•éƒ¨é—´è· */
            left: 0;
            right: 0;
            font-size: 12px;
            color: var(--accent-light);
        }
        .character-option.locked {
            cursor: not-allowed;
            opacity: 0.8;
        }
        .character-option.locked:hover {
            transform: none;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        .shake {
            animation: shake 0.5s;
        }
        .unlock-notification {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--accent-color);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            color: white;
            z-index: 200;
            animation: popup 0.5s, fadeout 0.5s 3s forwards;
        }
        .unlock-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }
        .unlock-message {
            font-size: 24px;
            color: var(--accent-light);
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        @keyframes popup {
            from { transform: translate(-50%, -50%) scale(0); }
            to { transform: translate(-50%, -50%) scale(1); }
        }
        @keyframes fadeout {
            from { opacity: 1; }
            to { opacity: 0; }
        }
    </style>
</head>
<body>
    <!-- æ·»åŠ ç½‘ç«™å›¾æ ‡ -->
    <link rel="icon" type="image/png" href="favicon.png">

    <!-- æ·»åŠ åŠ è½½æç¤º -->
    <div id="loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">æ¸¸æˆåŠ è½½ä¸­...</div>
    </div>

    <style>
    /* æ·»åŠ åŠ è½½åŠ¨ç”»æ ·å¼ */
    #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #1E1A4A;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 9999;
    }

    .loading-spinner {
        width: 50px;
        height: 50px;
        border: 5px solid #FFD86B;
        border-top: 5px solid transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .loading-text {
        margin-top: 20px;
        color: #FFFFFF;
        font-family: 'Pixel', monospace;
    }
    </style>

    <script>
    // æ·»åŠ èµ„æºé¢„åŠ è½½
    window.addEventListener('load', function() {
        // éšè—åŠ è½½å±å¹•
        document.getElementById('loading-screen').style.display = 'none';
    });

    // æ·»åŠ ç¦»çº¿ç¼“å­˜æ”¯æŒ
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('sw.js')
            .then(registration => console.log('ServiceWorker registered'))
            .catch(error => console.log('ServiceWorker error:', error));
    }
    </script>

    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div class="ui-container">
            <div id="score-container" class="stats-box">
                <div class="stats-icon">ğŸ…</div>
                <span id="score">0</span>
            </div>
            <div id="tea-container" class="stats-box">
                <div class="stats-icon">ğŸµ</div>
                <span id="tea-count">2</span>
            </div>
        </div>
        <div id="distance-container" class="stats-box">
            <span id="distance">0</span> ç±³
        </div>
        <div id="milestone-notification">é‡Œç¨‹ç¢‘: 3000ç±³!</div>
        <div id="start-screen">
            <h1 id="game-title">èŒ¶èŒ¶ä¹æ·˜é‡‘è®°</h1>
            <div class="instructions">
                ä¸å°ä¹å°èŒ¶ä¸€èµ·å¥”è·‘ï¼Œè·³è¿‡éšœç¢ï¼Œèµ¢å¾—é‡‘ç‰Œï¼<br>
                <span style="color: var(--accent-light);">ç©ºæ ¼é”®/ç‚¹å‡»å±å¹•</span> è¿›è¡Œè·³è·ƒ
            </div>
            <div id="game-controls">
                <button id="start-btn" class="pixel-btn">å¼€å§‹æ¸¸æˆ</button>
                <div style="margin-top: 15px; font-size: 14px; color: var(--accent-light);">BYï¼šåˆº</div>
            </div>
        </div>
        <div id="game-over">
            <h2 style="font-size: 22px; margin-bottom: 0px; color: var(--accent-light);">æ¸¸æˆç»“æŸ</h2>
            <div class="score-box">
                <div id="final-score">é‡‘ç‰Œæ•°é‡: 0</div>
                <div id="high-score" style="color: var(--accent-light);">æœ€é«˜é‡‘ç‰Œæ•°é‡: 0</div>
                <div id="final-distance" style="margin-top: 3px;">è·ç¦»: 0 ç±³</div>
            </div>
            <div id="character-selection" style="margin: 5px 0;">
                <h3 style="margin-bottom: 5px; color: var(--accent-light);font-size: 16px;">é€‰æ‹©è§’è‰²</h3>
                <div class="character-options">
                    <div class="character-option selected" data-character="sprite">
                        <img src="sprite.png" style="width: 50px; height: 50px; object-fit: contain;">
                        <div class="character-name">å°ä¹å°èŒ¶</div>
                    </div>
                    <div class="character-option" data-character="sprite02">
                        <img src="sprite02.png" style="width: 50px; height: 50px; object-fit: contain;">
                        <div class="character-name">æ–°è§’è‰²</div>
                    </div>
                </div>
            </div>
            <button id="restart-btn" class="pixel-btn" style="margin-top: 3px; margin-bottom: 3px;">å†ç©ä¸€æ¬¡</button>
            <div class="author-credit" style="margin-top: 3px; font-size: 12px; color: var(--accent-light);">BYï¼šåˆº</div>
        </div>
    </div>

    <div id="mobile-controls">
        <button id="jump-btn">è·³è·ƒ</button>
    </div>

    <script>
        // Game setup
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreDisplay = document.getElementById('final-score');
        const highScoreDisplay = document.getElementById('high-score');
        const finalDistanceDisplay = document.getElementById('final-distance');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const jumpBtn = document.getElementById('jump-btn');
        const milestoneNotification = document.getElementById('milestone-notification');

        // Set canvas size
        canvas.width = 800;
        canvas.height = 480;
        
        // Game state
        let gameRunning = false;
        let gameSpeed = 5;
        let gravity = 0.5;
        let score = 0;
        let highScore = 0;
        let distance = 0;
        let frameCount = 0;
        let lastMilestone = 0;
        const distanceDisplay = document.getElementById('distance');
        
        // æ·»åŠ è§’è‰²è§£é”çŠ¶æ€ç®¡ç†
        function saveUnlockStatus() {
            // ä½¿ç”¨localStorageä¿å­˜è§’è‰²è§£é”çŠ¶æ€
            localStorage.setItem('characterUnlocked', JSON.stringify(window.characterUnlocked));
        }

        function loadUnlockStatus() {
            // ä»localStorageåŠ è½½è§’è‰²è§£é”çŠ¶æ€
            const savedStatus = localStorage.getItem('window.characterUnlocked');
            if (savedStatus) {
                try {
                    characterUnlocked = JSON.parse(savedStatus);
                } catch (e) {
                    // å¦‚æœè§£æå‡ºé”™ï¼Œä½¿ç”¨é»˜è®¤å€¼
                    window.characterUnlocked = {
                        'sprite': true,
                        'sprite02': false
                    };
                }
            }
        }
        
        // è§†å›¾/ç›¸æœºè®¾ç½®
        let cameraY = 0; // ç›¸æœºå‚ç›´åç§»é‡
        let targetCameraY = 0; // ç›®æ ‡ç›¸æœºä½ç½®

        // Background state
        let currentBgStage = 0;
        let activeSceneName = null; // Track which scene is currently active
        let gameScene = 'sakura'; // Default game scene
        let clouds = []; // Cloud array
        let fireworksCity = []; // å®šä¹‰fireworksCityå˜é‡
        
        const bgStages = [
            { name: "å¤œé—´ä½“è‚²åœº", color1: "#0C0C24", color2: "#1E1E3F", groundColor: "#343A6B" },
            { name: "ä¸€èµ·çˆ¬å±±å§ï¼", color1: "#1A2C50", color2: "#4B3F72", groundColor: "#454F7A" },
            { name: "é›¨å¤œæµ·ç›—èˆ¹", color1: "#0A1B29", color2: "#1A2C3E", groundColor: "#253545" }, // æ–°å¢åœºæ™¯
            { name: "æµ·åº•æ½œè‰‡", color1: "#051525", color2: "#0E2B4E", groundColor: "#1A3A5E" },
            { name: "æ¨±èŠ±åº­é™¢", color1: "#362852", color2: "#4A3B65", groundColor: "#443A68" },
            { name: "æ˜Ÿç©ºæµæ˜Ÿé›¨", color1: "#050A24", color2: "#1A1559", groundColor: "#232654" },
            { name: "ä¸€èµ·æ”¾çƒŸèŠ±", color1: "#0F0618", color2: "#2A0A44", groundColor: "#26104E" }
        ];

        // Special background elements for each milestone
        const bgElements = [
            { 
                distance: 1200, 
                name: "mountains",
                setup: createMountains, 
                draw: drawMountains,
                description: "ä¸€èµ·ç™»å±±ï¼", 
                color: "#ffcc00" 
            },
            {
                distance: 3700,  // åœ¨å±±åŒºå’Œæ½œè‰‡ä¹‹é—´çš„è·ç¦»
                name: "pirateShip",
                setup: createPirateShipScene,
                draw: drawPirateShipScene,
                description: "é›¨å¤œè¡Œèˆ¹ï¼",
                color: "#4682B4"
            },
            { 
                distance: 6700, 
                name: "pirate",
                setup: createPirateScene, 
                draw: drawPirateScene,
                description: "æµ·åº•ä¸¤ä¸‡é‡Œï¼", 
                color: "#4682B4" 
            },
            { 
                distance: 10200, 
                name: "cherryBlossom",
                setup: createCherryBlossom, 
                draw: drawCherryBlossom,
                description: "æ°å¦‚å¤©ä¸Šæœˆï¼", 
                color: "#FF9CCB" 
            },
            { 
                distance: 14200, 
                name: "meteors",
                setup: createMeteorShower, 
                draw: drawMeteors,
                description: "ä¸€èµ·æ¥çœ‹æµæ˜Ÿé›¨ï¼", 
                color: "#FF5252" 
            },
            { 
                distance: 17700, 
                name: "fireworks",
                setup: createFireworks, 
                draw: drawFireworks,
                description: "ä¸€èµ·æ”¾çƒŸèŠ±ï¼", 
                color: "#FF4081" 
            }
        ];
        
        // Background element containers
        let mountains = [];
        let pirateElements = [];
        let cherrySakura = [];
        let gardenElements = [];
        let meteors = [];
        let fireworks = [];

        // Animation state
        let runningAnimationFrame = 0;
        let runningAnimationSpeed = 3; // frames per animation step (faster)
        let animationTimer = 0;
        let bodyTilt = 0; // For body tilt animation

        // åœ°å›¾ç›¸å…³å˜é‡
        let currentMap = "initialMap"; // æ·»åŠ ï¼šå®šä¹‰å½“å‰é€‰æ‹©çš„åœ°å›¾å˜é‡ï¼Œé»˜è®¤ä¸ºåˆå§‹åœ°å›¾
        // æ·»åŠ ï¼šå®šä¹‰åœ°å›¾è§£é”çŠ¶æ€å˜é‡
        let mapUnlocked = {
            initialMap: true,  // åˆå§‹åœ°å›¾é»˜è®¤è§£é”
            newMap: false      // æ–°åœ°å›¾é»˜è®¤æœªè§£é”
        };
        const MAP_UNLOCK_SCORE = 188;  // æ·»åŠ ï¼šå®šä¹‰è§£é”æ–°åœ°å›¾æ‰€éœ€çš„é‡‘ç‰Œæ•°é‡
        const mapConfigs = {  // æ·»åŠ ï¼šå®šä¹‰ä¸åŒåœ°å›¾çš„é…ç½®å¯¹è±¡
            initialMap: {  // æ·»åŠ ï¼šåˆå§‹åœ°å›¾é…ç½®
                name: "èœœæœˆæ—…è¡Œ",  // æ·»åŠ ï¼šåœ°å›¾æ˜¾ç¤ºåç§°
                description: "åŒ…å«å¤šç§ç²¾å½©åœºæ™¯çš„å†’é™©ä¹‹æ—…",  // æ·»åŠ ï¼šåœ°å›¾æè¿°
                bgElements: bgElements  // æ·»åŠ ï¼šä½¿ç”¨åŸæœ‰çš„bgElements
            },
            newMap: {  // æ·»åŠ ï¼šæ–°åœ°å›¾é…ç½®
            name: "æœ«æ—¥æ—…è¡Œ",  // æ·»åŠ ï¼šåœ°å›¾æ˜¾ç¤ºåç§°
            description: "çº¯å‡€çš„å¤œç©ºèƒŒæ™¯",  // æ·»åŠ ï¼šåœ°å›¾æè¿°
            bgElements: [],  // æ·»åŠ ï¼šæ–°åœ°å›¾æ²¡æœ‰ç‰¹æ®Šåœºæ™¯ï¼Œæ•°ç»„ä¸ºç©º
            unlockScore: MAP_UNLOCK_SCORE  // æ·»åŠ ï¼šè§£é”æ‰€éœ€åˆ†æ•°
    }
};
        // æ·»åŠ ï¼šèƒŒæ™¯åˆ‡æ¢ç›¸å…³é…ç½®
        const BACKGROUND_CHANGE_DISTANCE = 3000; // æ¯3000ç±³åˆ‡æ¢ä¸€æ¬¡èƒŒæ™¯ ã€è¯´æ˜ã€‘ï¼šå®šä¹‰èƒŒæ™¯åˆ‡æ¢çš„è·ç¦»é—´éš”
        const BACKGROUNDS_SEQUENCE = ['bg1', 'bg2', 'bg3', 'bg4', 'bg5']; // èƒŒæ™¯åˆ‡æ¢é¡ºåº ã€è¯´æ˜ã€‘ï¼šå®šä¹‰èƒŒæ™¯åˆ‡æ¢çš„é¡ºåº

// æ·»åŠ ï¼šèƒŒæ™¯åˆ‡æ¢çŠ¶æ€
        let currentBackgroundState = {
            current: 'bg1',         // å½“å‰æ˜¾ç¤ºçš„èƒŒæ™¯ ã€è¯´æ˜ã€‘ï¼šå½“å‰æ­£åœ¨æ˜¾ç¤ºçš„èƒŒæ™¯
            next: null,             // ä¸‹ä¸€ä¸ªè¦æ˜¾ç¤ºçš„èƒŒæ™¯ ã€è¯´æ˜ã€‘ï¼šå³å°†åˆ‡æ¢åˆ°çš„èƒŒæ™¯
            fadeProgress: 0,        // è¿‡æ¸¡è¿›åº¦(0-1) ã€è¯´æ˜ã€‘ï¼šæ§åˆ¶è¿‡æ¸¡åŠ¨ç”»çš„è¿›åº¦
            isFading: false,        // æ˜¯å¦æ­£åœ¨è¿‡æ¸¡ä¸­ ã€è¯´æ˜ã€‘ï¼šæ ‡è®°æ˜¯å¦æ­£åœ¨æ‰§è¡Œè¿‡æ¸¡åŠ¨ç”»
            fadeDuration: 60,       // è¿‡æ¸¡æŒç»­çš„å¸§æ•° ã€è¯´æ˜ã€‘ï¼šæ§åˆ¶è¿‡æ¸¡åŠ¨ç”»çš„é€Ÿåº¦
            lastChangeDistance: 0   // ä¸Šæ¬¡åˆ‡æ¢çš„è·ç¦» ã€è¯´æ˜ã€‘ï¼šè®°å½•ä¸Šæ¬¡åˆ‡æ¢èƒŒæ™¯çš„è·ç¦»
        }; // ã€è¯´æ˜ã€‘ï¼šç®¡ç†èƒŒæ™¯åˆ‡æ¢çš„çŠ¶æ€å’Œè¿‡æ¸¡æ•ˆæœ
        // Sound effects
// è¶…çº§é©¬é‡Œå¥¥é£æ ¼çš„é‡‘å¸æ”¶é›†éŸ³æ•ˆï¼ˆæç®€ç‰ˆæœ¬ï¼‰
        const collectSound = new Audio('shoujijinbi.mp3');        
        collectSound.volume = 0.2;

        const gameoverSound = new Audio('data:audio/wav;base64,UklGRrQDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YZADAABp/5X/0v/W/7//pf9e/0//ev+S/7j/3//8/wMABwAFABUAQgB7ALkA9QAiAUMBWQFnAWABUgFCAT0BQAFFAUYBQQEsAQkB1QCSAFUAGwDd/53/Yf8h/+z+tf6L/nD+X/5V/lr+cf6V/tD+Gf9o/7j/DQBhAK8A+gA+AWQBeQF+AW4BTgEjAesAoQBUAAgAuf9i/w3/uP5j/g/+vf1r/SD91/yX/Fj8KPwH/On75vvk+/370/vX++v7A/wk/FP8hvzA/Az9WP2j/e/9Qf6U/uj+Pf+T/+b/OACPAOMAOQGCAbsBDQI6Ilo2wfrt+ZT5pflK+gf72/o5+lf6CPyR/T395vwP/Z3+SADDAD4BgQJnA/IDXQSYBOMEyQTfBCMFNgUJBaMEPARqAwICwgDo/yT/TP6X/QT9c/zn+3P7FPvI+qH6jfqS+qr64/oj+3T72PtB/Lf8NP23/Tn+xf5M/9b/YQDtAHYB/gGHAvgCaQPKAycEhQTdBCwFcwW3BfsFFwY8Bl4GcQaLBpoGqQaqBrEGsAaxBq0GnwaTBosGdwZkBk0GOAYbBvYF0QWlBW8FOgX+BL4EegQ5BPcDvgN/AzsD9QLHAokCSQILAskBewE5AfYAuAByACsA4/+g/1j/Hf/c/pn+Xf4i/ub9r/19/Uj9FP3s/LX8i/xa/DX8Efzu+9X7vvuq+5H7gvt0+2r7YPte+177avt6+4r7pvvF++f7D/w4/Gf8mPzK/P38MP1m/Z79z/0K/kL+e/62/u/+KP9f/5r/0/8NAEIAeQCuAOMACwE4AVUBiwGxAc8B8AEAASQB1ACXAFsAKQDbAGkB/gGPAiADjQMiBJYEFgWKBe4FYQa4BgMHTweLB8MH+QcgCD0IWwhrCHsIfwiJCI0IlQiPCIoIeghwCFMIPAgiCPsH3AfBB6IHgQdhBz0HEQfsBr4GkAZqBjQGCQbQBaAFagUvBfcEvgSFBFAEEgTYA54DZQM3A/0C0AKFAkwCFgLgAasBagE7AfkAvACEAEsAEQDb/5j/bP8g/+f+pf5x/jj+Dv7V/a79ev1E/Rf96/y7/JT8afw//Bj87fvN+637jPt0+177Uvs9+zT7I/sl+yP7KPst+zf7Qvtc+2n7hfud+8D73/sI/C38U/x+/Kn81PwD/S/9XP2Q/b39+P0i/lf+if7A/vL+Lf9g/5n/yP8EADcAcACmANsAEgFGAYYBsAHzANkBEQLPAikDnwMRBG8E3QQwBYYF0AUgBmkGuQb9Bj0HfAfBBwEIQAh7CK4I3QgACTAJUwl1CZUJsAnECeEJ7QkBCgkKGQofCjYKPwpDClcKVwpmCmUKbApvCm8KcQpuCnQKcgp5CoAKiQqPCpiKnQqkCp8KlQqRCo0KkgqLCowKfQp5CnUKYwpvClkKRQpJCjMKKgo');
        gameoverSound.volume = 0.3;


// æ·»åŠ ï¼šæ–°åœ°å›¾èƒŒæ™¯å›¾ç‰‡åŠ è½½
        const newMapBackgrounds = {
        bg1: { image: new Image(), src: 'xinditu01.png' },
        bg2: { image: new Image(), src: 'xinditu02.png' },
        bg3: { image: new Image(), src: 'xinditu03.png' },
        bg4: { image: new Image(), src: 'xinditu04.png' },
        bg5: { image: new Image(), src: 'xinditu05.png' }
        }; // ã€è¯´æ˜ã€‘ï¼šåˆ›å»ºæ–°åœ°å›¾çš„èƒŒæ™¯å›¾ç‰‡å¯¹è±¡é›†åˆ

        collectSound.addEventListener('error', function() {
        console.error('æ— æ³•åŠ è½½é‡‘å¸éŸ³æ•ˆæ–‡ä»¶shoujijinbi.mp3ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨');
        });

        // åˆå§‹åŒ–åŠ è½½æ‰€æœ‰èƒŒæ™¯å›¾ç‰‡
        Object.values(newMapBackgrounds).forEach(bg => {
            bg.image.src = bg.src;
        }); // ã€è¯´æ˜ã€‘ï¼šé¢„åŠ è½½æ‰€æœ‰èƒŒæ™¯å›¾ç‰‡æ‰€æœ‰èƒŒæ™¯å›¾ç‰‡ï¼Œå¹¶åœ¨åŠ è½½å®Œæˆæ—¶åˆ†æé¢œè‰²

        // æ·»åŠ GMæŒ‡ä»¤å¤„ç†å‡½æ•°
        function handleGMCommand(key) {
            if (key === 'g' || key === 'G') {
                score += 300;
                scoreDisplay.textContent = score;
                
                if (score > highScore) {
                    highScore = score;
                    highScoreDisplay.textContent = "æœ€é«˜é‡‘ç‰Œæ•°é‡: " + highScore;
                }
                
                if (score >= UNLOCK_SCORE && !window.characterUnlocked.sprite02) {
                    window.characterUnlocked.sprite02 = true;
                    saveUnlockStatus();
                    showUnlockNotification('å°å˜å°å“å·²è§£é”ï¼');
                    
                    if (gameOverScreen.style.display === 'flex') {
                        updateCharacterSelectionUI();
                    }
                }
                
                console.log('GM Command: Added 300 to score');
                
            } else if (key === 'p' || key === 'P') {
                // å¿«é€Ÿå‘¼å‡ºæµ·ç›—èˆ¹åœºæ™¯
                console.log('GM Command: åˆ‡æ¢åˆ°æµ·ç›—èˆ¹åœºæ™¯');
                
                // è®¾ç½®è·ç¦»åˆ°æµ·ç›—èˆ¹åœºæ™¯çš„é‡Œç¨‹ç¢‘
                distance = 7500;
                distanceDisplay.textContent = Math.floor(distance);
                
                // æ‰‹åŠ¨è§¦å‘åœºæ™¯åˆ‡æ¢
                checkMilestones();
                
                // æ˜¾ç¤ºæç¤º
                showMilestoneNotification("å¼€å‘æ¨¡å¼: æµ·ç›—èˆ¹åœºæ™¯å·²åŠ è½½", "#4682B4");
            }
            else if (key === 'm' || key === 'M') {
    // åˆ‡æ¢æ–°åœ°å›¾è§£é”çŠ¶æ€
                    mapUnlocked.newMap = !mapUnlocked.newMap;
                    saveMapUnlockStatus();
    
    // æ˜¾ç¤ºæç¤º
                    const status = mapUnlocked.newMap ? "å·²è§£é”" : "å·²é”å®š";
                    showMilestoneNotification(`æœ«æ—¥æ—…è¡Œ: ${status}`, "#4682B4");
            }
            // [æ–°å¢] æŒ‰Ré”®é‡ç½®è§’è‰²è§£é”çŠ¶æ€
            else if (key === 'r' || key === 'R') {
        // é‡ç½®è§’è‰²è§£é”çŠ¶æ€
            characterUnlocked = {
            'sprite': true,     // åˆå§‹è§’è‰²ä¿æŒè§£é”
            'sprite02': false   // æ–°è§’è‰²é‡ç½®ä¸ºæœªè§£é”
        };
        // ä¿å­˜åˆ°localStorage
        saveUnlockStatus();
        // æ›´æ–°UI
        updateCharacterSelectionUI();
        // æ˜¾ç¤ºæç¤º
        showMilestoneNotification("å·²é‡ç½®è§’è‰²è§£é”çŠ¶æ€", "#FF6B6B");
        console.log('GM Command: è§’è‰²è§£é”çŠ¶æ€å·²é‡ç½®');
    }
    // [æ–°å¢] æŒ‰Lé”®æŸ¥çœ‹å½“å‰è§£é”çŠ¶æ€
    else if (key === 'u' || key === 'U') {
    // ç›´æ¥è®¾ç½®è§£é”çŠ¶æ€
    window.characterUnlocked.sprite02 = true;
    
    // ä¿å­˜åˆ°localStorage
    saveUnlockStatus();
    
    // å¼ºåˆ¶æ›´æ–°UI
    updateCharacterSelectionUI();
    
    // è¾“å‡ºè°ƒè¯•ä¿¡æ¯
    console.log('è°ƒè¯•å‘½ä»¤: å¼ºåˆ¶è§£é”è§’è‰²', window.characterUnlocked);
    showMilestoneNotification("è°ƒè¯•: å·²å¼ºåˆ¶è§£é”è§’è‰²", "#4682B4");
    
    // è¾“å‡ºDOMçŠ¶æ€
    const characterElement = document.querySelector('.character-option[data-character="sprite02"]');
    console.log('è§’è‰²å…ƒç´ ç±»å:', characterElement.className);
    console.log('è§’è‰²é¢„è§ˆHTML:', document.querySelector('.character-option[data-character="sprite02"] .character-preview').innerHTML);
}
    else if (key === 'l' || key === 'L') {
        console.log('å½“å‰è§’è‰²è§£é”çŠ¶æ€:', characterUnlocked);
        const status = characterUnlocked.sprite02 ? "å·²è§£é”" : "æœªè§£é”";
        showMilestoneNotification(`å°å˜å°å“: ${status}`, "#4682B4");
    }
}

// ä¿®æ”¹ç°æœ‰çš„é”®ç›˜äº‹ä»¶ç›‘å¬å™¨
window.addEventListener('keydown', function(e) {
    if (!gameRunning && (e.code === 'Space' || e.key === ' ')) {
        startGame();
    }
    
    // æ·»åŠ GMæŒ‡ä»¤æ£€æµ‹
    if (gameRunning) {
        handleGMCommand(e.key);
    }
});

// Characters
const playerHeight = 100;
const playerWidth = 85;
const groundHeight = 30;
const GROUND_Y = canvas.height - playerHeight - groundHeight + 55; // å°†+20æ”¹ä¸º+50ï¼Œä½¿è§’è‰²æ›´è´´è¿‘åœ°é¢

let player = {
    x: 50,
    y: GROUND_Y,
    width: playerWidth,
    height: playerHeight,
    jumping: false,
    jumpForce: 10,           // å¢åŠ åŸºç¡€è·³è·ƒåŠ›ï¼ˆä»11æ”¹ä¸º5ï¼‰
    maxJumpForce: 18,        // å¢åŠ æœ€å¤§è·³è·ƒåŠ›ï¼ˆä»16æ”¹ä¸º19ï¼‰
    jumpTimeStart: 0,
    maxJumpHoldTime: 370,    // å¢åŠ æœ€å¤§è“„åŠ›æ—¶é—´ï¼ˆä»300æ”¹ä¸º400ï¼‰
    minJumpHoldTime: 50,
    yVelocity: 0,
    frameX: 0,
    frameY: 0,
    animationSpeed: 0.15,
    animationTimer: 0,
    bodyTilt: 0,
    runningPhase: 0,
    invincible: false,
    invincibleTimer: 0,
    invincibleDuration: 5000, // æ— æ•Œæ—¶é—´5ç§’
    sparkles: [], // ç”¨äºå­˜å‚¨ç‰¹æ•ˆç²’å­
    glowIntensity: 0, // å‘å…‰å¼ºåº¦
    teaCollectFlash: 0 // æ”¶é›†èŒ¶é“å…·æ—¶çš„é—ªå…‰æ•ˆæœ
};

// åŠ è½½æ–°çš„ç²¾çµå›¾
const characterSprite = new Image();
characterSprite.src = "sprite.png";

// ç²¾çµå›¾åŠ¨ç”»é…ç½®
const spriteConfig = {
    frameWidth: 1280,
    frameHeight: 760,
    totalFrames: 10,
    framesPerRow: 5,
    rows: 2,
    runFrames: {row: 0, frames: [0, 1, 2, 3, 4]},
    jumpFrames: {row: 1, frames: [0, 1, 2, 3, 4]}
};

// Color palette for pixel art
const palette = {
    background: '#141432',
    ground: '#4466CC',
    koalaBody: '#A0A0A0',
    koalaEar: '#808080',
    koalaEarInner: '#FFCBC0',
    koalaEye: '#000000',
    koalaEyeArea: '#FFFFFF',
    koalaNose: '#000000',
    kittyBody: '#FFC0CB',
    kittyBodyDark: '#FF9CAC',
    kittyFace: '#FFFFFF',
    kittyBow: '#FF0000',
    kittyEye: '#000000',
    kittyNose: '#FFFF00',
    gold: '#FFD700',
    goldShine: '#FFFFFF',
    goldRibbon: '#CC0000',
    teaColor: '#66CC66',
    teaCup: '#FFFFFF',
    obstacleColors: {
        horse: '#D2B48C',
        horseLeg: '#8B4513',
        horsePadding: '#CD853F',
        horseHandle: '#A0522D',
        pool: '#1E90FF',
        poolEdge: '#FFFFFF',
        poolWave: '#ADD8E6',
        hurdle: '#D2691E',
        hurdleSupport: '#A52A2A',
        hurdleTop: '#FF4500',
        hurdleStripe: '#FFFFFF',
        rail: '#696969',
        railPost: '#A9A9A9',
        railTop: '#C0C0C0',
        railLine: '#808080',
        beam: '#6D4C41',
        beamSupport: '#5D4037',
        beamPad: '#8D6E63',
        pommelHorse: '#BC8F8F',
        pommelHandles: '#8B4513',
        divingBoard: '#795548',
        divingSpring: '#8D6E63',
        platform: '#795548',
        bar: '#FFD700',
        ring: '#FF5722'
    }
};

// Obstacles
const obstacleTypes = {
    HORSE: 0,
    POOL: 1,
    HURDLE: 2,
    RAIL: 3,
    BALANCE_BEAM: 4,
    POMMEL_HORSE: 5,
    DIVING_BOARD: 6,
    RINGS: 7,
    BARREL: 8,
    BIRD: 9,
    CRATE: 10,
    CACTUS: 11,
    SNAKE: 12,
    PARALLEL_BARS: 13,
    WATER_JUMP: 14,
    HIGH_JUMP: 15,
    UNEVEN_BARS: 16
};

let obstacles = [];
const obstacleHeight = {
    [obstacleTypes.HORSE]: 50,
    [obstacleTypes.POOL]: 20,
    [obstacleTypes.HURDLE]: 40,
    [obstacleTypes.RAIL]: 30,
    [obstacleTypes.BALANCE_BEAM]: 30,
    [obstacleTypes.POMMEL_HORSE]: 50,
    [obstacleTypes.DIVING_BOARD]: 40,
    [obstacleTypes.RINGS]: 70,
    [obstacleTypes.BARREL]: 35,
    [obstacleTypes.BIRD]: 20,
    [obstacleTypes.CRATE]: 40,
    [obstacleTypes.CACTUS]: 40,
    [obstacleTypes.SNAKE]: 15
};
const obstacleWidth = {
    [obstacleTypes.HORSE]: 60,
    [obstacleTypes.POOL]: 100,
    [obstacleTypes.HURDLE]: 20,
    [obstacleTypes.RAIL]: 80,
    [obstacleTypes.BALANCE_BEAM]: 120,
    [obstacleTypes.POMMEL_HORSE]: 70,
    [obstacleTypes.DIVING_BOARD]: 50,
    [obstacleTypes.RINGS]: 40,
    [obstacleTypes.BARREL]: 35,
    [obstacleTypes.BIRD]: 30,
    [obstacleTypes.CRATE]: 40,
    [obstacleTypes.CACTUS]: 25,
    [obstacleTypes.SNAKE]: 40
};

// Collectibles
let medals = [];
const medalSize = 20;
const collectibleTypes = {
    GOLD: 0,
    TEA: 1
};

// Player stats
let teaCount = 2; // Start with 2 tea items

// Game background elements
const cloudPositions = [];
for (let i = 0; i < 6; i++) {
    cloudPositions.push({
        x: Math.random() * canvas.width,
        y: Math.random() * 100 + 20,
        width: Math.random() * 60 + 40,
        height: Math.random() * 30 + 20, // Added height for more natural clouds
        puffs: [], // Will contain individual cloud parts
        speed: Math.random() * 0.5 + 0.2
    });
    
    // Initialize cloud puffs for more natural shapes
    const cloud = cloudPositions[i];
    const puffCount = 3 + Math.floor(Math.random() * 3);
    for (let j = 0; j < puffCount; j++) {
        cloud.puffs.push({
            x: cloud.x + (j / (puffCount - 1)) * cloud.width,
            y: cloud.y + Math.sin(j * 0.8) * (cloud.height * 0.2),
            size: cloud.height * (0.6 + Math.random() * 0.4)
        });
    }
}

// Stars for background
const stars = [];
for (let i = 0; i < 70; i++) {
    stars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * (canvas.height - 100),
        size: Math.random() * 2 + 1,
        twinkle: Math.random() * 100
    });
}

// Track markings
const trackMarkings = [];
const markingWidth = 30;
const markingGap = 50;
for (let x = 0; x < canvas.width + markingWidth + markingGap; x += markingWidth + markingGap) {
    trackMarkings.push(x);
}

// Create particle system for effects
const particles = [];

function createParticles(x, y, color, count = 10) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 3,
            vy: (Math.random() - 0.5) * 3,
            color: color,
            size: Math.random() * 3 + 1,
            life: Math.random() * 30 + 10
        });
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.life--;
        
        if (particle.life <= 0) {
            particles.splice(i, 1);
        }
    }
}

function drawParticles() {
    for (const particle of particles) {
        ctx.globalAlpha = particle.life / 40;
        ctx.fillStyle = particle.color;
        ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
    }
    ctx.globalAlpha = 1;
}

// æ·»åŠ ç»˜åˆ¶è½¨é“/åœ°é¢å‡½æ•°
function drawTrack() {
    // è·å–å½“å‰èƒŒæ™¯é˜¶æ®µ
    const bg = bgStages[currentBgStage];
    
    // åˆ¤æ–­å½“å‰åœºæ™¯
    const isUnderwaterScene = activeSceneName === "pirate";
    const isPirateShipScene = activeSceneName === "pirateShip"; 
    const isCherryBlossomScene = activeSceneName === "cherryBlossom"; // æ·»åŠ æ¨±èŠ±åœºæ™¯æ£€æµ‹

    // æ·»åŠ ï¼šåˆ¤æ–­æ˜¯å¦ä¸ºæ–°åœ°å›¾
    const isNewMap = currentMap === "newMap";
    
    if (isNewMap) {
        // æ‰‹åŠ¨è®¾ç½®é¢œè‰²
        let primaryColor = '#D0D0D0';  // é»˜è®¤æµ…ç°è‰²
        let secondaryColor = '#B0B0B0'; // é»˜è®¤æ·±ç°è‰²
        
        // æ ¹æ®å½“å‰èƒŒæ™¯é€‰æ‹©é¢œè‰²
        if (currentBackgroundState && currentBackgroundState.current) {
            switch(currentBackgroundState.current) {
                case 'bg1':
                    primaryColor = '#161c37';  // æ‚¨æŒ‡å®šçš„é¢œè‰² - æ·±è“è‰²
                    secondaryColor = '#12162c'; // ç¨æš—ä¸€äº›
                    break;
                case 'bg2':
                    primaryColor = '#16212d';  // æ‚¨æŒ‡å®šçš„é¢œè‰² - æ·±é’è‰²
                    secondaryColor = '#121a24'; // ç¨æš—ä¸€äº›
                    break;
                case 'bg3': 
                    primaryColor = '#172d57';  // æ‚¨æŒ‡å®šçš„é¢œè‰² - è“è‰²
                    secondaryColor = '#132446'; // ç¨æš—ä¸€äº›
                    break;
                case 'bg4':
                    primaryColor = '#0f1137';  // æ‚¨æŒ‡å®šçš„é¢œè‰² - æ·±ç´«è‰²
                    secondaryColor = '#0f1137'; // ç¨æš—ä¸€äº›
                    break;
                case 'bg5':
                    primaryColor = '#17072d';  // æ‚¨æŒ‡å®šçš„é¢œè‰² - ç´«è‰²
                    secondaryColor = '#130624'; // ç¨æš—ä¸€äº›
                    break;
                default:
                    // è‹¥æœªçŸ¥èƒŒæ™¯ï¼Œä½¿ç”¨é»˜è®¤æ·±è“è‰²
                    primaryColor = '#161c37';
                    secondaryColor = '#12162c';
            }
        }
        
        // åˆ›å»ºä»èƒŒæ™¯åº•éƒ¨åˆ°è·‘é“çš„æ¸å˜
        const trackGradient = ctx.createLinearGradient(0, canvas.height - 30, 0, canvas.height);
        trackGradient.addColorStop(0, primaryColor);   // ä¸»è‰²è°ƒ
        trackGradient.addColorStop(1, secondaryColor); // æ¬¡è‰²è°ƒ
        
        // ç»˜åˆ¶ä¸»è¦è·‘é“
        ctx.fillStyle = trackGradient;
        ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
        
        // æ·»åŠ è·‘é“æ ‡è®° - çº¯ç™½è‰²çº¿æ¡ï¼Œåœ¨æ·±è‰²èƒŒæ™¯ä¸Šæ›´åŠ æ˜æ˜¾
        ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
    }
    else if (isPirateShipScene) {
        // åˆ›å»ºä»æš´é£é›¨æµ·é¢åˆ°è·‘é“çš„æ¸å˜
        const trackGradient = ctx.createLinearGradient(0, canvas.height - 30, 0, canvas.height);
        trackGradient.addColorStop(0, '#334759'); // ä¸æµ·ç›—èˆ¹åœºæ™¯åº•éƒ¨é¢œè‰²ç›¸åŒ¹é…
        trackGradient.addColorStop(1, '#253545'); // ä¸æµ·ç›—èˆ¹è·‘é“é¢œè‰²ç›¸åŒ¹é…
        
        // ç»˜åˆ¶ä¸»è¦è·‘é“
        ctx.fillStyle = trackGradient;
        ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
        
        // æ·»åŠ é›¨å¤œè·‘é“æ ‡è®° - æ›´åŠ æ˜æ˜¾çš„ç™½è‰²æ ‡è®°
        ctx.fillStyle = "rgba(220, 220, 220, 0.3)";
    }
    else if (isUnderwaterScene) {
        // åˆ›å»ºä»æ·±æµ·è“åˆ°è·‘é“è“çš„æ¸å˜
        const trackGradient = ctx.createLinearGradient(0, canvas.height - 30, 0, canvas.height);
        trackGradient.addColorStop(0, '#0d4a6e'); // ä¸æµ·åº•èƒŒæ™¯åº•éƒ¨é¢œè‰²ç›¸åŒ¹é…
        trackGradient.addColorStop(1, '#1a3a5e'); // åŸå§‹è·‘é“é¢œè‰²
        
        // ç»˜åˆ¶ä¸»è¦è·‘é“
        ctx.fillStyle = trackGradient;
        ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
        
        // æ·»åŠ æ°´ä¸‹è·‘é“æ ‡è®° - åŠé€æ˜ç™½è‰²ï¼Œæ¨¡æ‹Ÿæ°´ä¸‹æ•ˆæœ
        ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
    }
    else if (isCherryBlossomScene) {
        // åˆ›å»ºæ¨±èŠ±åœºæ™¯çš„è·‘é“æ¸å˜
        const trackGradient = ctx.createLinearGradient(0, canvas.height - 30, 0, canvas.height);
        trackGradient.addColorStop(0, '#513B65'); // ä¸æ¨±èŠ±èƒŒæ™¯åº•éƒ¨é¢œè‰²ç›¸åŒ¹é…
        trackGradient.addColorStop(1, '#443A68'); // åŸå§‹æ¨±èŠ±åœºæ™¯è·‘é“é¢œè‰²
        
        // ç»˜åˆ¶ä¸»è¦è·‘é“
        ctx.fillStyle = trackGradient;
        ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
        
        // æ·»åŠ æ¨±èŠ±åœºæ™¯è·‘é“æ ‡è®° - æ·¡ç²‰è‰²æ ‡è®°
        ctx.fillStyle = "rgba(255, 220, 230, 0.4)";
    } else {
        // éæ°´ä¸‹åœºæ™¯æ­£å¸¸ç»˜åˆ¶
        // ç»˜åˆ¶ä¸»è¦çš„åœ°é¢/è½¨é“
        ctx.fillStyle = bg.groundColor;
        ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
        
        // æ·»åŠ è½¨é“æ ‡è®°çº¿ - æ™®é€šåœºæ™¯ç”¨ç™½è‰²
        ctx.fillStyle = "#FFFFFF";
    }
    
    // æ›´æ–°å’Œç»˜åˆ¶è½¨é“æ ‡è®°çº¿
    for (let i = 0; i < trackMarkings.length; i++) {
        // ç§»åŠ¨æ ‡è®°çº¿
        trackMarkings[i] -= gameSpeed;
        
        // å¦‚æœæ ‡è®°çº¿ç§»å‡ºå±å¹•ï¼Œå°†å…¶é‡æ–°æ”¾ç½®åˆ°å±å¹•å³ä¾§
        if (trackMarkings[i] < -markingWidth) {
            trackMarkings[i] = canvas.width + (trackMarkings[i] + markingWidth) % (markingWidth + markingGap);
        }
        
        // ç»˜åˆ¶æ ‡è®°çº¿ - æ ¹æ®åœºæ™¯è°ƒæ•´æ ·å¼
        if (isUnderwaterScene || isPirateShipScene || isCherryBlossomScene || isNewMap) {
            ctx.fillRect(trackMarkings[i], canvas.height - 28, markingWidth, 4);
        } else {
            ctx.fillRect(trackMarkings[i], canvas.height - 28, markingWidth, 3);
        }
    }
    
    // è½¨é“è¾¹ç¼˜é«˜å…‰æ•ˆæœ - ä½¿åœ°é¢çœ‹èµ·æ¥æ›´æœ‰æ·±åº¦
    if (isPirateShipScene) {
        ctx.fillStyle = "rgba(180, 210, 230, 0.15)";
    } 
    else if (isUnderwaterScene) {
        ctx.fillStyle = "rgba(160, 210, 230, 0.15)";
    } 
    else if (isCherryBlossomScene) {
        ctx.fillStyle = "rgba(255, 220, 230, 0.15)";
    }
    else if (isNewMap) {
        // æ–°åœ°å›¾ä½¿ç”¨äº®ç°è‰²é«˜å…‰ï¼Œä¸æ‰€æœ‰æ·±è‰²è·‘é“éƒ½æœ‰è‰¯å¥½å¯¹æ¯”
        ctx.fillStyle = "rgba(220, 220, 220, 0.2)";
    } else {
        ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
    }
    ctx.fillRect(0, canvas.height - 30, canvas.width, 2);
    
    // æµ·åº•åœºæ™¯ç‰¹æœ‰çš„æ°´æ³¢æ•ˆæœ
    if (isUnderwaterScene) {
        // æ°´æ³¢çº¹åŠ¨ç”»
        ctx.fillStyle = "rgba(160, 210, 230, 0.1)";
        ctx.beginPath();
        ctx.moveTo(0, canvas.height - 27);
        
        for (let x = 0; x < canvas.width; x += 20) {
            const y = canvas.height - 27 + Math.sin((x + frameCount * 2) * 0.05) * 2;
            ctx.lineTo(x, y);
        }
        
        ctx.lineTo(canvas.width, canvas.height - 27);
        ctx.lineTo(canvas.width, canvas.height - 24);
        ctx.lineTo(0, canvas.height - 24);
        ctx.closePath();
        ctx.fill();
        
        // å¶å°”ç”Ÿæˆæ°”æ³¡ä»åœ°é¢å‡èµ·
        if (Math.random() < 0.03) {
            const bubbleX = Math.random() * canvas.width;
            pirateElements.push({
                type: 'bubble',
                x: bubbleX,
                y: canvas.height - 10,
                size: 1 + Math.random() * 3,
                speed: 0.3 + Math.random() * 0.8,
                wobble: 0.3 + Math.random() * 0.8,
                phase: Math.random() * Math.PI * 2
            });
        }
    }
}

// æ·»åŠ ï¼šæ£€æŸ¥æ˜¯å¦éœ€è¦åˆ‡æ¢èƒŒæ™¯
function checkBackgroundChange() {
    if (currentMap !== "newMap") return; // åªåœ¨æ–°åœ°å›¾ä¸­æ‰§è¡Œ ã€è¯´æ˜ã€‘ï¼šç¡®ä¿åªåœ¨æ–°åœ°å›¾ä¸­åˆ‡æ¢èƒŒæ™¯
    
    // è®¡ç®—å½“å‰åº”è¯¥æ˜¾ç¤ºå“ªä¸ªèƒŒæ™¯
    const currentCycle = Math.floor(distance / BACKGROUND_CHANGE_DISTANCE); // ã€è¯´æ˜ã€‘ï¼šè®¡ç®—å½“å‰è·ç¦»å¯¹åº”çš„å¾ªç¯ä½ç½®
    const cyclePosition = currentCycle % (BACKGROUNDS_SEQUENCE.length + 1); // ã€è¯´æ˜ã€‘ï¼šè®¡ç®—åœ¨ä¸€ä¸ªå®Œæ•´å¾ªç¯ä¸­çš„ä½ç½®
    
    // ç¡®å®šåº”è¯¥æ˜¾ç¤ºçš„èƒŒæ™¯
    let targetBackground;
    if (cyclePosition === BACKGROUNDS_SEQUENCE.length) {
        targetBackground = 'bg5'; // æœ€åä¸€ä¸ª3000ç±³åŒºé—´ä¿æŒæ˜¾ç¤ºbg5 ã€è¯´æ˜ã€‘ï¼šç‰¹æ®Šå¤„ç†æœ€åä¸€ä¸ªåŒºé—´
    } else {
        targetBackground = BACKGROUNDS_SEQUENCE[cyclePosition]; // ã€è¯´æ˜ã€‘ï¼šæ ¹æ®å¾ªç¯ä½ç½®é€‰æ‹©å¯¹åº”èƒŒæ™¯
    }
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦å¼€å§‹æ–°çš„è¿‡æ¸¡
    if (!currentBackgroundState.isFading && 
        targetBackground !== currentBackgroundState.current && 
        Math.floor(distance / BACKGROUND_CHANGE_DISTANCE) !== currentBackgroundState.lastChangeDistance) {
        
        // å¼€å§‹æ–°çš„èƒŒæ™¯è¿‡æ¸¡
        startBackgroundTransition(targetBackground);
        
        // è®°å½•å½“å‰åˆ‡æ¢è·ç¦»
        currentBackgroundState.lastChangeDistance = Math.floor(distance / BACKGROUND_CHANGE_DISTANCE);
        
        // æ˜¾ç¤ºåˆ‡æ¢æç¤º - ä½¿ç”¨è‡ªå®šä¹‰åœºæ™¯åç§°
        const backgroundNames = {
            'bg1': 'è½æ—¥ç©¹é¡¶',
            'bg2': 'èµ›åšé»„æ˜',
            'bg3': 'æŠ•å¥”æ€’æµ·',
            'bg4': 'æ·±æµ·è¿·èˆª',
            'bg5': 'å¼‚æµ·æ´‹'
    };
    
        const sceneName = backgroundNames[targetBackground] || `åœºæ™¯${BACKGROUNDS_SEQUENCE.indexOf(targetBackground) + 1}`;
        showMilestoneNotification(sceneName, "#4682B4");
        } // ã€è¯´æ˜ã€‘ï¼šæ£€æŸ¥å½“å‰è·ç¦»ï¼Œå†³å®šæ˜¯å¦éœ€è¦åˆ‡æ¢èƒŒæ™¯
    }
// æ·»åŠ ï¼šå¼€å§‹èƒŒæ™¯è¿‡æ¸¡æ•ˆæœ
function startBackgroundTransition(nextBackground) {
    currentBackgroundState.next = nextBackground; // ã€è¯´æ˜ã€‘ï¼šè®¾ç½®ç›®æ ‡èƒŒæ™¯
    currentBackgroundState.fadeProgress = 0; // ã€è¯´æ˜ã€‘ï¼šé‡ç½®è¿‡æ¸¡è¿›åº¦
    currentBackgroundState.isFading = true; // ã€è¯´æ˜ã€‘ï¼šæ ‡è®°æ­£åœ¨è¿‡æ¸¡ä¸­
} // ã€è¯´æ˜ã€‘ï¼šåˆå§‹åŒ–èƒŒæ™¯è¿‡æ¸¡çŠ¶æ€

// æ·»åŠ ï¼šæ›´æ–°èƒŒæ™¯è¿‡æ¸¡æ•ˆæœ
function updateBackgroundTransition() {
    if (!currentBackgroundState.isFading) return; // ã€è¯´æ˜ã€‘ï¼šå¦‚æœæ²¡æœ‰æ­£åœ¨è¿›è¡Œçš„è¿‡æ¸¡ï¼Œç›´æ¥è¿”å›
    
    // æ›´æ–°è¿‡æ¸¡è¿›åº¦
    currentBackgroundState.fadeProgress += 1 / currentBackgroundState.fadeDuration; // ã€è¯´æ˜ã€‘ï¼šå¢åŠ è¿‡æ¸¡è¿›åº¦
    
    // æ£€æŸ¥è¿‡æ¸¡æ˜¯å¦å®Œæˆ
    if (currentBackgroundState.fadeProgress >= 1) {
        // è¿‡æ¸¡å®Œæˆï¼Œæ›´æ–°å½“å‰èƒŒæ™¯
        currentBackgroundState.current = currentBackgroundState.next; // ã€è¯´æ˜ã€‘ï¼šæ›´æ–°å½“å‰èƒŒæ™¯
        currentBackgroundState.next = null; // ã€è¯´æ˜ã€‘ï¼šæ¸…é™¤ä¸‹ä¸€ä¸ªèƒŒæ™¯
        currentBackgroundState.isFading = false; // ã€è¯´æ˜ã€‘ï¼šæ ‡è®°è¿‡æ¸¡ç»“æŸ
        currentBackgroundState.fadeProgress = 0; // ã€è¯´æ˜ã€‘ï¼šé‡ç½®è¿‡æ¸¡è¿›åº¦
    }
} // ã€è¯´æ˜ã€‘ï¼šå¤„ç†èƒŒæ™¯è¿‡æ¸¡åŠ¨ç”»çš„è¿›åº¦æ›´æ–°

// æ·»åŠ ç¼ºå¤±çš„drawSkyå‡½æ•°
function drawSky() {
    // Use the current background stage colors
    const bg = bgStages[currentBgStage];
    
    // æ£€æŸ¥å½“å‰åœ°å›¾
    if (currentMap === "newMap") {  // å¦‚æœæ˜¯æ–°åœ°å›¾
        // æ£€æŸ¥å¹¶æ›´æ–°èƒŒæ™¯åˆ‡æ¢
        checkBackgroundChange();
        updateBackgroundTransition();
        
        // æ ¹æ®å½“å‰çŠ¶æ€ç»˜åˆ¶èƒŒæ™¯
        if (currentBackgroundState.isFading && currentBackgroundState.next) {
            // ç»˜åˆ¶è¿‡æ¸¡æ•ˆæœ
            const currentBgImage = newMapBackgrounds[currentBackgroundState.current].image;
            const nextBgImage = newMapBackgrounds[currentBackgroundState.next].image;
            
            // ç¡®ä¿å›¾ç‰‡å·²åŠ è½½
            if (currentBgImage.complete && nextBgImage.complete) {
                // å…ˆç»˜åˆ¶å½“å‰èƒŒæ™¯
                ctx.globalAlpha = 1;
                ctx.drawImage(currentBgImage, 0, 0, canvas.width, canvas.height);
                
                // å†ç»˜åˆ¶ä¸‹ä¸€ä¸ªèƒŒæ™¯ï¼ˆå¸¦é€æ˜åº¦ï¼‰
                ctx.globalAlpha = currentBackgroundState.fadeProgress;
                ctx.drawImage(nextBgImage, 0, 0, canvas.width, canvas.height);
                
                // é‡ç½®é€æ˜åº¦
                ctx.globalAlpha = 1;
            } else {
                // å¤‡é€‰æ–¹æ¡ˆï¼šä½¿ç”¨æ¸å˜èƒŒæ™¯
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#0F0618');
                gradient.addColorStop(0.4, '#160D36');
                gradient.addColorStop(0.7, '#1E0A40');
                gradient.addColorStop(1, '#2A0A44');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        } else {
            // æ­£å¸¸ç»˜åˆ¶å½“å‰èƒŒæ™¯
            const currentBgImage = newMapBackgrounds[currentBackgroundState.current].image;
            if (currentBgImage.complete) {
                ctx.drawImage(currentBgImage, 0, 0, canvas.width, canvas.height);
            } else {
                // å¤‡é€‰æ–¹æ¡ˆï¼šä½¿ç”¨æ¸å˜èƒŒæ™¯
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#0F0618');
                gradient.addColorStop(0.4, '#160D36');
                gradient.addColorStop(0.7, '#1E0A40');
                gradient.addColorStop(1, '#2A0A44');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }
        
        // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
        for (let star of stars) {
            const twinkle = Math.sin(frameCount * 0.05 + star.twinkle) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + twinkle * 0.7})`;
            ctx.fillRect(star.x, star.y, star.size, star.size);
        }
        
        // ç»˜åˆ¶UFO
        drawUFO();
        return;  // æå‰è¿”å›ï¼Œä¸æ‰§è¡Œåé¢çš„åœºæ™¯ç»˜åˆ¶ä»£ç 
    }
    
    // ä»¥ä¸‹æ˜¯åŸæœ‰ä»£ç ï¼Œä¿æŒä¸å˜
    // Create a dark gradient background
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, bg.color1);
    gradient.addColorStop(1, bg.color2);
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw stars in the background
    for (let star of stars) {
        // Make stars twinkle
        const twinkle = Math.sin(frameCount * 0.05 + star.twinkle) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + twinkle * 0.7})`;
        ctx.fillRect(star.x, star.y, star.size, star.size);
    }
    
    // å¤„ç†åœºæ™¯è¿‡æ¸¡
    if (sceneFade.active) {
        // æ›´æ–°è¿‡æ¸¡è¿›åº¦
        sceneFade.progress++;
        
        // ç»˜åˆ¶æ—§åœºæ™¯å’Œæ–°åœºæ™¯ï¼Œä½¿ç”¨é€æ˜åº¦æ¥åˆ›å»ºè¿‡æ¸¡æ•ˆæœ
        const opacity = sceneFade.progress / sceneFade.duration;
        
        // ç»˜åˆ¶å‰ä¸€ä¸ªåœºæ™¯ï¼ˆæ·¡å‡ºï¼‰
        if (sceneFade.fromScene) {
            ctx.globalAlpha = 1 - opacity;
            for (const element of bgElements) {
                if (element.name === sceneFade.fromScene) {
                    element.draw();
                    break;
                }
            }
        }
        
        // ç»˜åˆ¶æ–°åœºæ™¯ï¼ˆæ·¡å…¥ï¼‰
        ctx.globalAlpha = opacity;
        for (const element of bgElements) {
            if (element.name === sceneFade.toScene) {
                element.draw();
                break;
            }
        }
        
        // é‡ç½®é€æ˜åº¦
        ctx.globalAlpha = 1;
        
        // å½“è¿‡æ¸¡å®Œæˆæ—¶
        if (sceneFade.progress >= sceneFade.duration) {
            sceneFade.active = false;
        }
    } 
    // æ­£å¸¸ç»˜åˆ¶å½“å‰åœºæ™¯
    else if (activeSceneName) {
        for (const element of bgElements) {
            if (element.name === activeSceneName) {
                element.draw();
                break;
            }
        }
    }
    // ä¿®æ”¹è¿™é‡Œ - å¦‚æœåœ¨åˆå§‹å¤œç©ºåœºæ™¯ï¼Œç»˜åˆ¶èƒŒæ™¯å›¾ç‰‡å’ŒUFO
    else if (!activeSceneName) {
        // ä½¿ç”¨åŸæ¥çš„æ¸å˜èƒŒæ™¯
        const bg = bgStages[currentBgStage];
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, bg.color1);
        gradient.addColorStop(1, bg.color2);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
        for (let star of stars) {
            const twinkle = Math.sin(frameCount * 0.05 + star.twinkle) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + twinkle * 0.7})`;
            ctx.fillRect(star.x, star.y, star.size, star.size);
        }
        
        // ç»˜åˆ¶UFO
        drawUFO();
    }
}
        
        // ç»˜åˆ¶éšœç¢ç‰©å‡½æ•°
        function drawObstacles() {
            for (const obstacle of obstacles) {
                const type = obstacle.type;
                
                switch (type) {
                    case obstacleTypes.HORSE:
                        // Draw horse obstacle
                        // Horse base
                        ctx.fillStyle = palette.obstacleColors.horse;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        
                        // Horse padding on top
                        ctx.fillStyle = palette.obstacleColors.horsePadding;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 10);
                        
                        // Horse legs
                        ctx.fillStyle = palette.obstacleColors.horseLeg;
                        ctx.fillRect(obstacle.x + 10, obstacle.y + obstacle.height - 25, 8, 25);
                        ctx.fillRect(obstacle.x + obstacle.width - 18, obstacle.y + obstacle.height - 25, 8, 25);
                        
                        // Horse handles on each side
                        ctx.fillStyle = palette.obstacleColors.horseHandle;
                        ctx.fillRect(obstacle.x - 5, obstacle.y + 5, 5, 20);
                        ctx.fillRect(obstacle.x + obstacle.width, obstacle.y + 5, 5, 20);
                        break;
                    
                    case obstacleTypes.POOL:
                        // Draw pool obstacle
                        ctx.fillStyle = palette.obstacleColors.pool;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        
                        // Pool edge
                        ctx.fillStyle = palette.obstacleColors.poolEdge;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 3);
                        ctx.fillRect(obstacle.x, obstacle.y + obstacle.height - 3, obstacle.width, 3);
                        
                        // Pool waves
                        ctx.fillStyle = palette.obstacleColors.poolWave;
                        for (let i = 0; i < 5; i++) {
                            const waveX = obstacle.x + 10 + i * 20;
                            const waveHeight = 3 + Math.sin(frameCount * 0.1 + i) * 2;
                            ctx.fillRect(waveX, obstacle.y + 5, 10, waveHeight);
                        }
                        break;
                    
                    case obstacleTypes.HURDLE:
                        // Draw hurdle obstacle
                        // Hurdle supporting legs
                        ctx.fillStyle = palette.obstacleColors.hurdleSupport;
                        ctx.fillRect(obstacle.x, obstacle.y + 15, 5, obstacle.height - 15);
                        ctx.fillRect(obstacle.x + obstacle.width - 5, obstacle.y + 15, 5, obstacle.height - 15);
                        
                        // Main hurdle top
                        ctx.fillStyle = palette.obstacleColors.hurdleTop;
                        ctx.fillRect(obstacle.x - 2, obstacle.y, obstacle.width + 4, 15);
                        
                        // Hurdle stripes
                        ctx.fillStyle = palette.obstacleColors.hurdleStripe;
                        for (let i = 0; i < 3; i++) {
                            ctx.fillRect(obstacle.x + 5 + i * ((obstacle.width - 10) / 2), obstacle.y + 5, 5, 5);
                        }
                        break;
                    
                    case obstacleTypes.RAIL:
                        // Draw rail obstacle
                        // Rail base
                        ctx.fillStyle = palette.obstacleColors.rail;
                        ctx.fillRect(obstacle.x, obstacle.y + obstacle.height - 15, obstacle.width, 15);
                        
                        // Rail posts
                        ctx.fillStyle = palette.obstacleColors.railPost;
                        for (let i = 0; i < 3; i++) {
                            const postX = obstacle.x + i * (obstacle.width / 2);
                            ctx.fillRect(postX, obstacle.y, 6, obstacle.height);
                        }
                        
                        // Rail top
                        ctx.fillStyle = palette.obstacleColors.railTop;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 5);
                        
                        // Rail lines
                        ctx.fillStyle = palette.obstacleColors.railLine;
                        ctx.fillRect(obstacle.x, obstacle.y + 15, obstacle.width, 2);
                        break;
                    
                    case obstacleTypes.BALANCE_BEAM:
                        // Draw balance beam
                        // Beam base
                        ctx.fillStyle = palette.obstacleColors.beam;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 10);
                        
                        // Beam supports
                        ctx.fillStyle = palette.obstacleColors.beamSupport;
                        ctx.fillRect(obstacle.x + 20, obstacle.y + 10, 15, obstacle.height - 10);
                        ctx.fillRect(obstacle.x + obstacle.width - 35, obstacle.y + 10, 15, obstacle.height - 10);
                        
                        // Beam padding
                        ctx.fillStyle = palette.obstacleColors.beamPad;
                        for (let i = 0; i < 3; i++) {
                            ctx.fillRect(obstacle.x + 10 + i * 40, obstacle.y - 3, 20, 3);
                        }
                        break;
                    
                    case obstacleTypes.POMMEL_HORSE:
                        // Draw pommel horse
                        // Horse body
                        ctx.fillStyle = palette.obstacleColors.pommelHorse;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height - 10);
                        
                        // Horse legs
                        ctx.fillStyle = palette.obstacleColors.horseLeg;
                        ctx.fillRect(obstacle.x + 10, obstacle.y + obstacle.height - 10, 10, 10);
                        ctx.fillRect(obstacle.x + obstacle.width - 20, obstacle.y + obstacle.height - 10, 10, 10);
                        
                        // Pommel handles
                        ctx.fillStyle = palette.obstacleColors.pommelHandles;
                        ctx.fillRect(obstacle.x + 15, obstacle.y - 10, 8, 15);
                        ctx.fillRect(obstacle.x + obstacle.width - 23, obstacle.y - 10, 8, 15);
                        break;
                    
                    case obstacleTypes.DIVING_BOARD:
                        // Draw diving board
                        // Board
                        ctx.fillStyle = palette.obstacleColors.divingBoard;
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 8);
                        
                        // Spring support
                        ctx.fillStyle = palette.obstacleColors.divingSpring;
                        ctx.fillRect(obstacle.x + 10, obstacle.y + 8, 30, obstacle.height - 8);
                        break;
                    
                    case obstacleTypes.RINGS:
                        // Draw rings
                        // Top bar
                        ctx.fillStyle = palette.obstacleColors.bar;
                        ctx.fillRect(obstacle.x - 20, obstacle.y, obstacle.width + 40, 5);
                        
                        // Ring chains
                        ctx.strokeStyle = '#CCCCCC';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x, obstacle.y + 5);
                        ctx.lineTo(obstacle.x, obstacle.y + 25);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + obstacle.width, obstacle.y + 5);
                        ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + 25);
                        ctx.stroke();
                        
                        // Rings
                        ctx.strokeStyle = palette.obstacleColors.ring;
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.arc(obstacle.x, obstacle.y + 35, 10, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.arc(obstacle.x + obstacle.width, obstacle.y + 35, 10, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    
                    case obstacleTypes.BARREL:
                        // ç»˜åˆ¶æœ¨æ¡¶
                        ctx.fillStyle = '#8B4513'; // æœ¨æ¡¶é¢œè‰²
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        
                        // æœ¨æ¡¶ç¯
                        ctx.strokeStyle = '#5D4037';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(obstacle.x, obstacle.y + 5, obstacle.width, 3);
                        ctx.strokeRect(obstacle.x, obstacle.y + obstacle.height - 8, obstacle.width, 3);
                        break;
                    
                    case obstacleTypes.BIRD:
                        // æ›´æ–°é¸Ÿçš„ç¿…è†€ä½ç½®
                        obstacle.wingPosition = (obstacle.wingPosition || 0) + 0.2;
                        const wingOffset = Math.sin(obstacle.wingPosition) * 5;
                        
                        // ç»˜åˆ¶é¸Ÿçš„èº«ä½“
                        ctx.fillStyle = '#4D7ABF'; // é¸Ÿçš„é¢œè‰²
                        ctx.beginPath();
                        ctx.ellipse(
                            obstacle.x + obstacle.width/2, 
                            obstacle.y + obstacle.height/2, 
                            obstacle.width/2, 
                            obstacle.height/2, 
                            0, 0, Math.PI * 2
                        );
                        ctx.fill();
                        
                        // ç»˜åˆ¶ç¿…è†€
                        ctx.fillStyle = '#3A5D9C';
                        
                        // å·¦ç¿…è†€
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + 5, obstacle.y + obstacle.height/2);
                        ctx.lineTo(obstacle.x - 10, obstacle.y + obstacle.height/2 - wingOffset);
                        ctx.lineTo(obstacle.x - 5, obstacle.y + obstacle.height/2 + 5);
                        ctx.closePath();
                        ctx.fill();
                        
                        // å³ç¿…è†€
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + obstacle.width - 5, obstacle.y + obstacle.height/2);
                        ctx.lineTo(obstacle.x + obstacle.width + 10, obstacle.y + obstacle.height/2 - wingOffset);
                        ctx.lineTo(obstacle.x + obstacle.width + 5, obstacle.y + obstacle.height/2 + 5);
                        ctx.closePath();
                        ctx.fill();
                        
                        // ç»˜åˆ¶çœ¼ç›
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(obstacle.x + obstacle.width * 0.7, obstacle.y + obstacle.height * 0.4, 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.arc(obstacle.x + obstacle.width * 0.7, obstacle.y + obstacle.height * 0.4, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ç»˜åˆ¶å˜´å·´
                        ctx.fillStyle = '#FF9900';
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + obstacle.width * 0.8, obstacle.y + obstacle.height * 0.5);
                        ctx.lineTo(obstacle.x + obstacle.width + 5, obstacle.y + obstacle.height * 0.6);
                        ctx.lineTo(obstacle.x + obstacle.width * 0.8, obstacle.y + obstacle.height * 0.7);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    
                    case obstacleTypes.CRATE:
                        // ç»˜åˆ¶æœ¨ç®±
                        ctx.fillStyle = '#A86032'; // æœ¨ç®±é¢œè‰²
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        
                        // æœ¨ç®±è¾¹ç¼˜
                        ctx.strokeStyle = '#5D4037';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        
                        // æœ¨ç®±çº¹ç†
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x, obstacle.y + obstacle.height/2);
                        ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height/2);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + obstacle.width/2, obstacle.y);
                        ctx.lineTo(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height);
                        ctx.stroke();
                        break;
                    
                    case obstacleTypes.CACTUS:
                        // ä»™äººæŒåŸºæœ¬éƒ¨åˆ†
                        ctx.fillStyle = '#2E8B57'; // ä»™äººæŒç»¿è‰²
                        ctx.fillRect(obstacle.x + 5, obstacle.y, obstacle.width - 10, obstacle.height);
                        
                        // ä»™äººæŒåˆ†æ”¯
                        ctx.fillRect(obstacle.x, obstacle.y + 10, obstacle.width/3, obstacle.height/3);
                        ctx.fillRect(obstacle.x + obstacle.width - obstacle.width/3, obstacle.y + 20, obstacle.width/3, obstacle.height/3);
                        
                        // ä»™äººæŒåˆº
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 6; i++) {
                            const y = obstacle.y + 5 + i * (obstacle.height/6);
                            
                            // å·¦ä¾§åˆº
                            ctx.beginPath();
                            ctx.moveTo(obstacle.x + 5, y);
                            ctx.lineTo(obstacle.x, y - 2);
                            ctx.stroke();
                            
                            // å³ä¾§åˆº
                            ctx.beginPath();
                            ctx.moveTo(obstacle.x + obstacle.width - 5, y);
                            ctx.lineTo(obstacle.x + obstacle.width, y - 2);
                            ctx.stroke();
                        }
                        break;
                    
                    case obstacleTypes.SNAKE:
                        // è›‡çš„èº«ä½“ - ä½¿ç”¨æ­£å¼¦æ³¢æ¥åˆ›å»ºè •åŠ¨æ•ˆæœ
                        const snakeLength = obstacle.width;
                        const amplitude = 5; // è •åŠ¨å¹…åº¦
                        const frequency = 0.2; // é¢‘ç‡
                        
                        ctx.fillStyle = '#6B8E23'; // æ©„æ¦„ç»¿è‰²è°ƒ
                        
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x, obstacle.y + obstacle.height/2);
                        
                        // ç»˜åˆ¶è •åŠ¨çš„è›‡
                        for (let i = 0; i <= snakeLength; i += 5) {
                            const x = obstacle.x + i;
                            const y = obstacle.y + obstacle.height/2 + 
                                     Math.sin((frameCount * 0.1) + (i * frequency)) * amplitude;
                            ctx.lineTo(x, y);
                        }
                        
                        // å®Œæˆè›‡çš„è½®å»“
                        for (let i = snakeLength; i >= 0; i -= 5) {
                            const x = obstacle.x + i;
                            const y = obstacle.y + obstacle.height/2 + 
                                     Math.sin((frameCount * 0.1) + (i * frequency)) * amplitude + 5;
                            ctx.lineTo(x, y);
                        }
                        
                        ctx.closePath();
                        ctx.fill();
                        
                        // è›‡çš„å¤´éƒ¨
                        ctx.fillStyle = '#556B2F'; // æ·±æ©„æ¦„ç»¿
                        const headX = obstacle.x + snakeLength;
                        const headY = obstacle.y + obstacle.height/2 + 
                                     Math.sin((frameCount * 0.1) + (snakeLength * frequency)) * amplitude;
                        
                        ctx.beginPath();
                        ctx.arc(headX, headY, 6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // è›‡çš„çœ¼ç›
                        ctx.fillStyle = '#FF0000'; // çº¢è‰²çœ¼ç›
                        ctx.beginPath();
                        ctx.arc(headX + 3, headY - 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    
                    case obstacleTypes.PARALLEL_BARS:
                        // ç»˜åˆ¶å¹³è¡Œæ 
                        // åº•åº§æ”¯æ’‘
                        ctx.fillStyle = '#5D4037'; // æ·±æ£•è‰²
                        ctx.fillRect(obstacle.x + 10, obstacle.y + 35, 10, obstacle.height - 35);
                        ctx.fillRect(obstacle.x + obstacle.width - 20, obstacle.y + 35, 10, obstacle.height - 35);
                        
                        // æ¨ªæ 
                        ctx.fillStyle = '#8D6E63'; // æµ…æ£•è‰²
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 5);
                        ctx.fillRect(obstacle.x, obstacle.y + 20, obstacle.width, 5);
                        break;
                    
                    case obstacleTypes.WATER_JUMP:
                        // ç»˜åˆ¶æ°´å‘è·³
                        // æ°´å‘
                        ctx.fillStyle = '#4FC3F7'; // æµ…è“è‰²
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        
                        // æ°´æ³¢æ•ˆæœ
                        ctx.fillStyle = '#81D4FA'; // æ›´æµ…çš„è“è‰²
                        for (let i = 0; i < 4; i++) {
                            const waveX = obstacle.x + 10 + i * 20;
                            const waveY = obstacle.y + Math.sin(frameCount * 0.1 + i * 0.5) * 3;
                            ctx.fillRect(waveX, waveY, 10, 2);
                        }
                        
                        // è¾¹ç¼˜
                        ctx.strokeStyle = '#0288D1'; // æ·±è“è‰²
                        ctx.lineWidth = 2;
                        ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                        break;
                    
                    case obstacleTypes.HIGH_JUMP:
                        // ç»˜åˆ¶è·³é«˜æ†
                        // æ”¯æŸ±
                        ctx.fillStyle = '#455A64'; // è“ç°è‰²
                        ctx.fillRect(obstacle.x, obstacle.y, 5, obstacle.height);
                        ctx.fillRect(obstacle.x + obstacle.width - 5, obstacle.y, 5, obstacle.height);
                        
                        // æ¨ªæ†
                        ctx.fillStyle = '#FFFFFF'; // ç™½è‰²
                        ctx.fillRect(obstacle.x - 5, obstacle.y, obstacle.width + 10, 3);
                        break;
                    
                    case obstacleTypes.UNEVEN_BARS:
                        // ç»˜åˆ¶é«˜ä½æ 
                        // æ”¯æŸ±
                        ctx.fillStyle = '#795548'; // æ£•è‰²
                        ctx.fillRect(obstacle.x + 5, obstacle.y + 20, 10, obstacle.height - 20);
                        ctx.fillRect(obstacle.x + obstacle.width - 15, obstacle.y + 35, 10, obstacle.height - 35);
                        
                        // æ¨ªæ 
                        ctx.fillStyle = '#FCB900'; // é‡‘è‰²
                        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, 5); // é«˜æ 
                        ctx.fillRect(obstacle.x, obstacle.y + 25, obstacle.width - 20, 5); // ä½æ 
                        break;
                }
            }
        }

        // ç»˜åˆ¶é‡‘ç‰Œå’ŒèŒ¶æ¯
        function drawMedals() {
            for (const medal of medals) {
                if (medal.type === collectibleTypes.GOLD) {
                    // é‡‘ç‰Œç»˜åˆ¶
                    ctx.beginPath();
                    ctx.arc(medal.x + medal.width / 2, medal.y + medal.height / 2, medal.width / 2, 0, Math.PI * 2);
                    ctx.fillStyle = palette.gold;
                    ctx.fill();
                    
                    // é‡‘ç‰Œä¸Šçš„å›¾æ¡ˆ
                    ctx.beginPath();
                    ctx.arc(medal.x + medal.width / 2, medal.y + medal.height / 2, medal.width / 3, 0, Math.PI * 2);
                    ctx.fillStyle = palette.goldShine;
                    ctx.fill();
                    
                    // é‡‘ç‰Œçš„å…‰æ™• - ä½¿ç”¨æ­£å¼¦æ³¢åˆ›å»ºå‘¼å¸å…‰æ•ˆ
                    const glowSize = 3 + Math.sin(frameCount * 0.1) * 2;
                    ctx.beginPath();
                    ctx.arc(medal.x + medal.width / 2, medal.y + medal.height / 2, medal.width / 2 + glowSize, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                    ctx.fill();
                    
                    // é‡‘ç‰Œä¸å¸¦
                    ctx.beginPath();
                    ctx.moveTo(medal.x + medal.width / 2, medal.y);
                    ctx.lineTo(medal.x + medal.width / 2 - 3, medal.y - 5);
                    ctx.lineTo(medal.x + medal.width / 2 + 3, medal.y - 5);
                    ctx.closePath();
                    ctx.fillStyle = palette.goldRibbon;
                    ctx.fill();
                    
                } else if (medal.type === collectibleTypes.TEA) {
                    // æ·»åŠ å…‰æ™•æ•ˆæœ
                    const glowSize = 20 + Math.sin(frameCount * 0.1) * 5; // è„‰åŠ¨æ•ˆæœ
                    const gradient = ctx.createRadialGradient(
                        medal.x + medalSize/2, medal.y + medalSize/2, 0,
                        medal.x + medalSize/2, medal.y + medalSize/2, glowSize
                    );
                    gradient.addColorStop(0, 'rgba(102, 255, 102, 0.3)');
                    gradient.addColorStop(1, 'rgba(102, 255, 102, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(medal.x - glowSize/2, medal.y - glowSize/2, 
                                medalSize + glowSize, medalSize + glowSize);

                    // æ·»åŠ æ¼‚æµ®æ•ˆæœ
                    const floatOffset = Math.sin(frameCount * 0.05) * 3;
                    
                    // ç»˜åˆ¶èŒ¶æ¯
                    ctx.fillStyle = palette.teaCup;
                    ctx.fillRect(medal.x, medal.y + floatOffset, medalSize, medalSize * 0.7);
                    
                    // ç»˜åˆ¶èŒ¶æ°´
                    ctx.fillStyle = palette.teaColor;
                    ctx.fillRect(medal.x + 2, medal.y + floatOffset + 2, medalSize - 4, medalSize * 0.4);
                    
                    // æ·»åŠ é—ªçƒæ˜Ÿæ˜Ÿæ•ˆæœ
                    const starAngle = frameCount * 0.1;
                    const starRadius = 2;
                    ctx.fillStyle = '#FFFFFF';
                    for (let i = 0; i < 4; i++) {
                        const angle = starAngle + (Math.PI * 2 * i / 4);
                        const starX = medal.x + medalSize/2 + Math.cos(angle) * 15;
                        const starY = medal.y + medalSize/2 + Math.sin(angle) * 15 + floatOffset;
                        ctx.beginPath();
                        ctx.arc(starX, starY, starRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // ä¸ºæ”¶é›†å“æ·»åŠ æµ®åŠ¨æ•ˆæœ
                medal.y += Math.sin(frameCount * 0.1) * 0.3;
            }
        }
        
        // Background elements functions
        function createMountains() {
            mountains = [];
            const mountainCount = 5;
            
            for (let i = 0; i < mountainCount; i++) {
                const mountainHeight = 80 + Math.random() * 100;
                mountains.push({
                    x: (i * canvas.width / mountainCount) + Math.random() * 50,
                    height: mountainHeight,
                    width: 100 + Math.random() * 150
                });
            }
        }
        
        function drawMountains() {
            for (const mountain of mountains) {
                // Move mountain with background parallax
                mountain.x -= gameSpeed * 0.2; // Slower than foreground for parallax effect
                
                if (mountain.x + mountain.width < 0) {
                    mountain.x = canvas.width;
                }
                
                // Draw mountain
                ctx.fillStyle = '#1A2C50'; // Dark blue for distant mountains
                ctx.beginPath();
                ctx.moveTo(mountain.x, canvas.height - 30); // Base at ground
                ctx.lineTo(mountain.x + mountain.width / 2, canvas.height - 30 - mountain.height);
                ctx.lineTo(mountain.x + mountain.width, canvas.height - 30);
                ctx.closePath();
                ctx.fill();
                
                // Snow caps
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.moveTo(mountain.x + mountain.width * 0.4, canvas.height - 30 - mountain.height * 0.85);
                ctx.lineTo(mountain.x + mountain.width / 2, canvas.height - 30 - mountain.height);
                ctx.lineTo(mountain.x + mountain.width * 0.6, canvas.height - 30 - mountain.height * 0.85);
                ctx.closePath();
                ctx.fill();
            }
        }

        // å®Œå…¨æ›¿æ¢åŸæœ‰çš„createPirateSceneå‡½æ•°
        function createPirateScene() {
            pirateElements = [];
            
            // æ·»åŠ æ·±æµ·å…‰æŸ - å¢å¼ºæ°›å›´æ„Ÿ
            for (let i = 0; i < 8; i++) {
                pirateElements.push({
                    type: 'oceanRay',
                    x: Math.random() * canvas.width,
                    y: 0,
                    width: 80 + Math.random() * 100,
                    height: canvas.height,
                    opacity: 0.05 + Math.random() * 0.08
                });
            }
            
            // æ·»åŠ æµ·è‰å’ŒçŠç‘š
            for (let i = 0; i < 10; i++) {
                pirateElements.push({
                    type: 'seaweed',
                    x: i * (canvas.width / 10) + Math.random() * 20 - 10,
                    y: canvas.height - 30,
                    height: 40 + Math.random() * 50,
                    width: 15 + Math.random() * 10,
                    segments: 3 + Math.floor(Math.random() * 3),
                    swaySpeed: 0.01 + Math.random() * 0.02,
                    swayAmount: 3 + Math.random() * 8,
                    phase: Math.random() * Math.PI * 2,
                    color: Math.random() > 0.7 ? '#5d936a' : '#3a7e68'
                });
            }
            
            // æ·»åŠ æ°”æ³¡
            for (let i = 0; i < 25; i++) {
                pirateElements.push({
                    type: 'bubble',
                    x: Math.random() * canvas.width,
                    y: canvas.height - Math.random() * 50,
                    size: 2 + Math.random() * 7,
                    speed: 0.5 + Math.random() * 1.5,
                    wobble: 0.5 + Math.random() * 1,
                    phase: Math.random() * Math.PI * 2
                });
            }
            
            // æ·»åŠ é±¼ç¾¤
            for (let i = 0; i < 3; i++) {
                const fishCount = 3 + Math.floor(Math.random() * 5);
                const direction = Math.random() > 0.5 ? 1 : -1;
                
                pirateElements.push({
                    type: 'fishSchool',
                    x: direction > 0 ? -50 : canvas.width + 50,
                    y: 100 + Math.random() * (canvas.height - 200),
                    direction: direction,
                    speed: 0.3 + Math.random() * 0.8,
                    fish: Array.from({length: fishCount}, () => ({
                        offsetX: (Math.random() - 0.5) * 60,
                        offsetY: (Math.random() - 0.5) * 30,
                        size: 8 + Math.random() * 7,
                        tailPhase: Math.random() * Math.PI * 2
                    }))
                });
            }
            
            // æ·»åŠ ä¸»æ½œè‰‡
            pirateElements.push({
                type: 'submarine',
                x: canvas.width * 0.3,
                y: canvas.height - 70,
                width: 180,
                height: 70,
                bobAmount: 2,
                bobSpeed: 0.01,
                windows: Array.from({length: 4}, (_, i) => ({
                    x: canvas.width * 0.3 + 45 + i * 25,
                    y: canvas.height - 70 + 25,
                    radius: 7,
                    glow: 0.8 + Math.random() * 0.2
                }))
            });
            
            // æ·»åŠ å°æ½œè‰‡
            pirateElements.push({
                type: 'smallSubmarine',
                x: canvas.width * 0.7,
                y: canvas.height - 55,
                width: 90,
                height: 40,
                bobAmount: 1.5,
                bobSpeed: 0.015
            });
            
            // æ”¾ç½®è½»é›¾å±‚æ¬¡
            for (let i = 0; i < 4; i++) {
                pirateElements.push({
                    type: 'mist',
                    y: canvas.height - 30 - i * 70,
                    opacity: 0.04 + i * 0.02,
                    speed: 0.1 + i * 0.05
                });
            }
        }

        // å®Œå…¨æ›¿æ¢åŸæœ‰çš„drawPirateSceneå‡½æ•°
        function drawPirateScene() {
            // ç»˜åˆ¶æµ·åº•æ¸å˜èƒŒæ™¯
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#071526');  // æ·±è“è‰²é¡¶éƒ¨
            skyGradient.addColorStop(0.4, '#0c2440'); // ä¸­æ·±è“
            skyGradient.addColorStop(0.7, '#0e3757'); // ä¸­è“ç»¿
            skyGradient.addColorStop(1, '#0d4a6e');   // åº•éƒ¨æ›´äº®è“ç»¿
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶å…‰æŸ - åˆ›é€ æ·±æµ·ç¥ç§˜æ°›å›´
            for (const element of pirateElements) {
                if (element.type === 'oceanRay') {
                    const gradient = ctx.createLinearGradient(
                        element.x, 0, 
                        element.x, canvas.height
                    );
                    gradient.addColorStop(0, `rgba(120, 180, 210, ${element.opacity})`);
                    gradient.addColorStop(1, 'rgba(120, 180, 210, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(element.x, 0);
                    ctx.lineTo(element.x - element.width/2, canvas.height);
                    ctx.lineTo(element.x + element.width/2, canvas.height);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // ç»˜åˆ¶æµ·è‰
            for (const element of pirateElements) {
                if (element.type === 'seaweed') {
                    // æ‘‡æ‘†åŠ¨ç”»
                    element.phase += element.swaySpeed;
                    const sway = Math.sin(element.phase) * element.swayAmount;
                    
                    // ç»˜åˆ¶å¼¯æ›²çš„æµ·è‰
                    ctx.fillStyle = element.color;
                    ctx.beginPath();
                    ctx.moveTo(element.x, element.y);
                    
                    // ç”¨è´å¡å°”æ›²çº¿åˆ›å»ºè‡ªç„¶å¼¯æ›²
                    ctx.bezierCurveTo(
                        element.x + sway, element.y - element.height * 0.4,
                        element.x + sway * 1.5, element.y - element.height * 0.7,
                        element.x + sway * 0.8, element.y - element.height
                    );
                    
                    ctx.bezierCurveTo(
                        element.x + sway * 1.2, element.y - element.height * 0.7,
                        element.x + sway * 0.6, element.y - element.height * 0.4,
                        element.x + element.width, element.y
                    );
                    
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            // ç»˜åˆ¶æ°”æ³¡
            for (const element of pirateElements) {
                if (element.type === 'bubble') {
                    // æ›´æ–°æ°”æ³¡ä½ç½®
                    element.y -= element.speed;
                    element.x += Math.sin(element.phase) * element.wobble * 0.2;
                    element.phase += 0.03;
                    
                    // é‡ç½®ç¦»å¼€å±å¹•çš„æ°”æ³¡
                    if (element.y < 0) {
                        element.y = canvas.height;
                        element.x = Math.random() * canvas.width;
                    }
                    
                    // ç»˜åˆ¶æ°”æ³¡
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 0.8;
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.size, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // æ°”æ³¡å†…éƒ¨æ¸å˜
                    const gradient = ctx.createRadialGradient(
                        element.x - element.size/3, element.y - element.size/3, 0,
                        element.x, element.y, element.size
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // æ°”æ³¡é«˜å…‰ç‚¹
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(element.x - element.size/3, element.y - element.size/3, element.size/6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // ç»˜åˆ¶é±¼ç¾¤
            for (const element of pirateElements) {
                if (element.type === 'fishSchool') {
                    // æ›´æ–°é±¼ç¾¤ä½ç½®
                    element.x += element.speed * element.direction;
                    
                    // é‡ç½®ç¦»å¼€å±å¹•çš„é±¼ç¾¤
                    if ((element.direction > 0 && element.x > canvas.width + 100) || 
                        (element.direction < 0 && element.x < -100)) {
                        element.x = element.direction > 0 ? -100 : canvas.width + 100;
                        element.y = 100 + Math.random() * (canvas.height - 200);
                    }
                    
                    // ç»˜åˆ¶æ¯æ¡é±¼
                    for (const fish of element.fish) {
                        // æ›´æ–°é±¼å°¾æ‘†åŠ¨
                        fish.tailPhase += 0.1;
                        const tailWag = Math.sin(fish.tailPhase) * fish.size/2;
                        
                        const fishX = element.x + fish.offsetX;
                        const fishY = element.y + fish.offsetY;
                        
                        // é±¼èº«ä½“
                        ctx.fillStyle = 'rgba(150, 180, 200, 0.8)';
                        ctx.beginPath();
                        ctx.ellipse(fishX, fishY, fish.size, fish.size/2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // é±¼å°¾
                        ctx.beginPath();
                        if (element.direction > 0) {
                            ctx.moveTo(fishX - fish.size, fishY - fish.size/4);
                            ctx.lineTo(fishX - fish.size*1.5, fishY + tailWag);
                            ctx.lineTo(fishX - fish.size, fishY + fish.size/4);
                        } else {
                            ctx.moveTo(fishX + fish.size, fishY - fish.size/4);
                            ctx.lineTo(fishX + fish.size*1.5, fishY + tailWag);
                            ctx.lineTo(fishX + fish.size, fishY + fish.size/4);
                        }
                        ctx.fill();
                        
                        // é±¼çœ¼
                        const eyeX = fishX + (element.direction > 0 ? fish.size/2 : -fish.size/2);
                        
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(eyeX, fishY - fish.size/4, fish.size/5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(eyeX, fishY - fish.size/4, fish.size/10, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // ç»˜åˆ¶æ½œæ°´è‰‡
            for (const element of pirateElements) {
                if (element.type === 'submarine' || element.type === 'smallSubmarine') {
                    const bob = Math.sin(frameCount * element.bobSpeed) * element.bobAmount;
                    const isSmall = element.type === 'smallSubmarine';
                    
                    // æ½œè‰‡ä¸»ä½“
                    const gradient = ctx.createLinearGradient(0, element.y + bob, 0, element.y + element.height + bob);
                    gradient.addColorStop(0, isSmall ? '#4a6a85' : '#5a7a95');
                    gradient.addColorStop(1, isSmall ? '#2a4a65' : '#3a5a75');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(
                        element.x + element.width/2,
                        element.y + bob,
                        element.width/2,
                        element.height/2,
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                    
                    // æ½œè‰‡é¡¶éƒ¨
                    if (!isSmall) {
                        ctx.fillStyle = '#3a5a75';
                        ctx.beginPath();
                        ctx.ellipse(
                            element.x + element.width*0.5,
                            element.y - element.height*0.2 + bob,
                            element.width*0.2,
                            element.height*0.2,
                            0, 0, Math.PI, true
                        );
                        ctx.fill();
                        
                        // æ½œæœ›é•œ
                        ctx.fillStyle = '#2a4a65';
                        ctx.fillRect(
                            element.x + element.width * 0.4 - 3,
                            element.y - element.height * 0.2 - 30 + bob,
                            6,
                            30
                        );
                        
                        // æ½œæœ›é•œé¡¶éƒ¨
                        ctx.fillRect(
                            element.x + element.width * 0.4 - 5,
                            element.y - element.height * 0.2 - 33 + bob,
                            10,
                            3
                        );
                        
                        // ç»˜åˆ¶çª—æˆ·
                        for (const window of element.windows) {
                            // çª—æˆ·å‘å…‰æ•ˆæœ
                            const glow = ctx.createRadialGradient(
                                window.x, window.y + bob, 0,
                                window.x, window.y + bob, window.radius * 2
                            );
                            glow.addColorStop(0, `rgba(162, 220, 240, ${window.glow})`);
                            glow.addColorStop(1, 'rgba(162, 220, 240, 0)');
                            
                            ctx.fillStyle = glow;
                            ctx.beginPath();
                            ctx.arc(window.x, window.y + bob, window.radius * 2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // çª—æˆ·æœ¬ä½“
                            ctx.fillStyle = 'rgba(200, 230, 250, 0.8)';
                            ctx.beginPath();
                            ctx.arc(window.x, window.y + bob, window.radius, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // çª—æˆ·è¾¹æ¡†
                            ctx.strokeStyle = '#2a4a65';
                            ctx.lineWidth = 1.5;
                            ctx.stroke();
                        }
                    } else {
                        // å°æ½œè‰‡çª—æˆ·
                        const windowX = element.x + element.width * 0.3;
                        const windowY = element.y + bob;
                        
                        ctx.fillStyle = 'rgba(162, 220, 240, 0.5)';
                        ctx.beginPath();
                        ctx.arc(windowX, windowY, element.width * 0.15, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'rgba(200, 230, 250, 0.8)';
                        ctx.beginPath();
                        ctx.arc(windowX, windowY, element.width * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.strokeStyle = '#2a4a65';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                    }
                }
            }
            
            // ç»˜åˆ¶è½»é›¾å±‚æ¬¡ - å¢å¼ºæ·±åº¦æ„Ÿ
            for (const element of pirateElements) {
                if (element.type === 'mist') {
                    // ç»˜åˆ¶åŠé€æ˜æµ…è“é›¾å±‚
                    ctx.fillStyle = `rgba(120, 180, 210, ${element.opacity})`;
                    ctx.fillRect(0, element.y, canvas.width, 70);
                }
            }
        }

        // æ·»åŠ æ–°çš„è¾…åŠ©å‡½æ•°
        function drawRainClouds() {
            // ... æ‚¨æä¾›çš„drawRainCloudsä»£ç  ...
        }

        function drawRainOverlay() {
            // ... æ‚¨æä¾›çš„drawRainOverlayä»£ç  ...
        }

        function createLightningBolt(lightning, startX, startY, length, angle, generation) {
            if (generation > 3) return;
            
            const endX = startX + Math.cos(angle) * length;
            const endY = startY + Math.sin(angle) * length;
            
            lightning.branches.push({
                startX: startX,
                startY: startY,
                endX: endX,
                endY: endY
            });
            
            if (Math.random() < 0.6 && generation < 2) {
                const newAngle = angle + (Math.random() * 0.5 - 0.25) * Math.PI;
                const newLength = length * (0.3 + Math.random() * 0.4);
                
                const branchStartPos = 0.3 + Math.random() * 0.5;
                const branchStartX = startX + (endX - startX) * branchStartPos;
                const branchStartY = startY + (endY - startY) * branchStartPos;
                
                createLightningBolt(
                    lightning,
                    branchStartX,
                    branchStartY,
                    newLength,
                    newAngle,
                    generation + 1
                );
            }
        }

        // åˆ›å»ºæ¨±èŠ±åº­é™¢åœºæ™¯å…ƒç´ 
        function createCherryBlossom() {
            // æ¸…ç©ºæ¨±èŠ±åœºæ™¯å…ƒç´ 
            cherrySakura = [];
            
            // èƒŒæ™¯è¿œå±± - å¤šå±‚æ¬¡çš„å±±è„‰
            cherrySakura.push({
                type: 'mountains',
                layers: [
                    {color: '#3A2D4D', height: 100, offset: 0},
                    {color: '#4D3A65', height: 80, offset: 20},
                    {color: '#5E477D', height: 60, offset: 40}
                ]
            });
            
            // æ·»åŠ é™æ€æ¨±èŠ±æ ‘ - å¤šç§å½¢æ€
            const treeCount = 5;
            for (let i = 0; i < treeCount; i++) {
                // ä½ç½®éšæ ‘çš„å¤§å°å’Œç±»å‹å˜åŒ–
                const treeType = i % 3;
                const x = i * (canvas.width / (treeCount - 0.5)) - 50;
                
                // ä¸åŒå¤§å°çš„æ ‘
                let height, width, style;
                if (treeType === 0) {
                    // é«˜å¤§çš„æ ‘
                    height = 190 + (i % 2) * 20;
                    width = 35 + (i % 2) * 5;
                    style = 'full';
                } else if (treeType === 1) {
                    // å°ç‚¹çš„æ ‘
                    height = 140 + (i % 2) * 15;
                    width = 25 + (i % 2) * 4;
                    style = 'curved';
                } else {
                    // ä¸­ç­‰çš„æ ‘
                    height = 160 + (i % 2) * 15;
                    width = 30 + (i % 2) * 5;
                    style = 'split';
                }
                
                cherrySakura.push({
                    type: 'tree',
                    x: x,
                    y: canvas.height - 30,
                    height: height,
                    width: width,
                    style: style,
                    blossomIntensity: 0.7 + (i % 3) * 0.1 // èŠ±æœµå¯†åº¦
                });
            }
            
            // æ·»åŠ åº­é™¢è£…é¥°å…ƒç´ 
            
            // ä¼ ç»ŸçŸ³ç¯ç¬¼
            cherrySakura.push({
                type: 'stone-lantern',
                x: canvas.width * 0.25,
                y: canvas.height - 30,
                height: 60,
                glowing: true
            });
            
            // å°æ¡¥
            cherrySakura.push({
                type: 'bridge',
                x: canvas.width * 0.6,
                y: canvas.height - 35,
                width: 120,
                height: 30
            });
            
            // æ± å¡˜
            cherrySakura.push({
                type: 'pond',
                x: canvas.width * 0.5,
                y: canvas.height - 20,
                width: 180,
                height: 15
            });
            
            // è£…é¥°çŸ³å¤´
            for (let i = 0; i < 8; i++) {
                const size = 8 + (i % 4) * 3;
                const stoneType = i % 3;
                let x, y;
                
                // æ ¹æ®çŸ³å¤´ç±»å‹æ”¾ç½®åœ¨ä¸åŒä½ç½®
                if (stoneType === 0) {
                    // æ± å¡˜è¾¹çš„çŸ³å¤´
                    x = canvas.width * 0.5 + (i - 4) * 20;
                    y = canvas.height - 25;
                } else if (stoneType === 1) {
                    // ç¯ç¬¼æ—çš„çŸ³å¤´
                    x = canvas.width * 0.25 + (i - 2) * 10 - 20;
                    y = canvas.height - 15 + (i % 2) * 2;
                } else {
                    // å°æ¡¥é™„è¿‘çš„çŸ³å¤´
                    x = canvas.width * 0.65 + (i - 4) * 15;
                    y = canvas.height - 18 + (i % 2) * 3;
                }
                
                cherrySakura.push({
                    type: 'stone',
                    x: x,
                    y: y,
                    size: size,
                    shape: stoneType
                });
            }
            
            // æ—¥å¼åº­é™¢æ …æ 
            for (let i = 0; i < 2; i++) {
                cherrySakura.push({
                    type: 'fence',
                    x: i === 0 ? 50 : canvas.width - 200,
                    y: canvas.height - 40,
                    width: 120,
                    height: 25
                });
            }
            
            // è¿œå¤„çš„é¸Ÿå±…
            cherrySakura.push({
                type: 'torii',
                x: canvas.width * 0.8,
                y: canvas.height - 80,
                width: 70,
                height: 60
            });
            
            // æ·»åŠ é£˜è½çš„èŠ±ç“£ - å¤§å¹…å¢åŠ æ•°é‡ä½¿åœºæ™¯æ›´åŠ ç”ŸåŠ¨
            const petalCount = 120; // å¤§å¹…å¢åŠ èŠ±ç“£æ•°é‡
            for (let i = 0; i < petalCount; i++) {
                cherrySakura.push({
                    type: 'petal',
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height - 60),
                    size: 1.5 + Math.random() * 1.8, // å¢å¤§å°ºå¯¸ï¼Œæ›´åŠ å¤šæ ·åŒ–
                    speed: 0.05 + Math.random() * 0.12, // ç¨å¾®å¢åŠ é€Ÿåº¦ä½†ä»ç„¶ä¿æŒç¼“æ…¢
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.01, // å¢åŠ æ—‹è½¬é€Ÿåº¦
                    swayAmount: 0.15 + Math.random() * 0.25, // å¢åŠ æ‘†åŠ¨å¹…åº¦
                    swaySpeed: 0.001 + Math.random() * 0.002, // å¢åŠ æ‘†åŠ¨é€Ÿåº¦
                    opacity: 0.5 + Math.random() * 0.4, // å¢åŠ ä¸é€æ˜åº¦
                    color: Math.random() > 0.7 ? 
                        (Math.random() > 0.5 ? '#FFC8D8' : '#FFDBF1') : '#FFB7C5' // æ›´å¤šè‰²å½©å˜åŒ–
                });
            }
        }
        
        // ç»˜åˆ¶æ¨±èŠ±åº­é™¢åœºæ™¯
        function drawCherryBlossom() {
            // ç»˜åˆ¶å¤©ç©ºèƒŒæ™¯æ¸å˜ - æŸ”å’Œçš„é»„æ˜è‰²è°ƒ
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height - 30);
            skyGradient.addColorStop(0, '#4A3B65'); // æ·±ç´«è‰²é¡¶éƒ¨
            skyGradient.addColorStop(0.5, '#7E5A9B'); // ä¸­é—´è‰²è°ƒ
            skyGradient.addColorStop(1, '#CF99CC'); // ç²‰ç´«è‰²åº•éƒ¨
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶è¿œå¤„çš„æœˆäº®
            ctx.fillStyle = 'rgba(255, 255, 240, 0.8)';
            ctx.beginPath();
            ctx.arc(canvas.width * 0.8, canvas.height * 0.2, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // æœˆäº®å…‰æ™•
            const moonGlowGradient = ctx.createRadialGradient(
                canvas.width * 0.8, canvas.height * 0.2, 25,
                canvas.width * 0.8, canvas.height * 0.2, 70
            );
            moonGlowGradient.addColorStop(0, 'rgba(255, 255, 240, 0.3)');
            moonGlowGradient.addColorStop(1, 'rgba(255, 255, 240, 0)');
            ctx.fillStyle = moonGlowGradient;
            ctx.beginPath();
            ctx.arc(canvas.width * 0.8, canvas.height * 0.2, 70, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶é™æ€æ˜Ÿæ˜Ÿ
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            for (let i = 0; i < 30; i++) {
                const x = (i * 37) % canvas.width;
                const y = ((i * 29) % 150) + 20;
                const size = 0.5 + (i % 3) * 0.5;
                ctx.fillRect(x, y, size, size);
            }
            
            // ç»˜åˆ¶æ‰€æœ‰é™æ€åœºæ™¯å…ƒç´ 
            for (const element of cherrySakura) {
                if (element.type === 'mountains') {
                    // ç»˜åˆ¶å¤šå±‚æ¬¡çš„è¿œå±±
                    for (const layer of element.layers) {
                        // å±±è„‰è½®å»“
                        ctx.fillStyle = layer.color;
                        ctx.beginPath();
                        ctx.moveTo(0, canvas.height);
                        
                        // åˆ›å»ºå±±è„‰æ›²çº¿
                        const segmentCount = 10;
                        for (let i = 0; i <= segmentCount; i++) {
                            const x = i * (canvas.width / segmentCount);
                            // ä½¿ç”¨æ­£å¼¦å‡½æ•°åˆ›å»ºè‡ªç„¶çš„å±±è„‰å½¢çŠ¶
                            const height = layer.height + Math.sin(i * 0.8) * 20 + Math.sin(i * 0.3) * 15;
                            const y = canvas.height - height - layer.offset;
                            
                            if (i === 0) {
                                ctx.lineTo(x, y);
                            } else {
                                const prevX = (i - 1) * (canvas.width / segmentCount);
                                const prevHeight = layer.height + Math.sin((i - 1) * 0.8) * 20 + Math.sin((i - 1) * 0.3) * 15;
                                const prevY = canvas.height - prevHeight - layer.offset;
                                
                                // ä½¿ç”¨è´å¡å°”æ›²çº¿åˆ›å»ºå¹³æ»‘çš„å±±è„‰
                                const cpX = (prevX + x) / 2;
                                ctx.quadraticCurveTo(cpX, prevY, x, y);
                            }
                        }
                        
                        ctx.lineTo(canvas.width, canvas.height);
                        ctx.closePath();
                        ctx.fill();
                        
                        // å±±ä¸Šçš„ç§¯é›ª/å…‰æ•ˆ
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.beginPath();
                        ctx.moveTo(0, canvas.height - layer.height - layer.offset);
                        
                        for (let i = 0; i <= segmentCount; i++) {
                            const x = i * (canvas.width / segmentCount);
                            const height = layer.height + Math.sin(i * 0.8) * 20 + Math.sin(i * 0.3) * 15;
                            const y = canvas.height - height - layer.offset;
                            
                            if (i === 0) {
                                ctx.lineTo(x, y);
                            } else {
                                const prevX = (i - 1) * (canvas.width / segmentCount);
                                const prevHeight = layer.height + Math.sin((i - 1) * 0.8) * 20 + Math.sin((i - 1) * 0.3) * 15;
                                const prevY = canvas.height - prevHeight - layer.offset;
                                
                                const cpX = (prevX + x) / 2;
                                ctx.quadraticCurveTo(cpX, prevY, x, y);
                            }
                        }
                        
                        ctx.lineTo(canvas.width, canvas.height - layer.height - layer.offset + 20);
                        ctx.lineTo(0, canvas.height - layer.height - layer.offset + 20);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
                else if (element.type === 'tree') {
                    // ç»˜åˆ¶æ¨±èŠ±æ ‘å¹²
                    const trunkGradient = ctx.createLinearGradient(
                        element.x, element.y - element.height,
                        element.x + element.width, element.y
                    );
                    trunkGradient.addColorStop(0, '#6D4C41'); // æ·±è¤è‰²
                    trunkGradient.addColorStop(1, '#8D6E63'); // æµ…è¤è‰²
                    
                    ctx.fillStyle = trunkGradient;
                    
                    // æ ¹æ®æ ‘çš„æ ·å¼ç»˜åˆ¶ä¸åŒå½¢çŠ¶çš„æ ‘å¹²
                    if (element.style === 'full') {
                        // å®Œæ•´æŒºæ‹”çš„æ ‘å¹²
                        ctx.beginPath();
                        ctx.moveTo(element.x, element.y);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.1, 
                            element.y - element.height * 0.5,
                            element.x + element.width * 0.2, 
                            element.y - element.height * 0.9
                        );
                        ctx.lineTo(element.x + element.width * 0.2, element.y - element.height * 0.9);
                        ctx.lineTo(element.x + element.width * 0.8, element.y - element.height * 0.9);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.9, 
                            element.y - element.height * 0.5,
                            element.x + element.width, element.y
                        );
                        ctx.closePath();
                        ctx.fill();
                        
                        // æ·»åŠ ä¸»è¦åˆ†æ
                        ctx.strokeStyle = '#6D4C41';
                        ctx.lineWidth = 3;
                        
                        // å·¦ä¾§ä¸»åˆ†æ
                        ctx.beginPath();
                        ctx.moveTo(element.x + element.width * 0.3, element.y - element.height * 0.5);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.1, 
                            element.y - element.height * 0.6,
                            element.x, element.y - element.height * 0.7
                        );
                        ctx.stroke();
                        
                        // å³ä¾§ä¸»åˆ†æ
                        ctx.beginPath();
                        ctx.moveTo(element.x + element.width * 0.7, element.y - element.height * 0.6);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.9, 
                            element.y - element.height * 0.7,
                            element.x + element.width + 10, element.y - element.height * 0.75
                        );
                        ctx.stroke();
                        
                        // ç»˜åˆ¶æ¨±èŠ±
                        ctx.fillStyle = '#FFCFD5';
                        
                        // ä¸»æ ‘å† 
                        drawTreeBlossoms(
                            element.x + element.width * 0.5, 
                            element.y - element.height * 0.8,
                            element.width * 2.5,
                            element.height * 0.4,
                            element.blossomIntensity
                        );
                        
                        // å·¦ä¾§æ ‘å† 
                        drawTreeBlossoms(
                            element.x + element.width * 0.15, 
                            element.y - element.height * 0.6,
                            element.width * 1.2,
                            element.height * 0.3,
                            element.blossomIntensity
                        );
                        
                        // å³ä¾§æ ‘å† 
                        drawTreeBlossoms(
                            element.x + element.width * 0.85, 
                            element.y - element.height * 0.7,
                            element.width * 1.2,
                            element.height * 0.3,
                            element.blossomIntensity
                        );
                    }
                    else if (element.style === 'curved') {
                        // å¼¯æ›²çš„æ ‘å¹²
                        ctx.beginPath();
                        ctx.moveTo(element.x, element.y);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.3, 
                            element.y - element.height * 0.5,
                            element.x + element.width * 0.7, 
                            element.y - element.height * 0.9
                        );
                        ctx.lineTo(element.x + element.width * 0.8, element.y - element.height * 0.85);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.5, 
                            element.y - element.height * 0.4,
                            element.x + element.width, element.y
                        );
                        ctx.closePath();
                        ctx.fill();
                        
                        // æ·»åŠ åˆ†æ
                        ctx.strokeStyle = '#6D4C41';
                        ctx.lineWidth = 2;
                        
                        // ä¸Šéƒ¨åˆ†æ
                        ctx.beginPath();
                        ctx.moveTo(element.x + element.width * 0.6, element.y - element.height * 0.7);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.8, 
                            element.y - element.height * 0.8,
                            element.x + element.width * 0.9, element.y - element.height * 0.95
                        );
                        ctx.stroke();
                        
                        // ä¸­éƒ¨åˆ†æ
                        ctx.beginPath();
                        ctx.moveTo(element.x + element.width * 0.4, element.y - element.height * 0.5);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.2, 
                            element.y - element.height * 0.55,
                            element.x, element.y - element.height * 0.6
                        );
                        ctx.stroke();
                        
                        // ç»˜åˆ¶æ¨±èŠ±
                        ctx.fillStyle = '#FFCFD5';
                        
                        // ä¸»æ ‘å† 
                        drawTreeBlossoms(
                            element.x + element.width * 0.7, 
                            element.y - element.height * 0.85,
                            element.width * 1.8,
                            element.height * 0.3,
                            element.blossomIntensity
                        );
                        
                        // ä¸‹éƒ¨æ ‘å† 
                        drawTreeBlossoms(
                            element.x + element.width * 0.2, 
                            element.y - element.height * 0.5,
                            element.width * 1.5,
                            element.height * 0.25,
                            element.blossomIntensity
                        );
                    }
                    else if (element.style === 'split') {
                        // åˆ†å‰çš„æ ‘å¹²
                        ctx.beginPath();
                        ctx.moveTo(element.x, element.y);
                        ctx.lineTo(element.x + element.width/2, element.y - element.height * 0.4);
                        ctx.lineTo(element.x + element.width, element.y);
                        ctx.closePath();
                        ctx.fill();
                        
                        // å·¦ä¸»å¹²
                        ctx.beginPath();
                        ctx.moveTo(element.x + element.width * 0.35, element.y - element.height * 0.35);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.2, 
                            element.y - element.height * 0.6,
                            element.x + element.width * 0.1, 
                            element.y - element.height * 0.85
                        );
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.15, 
                            element.y - element.height * 0.7,
                            element.x + element.width * 0.3, 
                            element.y - element.height * 0.45
                        );
                        ctx.closePath();
                        ctx.fill();
                        
                        // å³ä¸»å¹²
                        ctx.beginPath();
                        ctx.moveTo(element.x + element.width * 0.65, element.y - element.height * 0.35);
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.8, 
                            element.y - element.height * 0.65,
                            element.x + element.width * 0.95, 
                            element.y - element.height * 0.8
                        );
                        ctx.quadraticCurveTo(
                            element.x + element.width * 0.85, 
                            element.y - element.height * 0.65,
                            element.x + element.width * 0.7, 
                            element.y - element.height * 0.45
                        );
                        ctx.closePath();
                        ctx.fill();
                        
                        // ç»˜åˆ¶æ¨±èŠ±
                        ctx.fillStyle = '#FFCFD5';
                        
                        // å·¦ä¾§æ ‘å† 
                        drawTreeBlossoms(
                            element.x + element.width * 0.2, 
                            element.y - element.height * 0.75,
                            element.width * 1.4,
                            element.height * 0.25,
                            element.blossomIntensity
                        );
                        
                        // å³ä¾§æ ‘å† 
                        drawTreeBlossoms(
                            element.x + element.width * 0.8, 
                            element.y - element.height * 0.7,
                            element.width * 1.4,
                            element.height * 0.25,
                            element.blossomIntensity
                        );
                    }
                }
                else if (element.type === 'stone-lantern') {
                    // ç»˜åˆ¶ä¼ ç»Ÿæ—¥å¼çŸ³ç¯ç¬¼
                    const baseWidth = 20;
                    
                    // åº•åº§
                    ctx.fillStyle = '#8C8C8C';
                    ctx.fillRect(
                        element.x - baseWidth, 
                        element.y - 10, 
                        baseWidth * 2, 
                        10
                    );
                    
                    // ä¸­æŸ±
                    ctx.fillRect(
                        element.x - baseWidth/2,
                        element.y - 25,
                        baseWidth,
                        15
                    );
                    
                    // ç¯ç¬¼ä¸»ä½“
                    ctx.fillStyle = '#7A7A7A';
                    ctx.beginPath();
                    ctx.moveTo(element.x - baseWidth, element.y - 30);
                    ctx.lineTo(element.x + baseWidth, element.y - 30);
                    ctx.lineTo(element.x + baseWidth - 5, element.y - 45);
                    ctx.lineTo(element.x - baseWidth + 5, element.y - 45);
                    ctx.closePath();
                    ctx.fill();
                    
                    // ç¯ç¬¼é¡¶éƒ¨
                    ctx.fillStyle = '#686868';
                    ctx.beginPath();
                    ctx.moveTo(element.x - baseWidth + 3, element.y - 45);
                    ctx.lineTo(element.x + baseWidth - 3, element.y - 45);
                    ctx.lineTo(element.x + baseWidth/2, element.y - 55);
                    ctx.lineTo(element.x - baseWidth/2, element.y - 55);
                    ctx.closePath();
                    ctx.fill();
                    
                    // ç¯ç¬¼çª—å£ - å‘å…‰æ•ˆæœ
                    if (element.glowing) {
                        // çª—å£
                        ctx.fillStyle = 'rgba(255, 220, 150, 0.7)';
                        ctx.fillRect(
                            element.x - baseWidth/2,
                            element.y - 40,
                            baseWidth,
                            10
                        );
                        
                        // å…‰æ™•
                        const glowGradient = ctx.createRadialGradient(
                            element.x, element.y - 35, 5,
                            element.x, element.y - 35, 25
                        );
                        glowGradient.addColorStop(0, 'rgba(255, 220, 150, 0.4)');
                        glowGradient.addColorStop(1, 'rgba(255, 220, 150, 0)');
                        
                        ctx.fillStyle = glowGradient;
                        ctx.beginPath();
                        ctx.arc(element.x, element.y - 35, 25, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.fillStyle = '#555555';
                        ctx.fillRect(
                            element.x - baseWidth/2,
                            element.y - 40,
                            baseWidth,
                            10
                        );
                    }
                }
                else if (element.type === 'bridge') {
                    // ç»˜åˆ¶å°æ¡¥
                    ctx.fillStyle = '#8B5A2B';
                    
                    // æ¡¥çš„å¼§å½¢
                    ctx.beginPath();
                    ctx.moveTo(element.x, element.y);
                    ctx.quadraticCurveTo(
                        element.x + element.width/2, 
                        element.y - element.height,
                        element.x + element.width, 
                        element.y
                    );
                    ctx.lineTo(element.x + element.width, element.y + 5);
                    ctx.lineTo(element.x, element.y + 5);
                    ctx.closePath();
                    ctx.fill();
                    
                    // æ¡¥æ æ†
                    ctx.fillStyle = '#6D4C41';
                    
                    // å·¦æ æ†æŸ±
                    ctx.fillRect(
                        element.x + 10,
                        element.y - 10,
                        3,
                        14
                    );
                    
                    // å³æ æ†æŸ±
                    ctx.fillRect(
                        element.x + element.width - 13,
                        element.y - 10,
                        3,
                        14
                    );
                    
                    // æ¡¥æ æ†æ¨ªæ¡
                    ctx.fillRect(
                        element.x + 5,
                        element.y - 7,
                        element.width - 10,
                        2
                    );
                    
                    // æ¡¥æ¿çº¹ç†
                    ctx.strokeStyle = '#5D4037';
                    ctx.lineWidth = 1;
                    
                    for (let i = 1; i < 10; i++) {
                        const x = element.x + (element.width * i) / 10;
                        
                        // è®¡ç®—æ¡¥é¢é«˜åº¦
                        const boardY = element.y - Math.sin((i / 10) * Math.PI) * element.height;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, boardY);
                        ctx.lineTo(x, boardY + 5);
                        ctx.stroke();
                    }
                }
                else if (element.type === 'pond') {
                    // ç»˜åˆ¶æ± å¡˜
                    const pondGradient = ctx.createLinearGradient(
                        element.x, element.y - element.height, 
                        element.x, element.y
                    );
                    pondGradient.addColorStop(0, '#5B88A5');
                    pondGradient.addColorStop(1, '#3A6980');
                    
                    ctx.fillStyle = pondGradient;
                    
                    // ç»˜åˆ¶æ± å¡˜å½¢çŠ¶ - æ¤­åœ†
                    ctx.beginPath();
                    ctx.ellipse(
                        element.x + element.width/2, 
                        element.y, 
                        element.width/2, 
                        element.height, 
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                    
                    // æ± å¡˜è¾¹ç¼˜
                    ctx.strokeStyle = '#4A7890';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.ellipse(
                        element.x + element.width/2, 
                        element.y, 
                        element.width/2, 
                        element.height, 
                        0, 0, Math.PI * 2
                    );
                    ctx.stroke();
                    
                    // æ± å¡˜é™æ€åå…‰
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.beginPath();
                    ctx.ellipse(
                        element.x + element.width/2 + 15, 
                        element.y - 2, 
                        element.width/3, 
                        element.height/1.5, 
                        0, 0, Math.PI
                    );
                    ctx.fill();
                    
                    // æ± å¡˜é™æ€å€’å½± - æ¨±èŠ±æ ‘çš„å€’å½±
                    ctx.fillStyle = 'rgba(255, 182, 193, 0.1)';
                    for (let i = 0; i < 3; i++) {
                        const reflectionX = element.x + element.width/2 + (i-1) * 30;
                        const reflectionY = element.y;
                        const reflectionSize = 10 + i * 5;
                        
                        ctx.beginPath();
                        ctx.moveTo(reflectionX - reflectionSize, reflectionY);
                        ctx.quadraticCurveTo(
                            reflectionX, 
                            reflectionY + 8,
                            reflectionX + reflectionSize, 
                            reflectionY
                        );
                        ctx.fill();
                    }
                }
                else if (element.type === 'stone') {
                    // ç»˜åˆ¶è£…é¥°çŸ³å¤´
                    const stoneGradient = ctx.createRadialGradient(
                        element.x, element.y - element.size/3, 0,
                        element.x, element.y - element.size/3, element.size
                    );
                    stoneGradient.addColorStop(0, '#A0A0A0');
                    stoneGradient.addColorStop(1, '#707070');
                    
                    ctx.fillStyle = stoneGradient;
                    
                    // æ ¹æ®çŸ³å¤´å½¢çŠ¶ç»˜åˆ¶ä¸åŒæ ·å¼
                    if (element.shape === 0) {
                        // åœ†å½¢çŸ³å¤´
                        ctx.beginPath();
                        ctx.arc(
                            element.x, 
                            element.y, 
                            element.size/2, 
                            0, Math.PI * 2
                        );
                        ctx.fill();
                    } 
                    else if (element.shape === 1) {
                        // æ¤­åœ†å½¢çŸ³å¤´
                        ctx.beginPath();
                        ctx.ellipse(
                            element.x, 
                            element.y, 
                            element.size * 0.7, 
                            element.size * 0.4, 
                            0, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                    else {
                        // ä¸è§„åˆ™çŸ³å¤´
                        ctx.beginPath();
                        ctx.moveTo(element.x - element.size/2, element.y);
                        ctx.quadraticCurveTo(
                            element.x - element.size/2, element.y - element.size/2,
                            element.x, element.y - element.size/2
                        );
                        ctx.quadraticCurveTo(
                            element.x + element.size/2, element.y - element.size/2,
                            element.x + element.size/2, element.y
                        );
                        ctx.quadraticCurveTo(
                            element.x + element.size/3, element.y + element.size/3,
                            element.x, element.y + element.size/4
                        );
                        ctx.quadraticCurveTo(
                            element.x - element.size/3, element.y + element.size/3,
                            element.x - element.size/2, element.y
                        );
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // çŸ³å¤´é«˜å…‰
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.beginPath();
                    ctx.ellipse(
                        element.x - element.size * 0.2, 
                        element.y - element.size * 0.1, 
                        element.size * 0.15, 
                        element.size * 0.1, 
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
                else if (element.type === 'fence') {
                    // ç»˜åˆ¶æ—¥å¼åº­é™¢æ …æ 
                    const postCount = 6;
                    const postWidth = 3;
                    const postSpacing = element.width / (postCount - 1);
                    
                    ctx.fillStyle = '#8B5A2B';
                    
                    // ç»˜åˆ¶æ …æ æŸ±å­
                    for (let i = 0; i < postCount; i++) {
                        const postX = element.x + i * postSpacing;
                        
                        ctx.fillRect(
                            postX - postWidth/2,
                            element.y - element.height,
                            postWidth,
                            element.height
                        );
                    }
                    
                    // ç»˜åˆ¶æ …æ æ¨ªæ¡
                    for (let i = 0; i < 2; i++) {
                        const barY = element.y - element.height * 0.8 + i * element.height * 0.5;
                        
                        ctx.fillRect(
                            element.x,
                            barY,
                            element.width,
                            2
                        );
                    }
                }
                else if (element.type === 'torii') {
                    // ç»˜åˆ¶è¿œå¤„çš„é¸Ÿå±…
                    ctx.fillStyle = '#E53935'; // ä¼ ç»Ÿæœ±çº¢è‰²
                    
                    // é¡¶éƒ¨æ¨ªæ¢
                    ctx.beginPath();
                    ctx.moveTo(element.x - 5, element.y - element.height * 0.9);
                    ctx.lineTo(element.x + element.width + 5, element.y - element.height * 0.9);
                    ctx.lineTo(element.x + element.width + 10, element.y - element.height * 0.85);
                    ctx.lineTo(element.x + element.width + 10, element.y - element.height * 0.8);
                    ctx.lineTo(element.x - 10, element.y - element.height * 0.8);
                    ctx.lineTo(element.x - 10, element.y - element.height * 0.85);
                    ctx.closePath();
                    ctx.fill();
                    
                    // æ¬¡æ¨ªæ¢
                    ctx.fillRect(
                        element.x - 5,
                        element.y - element.height * 0.75,
                        element.width + 10,
                        element.height * 0.05
                    );
                    
                    // å·¦ç«‹æŸ±
                    ctx.fillRect(
                        element.x,
                        element.y - element.height,
                        element.width * 0.1,
                        element.height
                    );
                    
                    // å³ç«‹æŸ±
                    ctx.fillRect(
                        element.x + element.width * 0.9,
                        element.y - element.height,
                        element.width * 0.1,
                        element.height
                    );
                }
                else if (element.type === 'petal') {
                    // ç»˜åˆ¶é£˜è½çš„èŠ±ç“£
                    ctx.save();
                    ctx.translate(element.x, element.y);
                    ctx.rotate(element.rotation);
                    
                    ctx.fillStyle = `${element.color}${Math.floor(element.opacity * 255).toString(16).padStart(2, '0')}`;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, element.size, element.size * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                    
                    // æ¯6å¸§æ›´æ–°ä¸€æ¬¡èŠ±ç“£ä½ç½®ï¼Œé€‚å½“åŠ å¿«åŠ¨ç”»é€Ÿåº¦
                    if (frameCount % 6 === 0) {
                        // èŠ±ç“£ä¸‹è½å’Œæ‘‡æ‘†åŠ¨ä½œ - é€‚å½“åŠ å¿«
                        element.y += element.speed * 1.3; // å¢åŠ ä¸‹è½é€Ÿåº¦
                        element.x += Math.sin(frameCount * element.swaySpeed * 1.2) * element.swayAmount;
                        element.rotation += element.rotSpeed * 1.2;
                        
                        // é‡ç½®è¶…å‡ºå±å¹•çš„èŠ±ç“£
                        if (element.y > canvas.height) {
                            element.y = -10 - Math.random() * 50;
                            element.x = Math.random() * canvas.width;
                        }
                    }
                }
            }
            
            // ç»˜åˆ¶åœ°é¢
            const groundGradient = ctx.createLinearGradient(0, canvas.height - 30, 0, canvas.height);
            groundGradient.addColorStop(0, '#4A367A');
            groundGradient.addColorStop(1, '#3A2963');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
            
            // ç»˜åˆ¶é™æ€å‰æ™¯è–„é›¾
            const mistGradient = ctx.createLinearGradient(0, canvas.height - 60, 0, canvas.height - 30);
            mistGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
            mistGradient.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
            
            ctx.fillStyle = mistGradient;
            ctx.fillRect(0, canvas.height - 60, canvas.width, 30);
        }
        
        function drawTreeBlossoms(centerX, centerY, width, height, intensity) {
            const clusterCount = Math.floor(width / 20);
            const petalCount = Math.floor(15 * intensity);
            
            // ä¸ºä¸åŒä½ç½®é€‰æ‹©ä¸åŒçš„ç²‰è‰²è°ƒ
            const pinkColors = ['#FFCFD5', '#FFD6DE', '#FFB7C5', '#FFC8D8'];
            
            for (let i = 0; i < clusterCount; i++) {
                const clusterX = centerX + (i - clusterCount/2) * (width / clusterCount);
                const clusterY = centerY + Math.sin(i * 0.7) * height * 0.5;
                const clusterSize = 12 + Math.sin(i) * 4;
                
                const colorIndex = Math.floor(i % pinkColors.length);  // ç¡®å®šæ€§é€‰æ‹©é¢œè‰²ï¼Œä¸ä½¿ç”¨éšæœº
                ctx.fillStyle = pinkColors[colorIndex];
                
                for (let j = 0; j < petalCount; j++) {
                    // åˆ›å»ºè‡ªç„¶åˆ†å¸ƒçš„èŠ±æœµç°‡ - å®Œå…¨ç¡®å®šæ€§ï¼Œä¸ä½¿ç”¨éšæœº
                    const angle = j * (Math.PI * 2 / petalCount);
                    const distance = ((j % 5) / 5) * clusterSize;
                    const petalX = clusterX + Math.cos(angle) * distance;
                    const petalY = clusterY + Math.sin(angle) * distance * 0.7;
                    const petalSize = 2 + (j % 3);
                    
                    ctx.beginPath();
                    ctx.arc(petalX, petalY, petalSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function createMeteorShower() {
            meteors = [];
            // Initial meteors
            for (let i = 0; i < 3; i++) {
                addMeteor();
            }
        }
        
        function addMeteor() {
            meteors.push({
                x: Math.random() * canvas.width,
                y: -10,
                speed: 3 + Math.random() * 5,
                length: 20 + Math.random() * 30,
                width: 2 + Math.random() * 2,
                color: `hsl(${Math.random() * 60 + 10}, 100%, 70%)`, // Varying meteor colors
                active: true
            });
        }
        
        function drawMeteors() {
            // ç»˜åˆ¶æ›´æ¢¦å¹»çš„æµæ˜Ÿé›¨èƒŒæ™¯
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#0D0221'); // æ·±ç´«è‰²é¡¶éƒ¨
            skyGradient.addColorStop(0.3, '#170B3B'); // æ·±é›ç´«è‰²
            skyGradient.addColorStop(0.6, '#1D1160'); // è“ç´«è‰²
            skyGradient.addColorStop(0.8, '#2A1B67'); // é›è“è‰²
            skyGradient.addColorStop(1, '#380E61'); // æš—ç´«è‰²åº•éƒ¨
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        
            // ç»˜åˆ¶è¿œå±±
            // ç¬¬ä¸€å±‚å±±è„‰ï¼ˆè¿œï¼‰ - å¢åŠ é«˜åº¦å’Œå¯è§åº¦
            ctx.fillStyle = 'rgba(48, 25, 90, 0.7)'; // æ›´æ·±ã€æ›´ä¸é€æ˜çš„ç´«è‰²
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 35);
            for (let x = 0; x < canvas.width; x += 60) {
                const height = 45 + Math.sin(x * 0.008) * 20; // æ˜¾è‘—å¢åŠ é«˜åº¦å’ŒæŒ¯å¹…
                ctx.lineTo(x, canvas.height - height);
            }
            ctx.lineTo(canvas.width, canvas.height - 40);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();
            
            // ç¬¬äºŒå±‚å±±è„‰ï¼ˆè¿‘ï¼‰ - å¢åŠ é«˜åº¦å’Œå¯¹æ¯”åº¦
            ctx.fillStyle = 'rgba(38, 20, 75, 0.8)'; // æ›´ä¸é€æ˜çš„è¿‘æ™¯å±±è„‰
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 25);
            for (let x = 0; x < canvas.width; x += 50) {
                const height = 30 + Math.sin(x * 0.015 + 30) * 15; // å¢åŠ é«˜åº¦å’Œèµ·ä¼
                ctx.lineTo(x, canvas.height - height);
            }
            ctx.lineTo(canvas.width, canvas.height - 20);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();
            
            // ç»˜åˆ¶èƒŒæ™¯ä¸­é—ªçƒçš„æ’æ˜Ÿ
            for (let i = 0; i < 100; i++) {
                const x = (i * 17 + frameCount * 0.01) % canvas.width;
                const y = (i * 23) % canvas.height;
                const size = (Math.sin(frameCount * 0.01 + i) * 0.5 + 0.5) * 2 + 0.5;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + Math.sin(frameCount * 0.02 + i * 0.1) * 0.3})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // å¶å°”æ·»åŠ å…‰æ™•
                if (size > 2) {
                    const glow = ctx.createRadialGradient(x, y, 0, x, y, size * 3);
                    glow.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                    glow.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(x, y, size * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // ç»˜åˆ¶è¿œå¤„çš„æ˜Ÿç³»
            ctx.save();
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            const galaxyX = canvas.width * 0.3;
            const galaxyY = canvas.height * 0.3;
            const galaxyRadius = 80;
            const spiralArms = 3;
            
            for (let t = 0; t < 30; t += 0.1) {
                const scale = 1 - Math.pow(t / 30, 0.5);
                for (let arm = 0; arm < spiralArms; arm++) {
                    const angle = t + (Math.PI * 2 * arm / spiralArms);
                    const x = galaxyX + Math.cos(angle) * t * scale * galaxyRadius / 30;
                    const y = galaxyY + Math.sin(angle) * t * scale * galaxyRadius / 30;
                    const size = 1.5 - (t / 30);
                    
                    if (size > 0) {
                        ctx.fillStyle = `rgba(255, 240, 220, ${0.7 * (1 - t/30)})`;
                        ctx.fillRect(x, y, size, size);
                    }
                }
            }
            ctx.restore();
            
            // Update meteor positions and draw them
            for (let i = meteors.length - 1; i >= 0; i--) {
                const meteor = meteors[i];
                
                if (meteor.active) {
                    meteor.x += meteor.speed;
                    meteor.y += meteor.speed;
                    
                    // Draw meteor with improved gradient and glow effect
                    const gradient = ctx.createLinearGradient(
                        meteor.x, meteor.y, 
                        meteor.x - meteor.length, meteor.y - meteor.length
                    );
                    gradient.addColorStop(0, '#FFFFFF');
                    gradient.addColorStop(0.2, meteor.color);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    // Draw glow effect
                    ctx.save();
                    ctx.shadowColor = meteor.color;
                    ctx.shadowBlur = 15; // å¢å¼ºå‘å…‰æ•ˆæœ
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = meteor.width;
                    ctx.lineCap = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(meteor.x, meteor.y);
                    ctx.lineTo(meteor.x - meteor.length, meteor.y - meteor.length);
                    ctx.stroke();
                    
                    ctx.restore();
                    
                    // Add enhanced particle trail
                    if (frameCount % 2 === 0) {
                        createParticles(meteor.x - Math.random() * 10, meteor.y - Math.random() * 10, meteor.color, 2);
                        
                        // æ·»åŠ ç™½è‰²æ ¸å¿ƒç²’å­
                        createParticles(meteor.x - Math.random() * 5, meteor.y - Math.random() * 5, "#FFFFFF", 1);
                    }
                    
                    // Check if meteor is out of view
                    if (meteor.x > canvas.width || meteor.y > canvas.height) {
                        meteor.active = false;
                    }
                }
            }
            
            // Remove inactive meteors and add new ones
            meteors = meteors.filter(m => m.active);
            
            if (meteors.length < 4 && Math.random() < 0.05) { // å¢åŠ æµæ˜Ÿç”Ÿæˆæ¦‚ç‡
                addMeteor();
            }
            
            // Occasionally add a really bright/large meteor
            if (meteors.length < 6 && Math.random() < 0.003) { // ç•¥å¾®å¢åŠ å¤§æµæ˜Ÿæ¦‚ç‡
                const bigMeteor = {
                    x: Math.random() * canvas.width / 2,
                    y: -20,
                    speed: 2 + Math.random() * 3,
                    length: 60 + Math.random() * 60, // æ›´é•¿çš„æµæ˜Ÿå°¾è¿¹
                    width: 6 + Math.random() * 6, // æ›´ç²—çš„æµæ˜Ÿ
                    color: `hsl(${Math.random() * 60}, 100%, 80%)`, // éšæœºæš–è‰²è°ƒ
                    active: true
                };
                meteors.push(bigMeteor);
                
                // Create a more subtle flash effect
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)'; // æ›´æŸ”å’Œçš„é—ªå…‰
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Add distant stars/meteors as background elements
            if (Math.random() < 0.15) { // å¢åŠ å°æµæ˜Ÿé¢‘ç‡
                const smallMeteor = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height / 2),
                    speed: 0.3 + Math.random() * 0.8,
                    length: 4 + Math.random() * 8,
                    width: 1,
                    color: `rgba(${150 + Math.random() * 105}, ${150 + Math.random() * 105}, 255, 0.6)`, // è“è‰²è°ƒå°æµæ˜Ÿ
                    active: true
                };
                meteors.push(smallMeteor);
            }
        }
        
        function createFireworks() {
            fireworks = [];
            
            // Launch initial fireworks
            for (let i = 0; i < 5; i++) {
                launchFirework();
            }
            
            // åˆ›å»ºé™æ€èƒŒæ™¯å…ƒç´ 
            // åŸå¸‚æˆ–ç¥ç¤¾å‰ªå½± - æ”¾åœ¨åº•éƒ¨
            const cityElements = [];
            const buildingCount = 8;
            
            for (let i = 0; i < buildingCount; i++) {
                const width = 30 + Math.random() * 50;
                const height = 40 + Math.random() * 80;
                const x = i * (canvas.width / buildingCount);
                
                cityElements.push({
                    type: 'building',
                    x: x,
                    y: canvas.height - 30,
                    width: width,
                    height: height,
                    windows: []
                });
                
                // å»ºç­‘ç‰©ä¸Šçš„çª—æˆ·
                const windowsPerRow = 3 + Math.floor(Math.random() * 2);
                const windowRows = Math.floor(height / 15);
                for (let row = 0; row < windowRows; row++) {
                    for (let col = 0; col < windowsPerRow; col++) {
                        if (Math.random() > 0.3) { // ä¸æ˜¯æ‰€æœ‰çª—æˆ·éƒ½äº®ç€
                            const windowX = x + col * (width / windowsPerRow) + 5;
                            const windowY = canvas.height - 30 - height + row * 15 + 5;
                            cityElements.push({
                                type: 'window',
                                x: windowX,
                                y: windowY,
                                width: 5,
                                height: 8,
                                lit: Math.random() > 0.5
                            });
                        }
                    }
                }
            }
            
            // ç¥ç¤¾æˆ–ç‰¹æ®Šå»ºç­‘
            cityElements.push({
                type: 'shrine',
                x: canvas.width * 0.7,
                y: canvas.height - 30,
                width: 100,
                height: 70
            });
            
            // å­˜å‚¨åˆ°å…¨å±€å˜é‡ä¸­
            fireworksCity = cityElements;
        }
        
        function launchFirework() {
            // åˆ›å»ºå¤šæ ·åŒ–çš„çƒŸèŠ±ï¼Œä½†å‡å°‘ç‰¹æ®Šå½¢çŠ¶çš„é¢‘ç‡ï¼ˆé€‚å½“å‡å°‘å¿ƒå½¢å’Œåœ†å½¢çš„å‡ºç°é¢‘æ¬¡ï¼‰
            const specialEffects = ["starburst", "ring", "heart", "willow", "chrysanthemum"];
            // é™ä½ç‰¹æ®Šæ•ˆæœæ¦‚ç‡ä»0.3é™åˆ°0.15
            const specialEffect = Math.random() < 0.15 ? 
                specialEffects[Math.floor(Math.random() * specialEffects.length)] : null;
            
            // æ›´å¤šçƒŸèŠ±é¢œè‰²é€‰æ‹©
            const colors = [
                { hue: 0, sat: 100, lig: 60 },      // çº¢è‰²
                { hue: 30, sat: 100, lig: 60 },     // æ©™è‰²
                { hue: 60, sat: 100, lig: 60 },     // é»„è‰²
                { hue: 120, sat: 100, lig: 60 },    // ç»¿è‰²
                { hue: 180, sat: 100, lig: 60 },    // é’è‰²
                { hue: 240, sat: 100, lig: 60 },    // è“è‰²
                { hue: 280, sat: 100, lig: 70 },    // ç´«è‰²
                { hue: 300, sat: 100, lig: 70 },    // ç²‰è‰²
                { hue: 330, sat: 100, lig: 70 }     // ç²‰çº¢è‰²
            ];
            
            const selectedColor = colors[Math.floor(Math.random() * colors.length)];
            
            // Create a new firework rocket
            const rocket = {
                x: Math.random() * canvas.width,
                y: canvas.height,
                targetY: 50 + Math.random() * 150,
                speed: 3 + Math.random() * 4,
                size: 2 + Math.random() * 2,
                color: `hsl(${selectedColor.hue}, ${selectedColor.sat}%, ${selectedColor.lig}%)`,
                exploded: false,
                particles: [],
                trailTimer: 0,
                specialEffect: specialEffect,
                baseHue: selectedColor.hue
            };
            
            fireworks.push(rocket);
        }
        
        function drawFireworks() {
            // ç»˜åˆ¶ç¾ä¸½çš„å¤œç©ºèƒŒæ™¯
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#0F0618');  // æ·±æš—è“ç´«è‰²é¡¶éƒ¨
            skyGradient.addColorStop(0.4, '#160D36');  // æ·±è“ç´«è‰²
            skyGradient.addColorStop(0.7, '#1E0A40');  // ä¸­é—´æ·±ç´«è‰²
            skyGradient.addColorStop(1, '#2A0A44');  // åº•éƒ¨ç´«è‰²
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶æœˆäº®
            ctx.fillStyle = 'rgba(255, 255, 240, 0.9)';
            ctx.beginPath();
            ctx.arc(canvas.width * 0.15, canvas.height * 0.15, 30, 0, Math.PI * 2);
            ctx.fill();
            
            // æœˆäº®å…‰æ™•
            const moonGlow = ctx.createRadialGradient(
                canvas.width * 0.15, canvas.height * 0.15, 30,
                canvas.width * 0.15, canvas.height * 0.15, 100
            );
            moonGlow.addColorStop(0, 'rgba(255, 255, 240, 0.3)');
            moonGlow.addColorStop(1, 'rgba(255, 255, 240, 0)');
            ctx.fillStyle = moonGlow;
            ctx.beginPath();
            ctx.arc(canvas.width * 0.15, canvas.height * 0.15, 100, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
            for (let i = 0; i < 100; i++) {
                const x = (i * 19) % canvas.width;
                const y = ((i * 17) % 200) + 5;
                const starSize = 0.5 + Math.random() * 1.5;
                const twinkle = Math.sin(frameCount * 0.05 + i) * 0.5 + 0.5;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + twinkle * 0.7})`;
                ctx.beginPath();
                ctx.arc(x, y, starSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ç»˜åˆ¶åŸå¸‚/ç¥ç¤¾å‰ªå½±
            if (fireworksCity && fireworksCity.length > 0) {
                for (const element of fireworksCity) {
                    if (element.type === 'building') {
                        // å»ºç­‘ç‰©å‰ªå½±
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(element.x, element.y - element.height, element.width, element.height);
                    }
                    else if (element.type === 'window') {
                        // çª—æˆ·
                        if (element.lit) {
                            ctx.fillStyle = 'rgba(255, 244, 214, 0.7)';
                        } else {
                            ctx.fillStyle = 'rgba(40, 40, 70, 0.9)';
                        }
                        ctx.fillRect(element.x, element.y, element.width, element.height);
                    }
                    else if (element.type === 'shrine') {
                        // ç¥ç¤¾å±‹é¡¶
                        ctx.fillStyle = '#000000';
                        ctx.beginPath();
                        ctx.moveTo(element.x, element.y - element.height * 0.7);
                        ctx.lineTo(element.x + element.width, element.y - element.height * 0.7);
                        ctx.lineTo(element.x + element.width * 0.75, element.y - element.height);
                        ctx.lineTo(element.x + element.width * 0.25, element.y - element.height);
                        ctx.closePath();
                        ctx.fill();
                        
                        // ç¥ç¤¾åº•éƒ¨
                        ctx.fillRect(
                            element.x + element.width * 0.15, 
                            element.y - element.height * 0.7, 
                            element.width * 0.7, 
                            element.height * 0.7
                        );
                        
                        // ç¥ç¤¾é¸Ÿå±…
                        ctx.fillStyle = '#400000';
                        // é¡¶éƒ¨æ¨ªæ¢
                        ctx.fillRect(
                            element.x + element.width * 0.05,
                            element.y - element.height * 0.6,
                            element.width * 0.9,
                            5
                        );
                        // åº•éƒ¨æ¨ªæ¢
                        ctx.fillRect(
                            element.x + element.width * 0.15,
                            element.y - element.height * 0.5,
                            element.width * 0.7,
                            4
                        );
                        // å·¦ä¾§æŸ±å­
                        ctx.fillRect(
                            element.x + element.width * 0.2,
                            element.y - element.height * 0.5,
                            5,
                            element.height * 0.5 - 5
                        );
                        // å³ä¾§æŸ±å­
                        ctx.fillRect(
                            element.x + element.width * 0.8 - 5,
                            element.y - element.height * 0.5,
                            5,
                            element.height * 0.5 - 5
                        );
                    }
                }
            }
            
            // Update and draw each firework
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const fw = fireworks[i];
                
                if (!fw.exploded) {
                    // Draw rocket in upward trajectory
                    fw.y -= fw.speed;
                    
                    // Create rocket trail
                    fw.trailTimer++;
                    if (fw.trailTimer > 2) {
                        fw.trailTimer = 0;
                        // Add trail particles
                        for (let j = 0; j < 4; j++) {
                            fw.particles.push({
                                x: fw.x + (Math.random() * 2 - 1),
                                y: fw.y + (Math.random() * 2 - 1) + 5,
                                vx: Math.random() * 1.5 - 0.75,
                                vy: Math.random() * 1.5 + 1.5,
                                size: Math.random() * 3 + 1,
                                color: '#FFA500',
                                alpha: 1,
                                isTrail: true
                            });
                        }
                    }
                    
                    // Draw the rocket body with glow effect
                    ctx.save();
                    ctx.shadowColor = fw.color;
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(fw.x, fw.y, 2, 6);
                    ctx.restore();
                    
                    // Check if rocket should explode
                    if (fw.y <= fw.targetY) {
                        fw.exploded = true;
                        
                        // çƒŸèŠ±çˆ†ç‚¸éŸ³æ•ˆ
                        // (å¦‚æœéœ€è¦æ·»åŠ éŸ³æ•ˆï¼Œå¯ä»¥åœ¨è¿™é‡Œ)
                        
                        // æ ¹æ®ç‰¹æ®Šæ•ˆæœåˆ›å»ºç²’å­
                        if (fw.specialEffect === "starburst") {
                            // æ˜Ÿçˆ†æ•ˆæœ - æ”¾å°„çŠ¶
                            const particleCount = 120;
                            const arms = 16;
                            
                            for (let arm = 0; arm < arms; arm++) {
                                const baseAngle = (arm / arms) * Math.PI * 2;
                                
                                for (let j = 0; j < particleCount / arms; j++) {
                                    const angle = baseAngle + (Math.random() * 0.1 - 0.05);
                                    const speed = 1 + Math.random() * 4;
                                    
                                    const hueVariation = (Math.random() * 20) - 10;
                                    const particleColor = `hsla(${fw.baseHue + hueVariation}, 100%, 60%, 1)`;
                                    
                                    fw.particles.push({
                                        x: fw.x,
                                        y: fw.y,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed,
                                        size: Math.random() * 3 + 2,
                                        color: particleColor,
                                        alpha: 1,
                                        isTrail: false,
                                        decay: 0.01 + Math.random() * 0.01
                                    });
                                }
                            }
                        }
                        else if (fw.specialEffect === "ring") {
                            // ç¯å½¢æ•ˆæœ
                            const particleCount = 150;
                            const ringRadius = 3 + Math.random() * 2;
                            
                            for (let j = 0; j < particleCount; j++) {
                                const angle = (j / particleCount) * Math.PI * 2;
                                const speed = ringRadius;
                                
                                const hueVariation = (j / particleCount) * 30;
                                const particleColor = `hsla(${fw.baseHue + hueVariation}, 100%, 60%, 1)`;
                                
                                fw.particles.push({
                                    x: fw.x,
                                    y: fw.y,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed,
                                    size: Math.random() * 2.5 + 1.5,
                                    color: particleColor,
                                    alpha: 1,
                                    isTrail: false,
                                    decay: 0.005 + Math.random() * 0.005
                                });
                            }
                        }
                        else if (fw.specialEffect === "heart") {
                            // å¿ƒå½¢æ•ˆæœ
                            const particleCount = 160;
                            const heartSize = 8;
                            
                            for (let j = 0; j < particleCount; j++) {
                                const t = (j / particleCount) * Math.PI * 2;
                                
                                // å¿ƒå½¢æ–¹ç¨‹
                                const x = 16 * Math.sin(t) * Math.sin(t) * Math.sin(t);
                                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                                
                                const hueVariation = Math.abs(t) * 5;
                                const particleColor = `hsla(${fw.baseHue + hueVariation}, 100%, 70%, 1)`;
                                
                                fw.particles.push({
                                    x: fw.x,
                                    y: fw.y,
                                    vx: x * heartSize * 0.08,
                                    vy: -y * heartSize * 0.08,
                                    size: Math.random() * 3 + 1.5,
                                    color: particleColor,
                                    alpha: 1,
                                    isTrail: false,
                                    decay: 0.007 + Math.random() * 0.005
                                });
                            }
                        }
                        else if (fw.specialEffect === "willow") {
                            // æŸ³æ ‘æ•ˆæœ - ä¸‹å‚çš„ç²’å­
                            const particleCount = 200;
                            
                            for (let j = 0; j < particleCount; j++) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 1 + Math.random() * 5;
                                
                                // é»„è‰²åˆ°ç™½è‰²çš„æ¸å˜
                                const brightness = 70 + Math.random() * 30;
                                const particleColor = `hsla(${fw.baseHue}, 100%, ${brightness}%, 1)`;
                                
                                fw.particles.push({
                                    x: fw.x,
                                    y: fw.y,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed,
                                    gravity: 0.05 + Math.random() * 0.05, // æ›´é«˜çš„é‡åŠ›
                                    size: Math.random() * 3 + 1,
                                    color: particleColor,
                                    alpha: 1,
                                    isTrail: false,
                                    decay: 0.003 + Math.random() * 0.002
                                });
                            }
                        }
                        else if (fw.specialEffect === "chrysanthemum") {
                            // èŠèŠ±æ•ˆæœ - å¤šå±‚æ¬¡çˆ†ç‚¸
                            const layers = 3 + Math.floor(Math.random() * 2);
                            const particlesPerLayer = 50;
                            
                            for (let layer = 0; layer < layers; layer++) {
                                const speed = 1 + layer * 1.5;
                                const hueOffset = layer * 15;
                                
                                for (let j = 0; j < particlesPerLayer; j++) {
                                    const angle = (j / particlesPerLayer) * Math.PI * 2;
                                    const particleColor = `hsla(${fw.baseHue + hueOffset}, 100%, 60%, 1)`;
                                    
                                    fw.particles.push({
                                        x: fw.x,
                                        y: fw.y,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed,
                                        size: Math.random() * 3 + 1.5,
                                        color: particleColor,
                                        alpha: 1,
                                        isTrail: false,
                                        decay: 0.007 + Math.random() * 0.005
                                    });
                                }
                            }
                        }
                        else {
                            // æ ‡å‡†çˆ†ç‚¸æ•ˆæœ - ä½†æ›´åŠ ä¸°å¯Œ
                            const particleCount = 120 + Math.floor(Math.random() * 80);
                            
                            for (let j = 0; j < particleCount; j++) {
                                // åˆ›å»º360åº¦å›¾æ¡ˆçš„çˆ†ç‚¸ç²’å­
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 1 + Math.random() * 4;
                                
                                // åœ¨åŒä¸€çƒŸèŠ±å†…éƒ¨çš„é¢œè‰²å˜åŒ–
                                const hueVariation = (Math.random() * 30) - 15;
                                const brightness = 60 + Math.random() * 20;
                                const particleColor = `hsla(${fw.baseHue + hueVariation}, 100%, ${brightness}%, 1)`;
                                
                                fw.particles.push({
                                    x: fw.x,
                                    y: fw.y,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed,
                                    size: Math.random() * 3 + 1.5,
                                    color: particleColor,
                                    alpha: 1,
                                    isTrail: false,
                                    decay: 0.01 + Math.random() * 0.01
                                });
                            }
                        }
                    }
                }
                
                // Update and draw particle effects
                for (let j = fw.particles.length - 1; j >= 0; j--) {
                    const p = fw.particles[j];
                    
                    // Update particle position
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    // Apply gravity to explosion particles
                    if (!p.isTrail) {
                        p.vy += p.gravity || 0.05; // é»˜è®¤é‡åŠ›æˆ–è‡ªå®šä¹‰é‡åŠ›
                    }
                    
                    // Fade particles
                    p.alpha -= p.isTrail ? 0.1 : (p.decay || 0.01);
                    
                    // Draw particle with glow effect
                    ctx.save();
                    ctx.globalAlpha = p.alpha;
                    if (!p.isTrail) {
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = 5;
                    }
                    ctx.fillStyle = p.isTrail ? 'rgba(255, 165, 0, ' + p.alpha + ')' : p.color;
                    
                    // ä¸åŒå½¢çŠ¶çš„ç²’å­
                    if (Math.random() > 0.9 && !p.isTrail) {
                        // å¶å°”ç»˜åˆ¶æ˜Ÿå½¢ç²’å­
                        const size = p.size * 1.2;
                        drawStar(p.x, p.y, 5, size, size / 2);
                    } else {
                        // åœ†å½¢ç²’å­
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                    
                    // Remove faded particles
                    if (p.alpha <= 0) {
                        fw.particles.splice(j, 1);
                    }
                }
                
                // Remove fireworks with no particles left and that have exploded
                if (fw.particles.length === 0 && fw.exploded) {
                    fireworks.splice(i, 1);
                }
            }
            
            // ç»˜åˆ¶å…¨åœºæ™¯å…‰ç…§æ•ˆæœ
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const fw = fireworks[i];
                if (fw.exploded) {
                    // ä¸ºçˆ†ç‚¸çš„çƒŸèŠ±æ·»åŠ æ•´ä½“å…‰ç…§
                    const particleCount = fw.particles.length;
                    if (particleCount > 0) {
                        // è®¡ç®—çˆ†ç‚¸ä¸­å¿ƒ
                        let centerX = 0;
                        let centerY = 0;
                        for (const p of fw.particles) {
                            centerX += p.x;
                            centerY += p.y;
                        }
                        centerX /= particleCount;
                        centerY /= particleCount;
                        
                        // å¢åŠ æ•´ä½“å…‰æ™•
                        const glow = ctx.createRadialGradient(
                            centerX, centerY, 0,
                            centerX, centerY, 150
                        );
                        // ä»çƒŸèŠ±é¢œè‰²åˆ°é€æ˜
                        glow.addColorStop(0, `hsla(${fw.baseHue}, 100%, 60%, 0.2)`);
                        glow.addColorStop(1, `hsla(${fw.baseHue}, 100%, 60%, 0)`);
                        
                        ctx.fillStyle = glow;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, 150, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // Randomly launch new fireworks - é™ä½å‘å°„é¢‘ç‡å’Œæœ€å¤§æ•°é‡
            if (Math.random() < 0.03 && fireworks.length < 10) {
                launchFirework();
            }
            
            // Add overall glow effect to the scene
            ctx.fillStyle = 'rgba(255, 200, 100, 0.005)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // ç»˜åˆ¶æ˜Ÿå½¢å‡½æ•°
        function drawStar(x, y, points, outerRadius, innerRadius) {
            ctx.beginPath();
            
            for (let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i * Math.PI) / points;
                
                ctx.lineTo(
                    x + radius * Math.sin(angle),
                    y + radius * Math.cos(angle)
                );
            }
            
            ctx.closePath();
            ctx.fill();
        }
        
        // è¾…åŠ©å‡½æ•° - ç»˜åˆ¶æœˆäº®å’Œæ˜Ÿæ˜Ÿ
        function drawMoonAndStars() {
            // ç»˜åˆ¶æœˆäº®
            ctx.fillStyle = 'rgba(255, 255, 240, 0.9)';
            ctx.beginPath();
            ctx.arc(canvas.width * 0.85, canvas.height * 0.15, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // æœˆäº®å…‰æ™•
            const moonGlow = ctx.createRadialGradient(
                canvas.width * 0.85, canvas.height * 0.15, 25,
                canvas.width * 0.85, canvas.height * 0.15, 80
            );
            moonGlow.addColorStop(0, 'rgba(255, 255, 240, 0.3)');
            moonGlow.addColorStop(1, 'rgba(255, 255, 240, 0)');
            ctx.fillStyle = moonGlow;
            ctx.beginPath();
            ctx.arc(canvas.width * 0.85, canvas.height * 0.15, 80, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
            for (let i = 0; i < 80; i++) {
                const x = (i * 21) % canvas.width;
                const y = ((i * 31) % 180) + 5;
                const starSize = 0.5 + Math.random() * 1.5;
                const twinkle = Math.sin(frameCount * 0.02 + i) * 0.5 + 0.5;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + twinkle * 0.7})`;
                ctx.beginPath();
                
                // æœ‰æ—¶ç»˜åˆ¶é—ªäº®çš„æ˜Ÿæ˜Ÿ
                if (i % 12 === 0) {
                    drawStar(x, y, 4, starSize * 1.5, starSize * 0.6);
                } else {
                    ctx.arc(x, y, starSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Event listeners
        startBtn.addEventListener('click', function() {
            startScreen.style.display = 'none';
            resetGame();
            gameLoop();
        });

        restartBtn.addEventListener('click', () => {
            gameOverScreen.style.display = 'none';
            gameRunning = true;
            score = 0;
            scoreDisplay.textContent = '0';  // æ·»åŠ è¿™è¡Œæ¥æ›´æ–°æ˜¾ç¤ºçš„é‡‘ç‰Œæ•°é‡
            teaCount = 2;
            document.getElementById('tea-count').textContent = teaCount;
            distance = 0;
            distanceDisplay.textContent = '0';
            gameSpeed = 5;
            obstacles = [];
            medals = [];
            player.y = GROUND_Y;
            player.yVelocity = 0;
            player.jumping = false;
            player.invincible = false;
            player.invincibleTimer = 0;
            frameCount = 0;
            lastMilestone = 0;
            currentBgStage = 0;
            activeSceneName = null;
            gameLoop();
        });

        jumpBtn.addEventListener('touchstart', jump);
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameRunning) {
                jump();
            } else if (e.code === 'Space' && !gameRunning && !gameOverScreen.style.display === 'flex') {
                startGame();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                endJump();
            }
        });
        
        canvas.addEventListener('mousedown', () => {
            if (gameRunning) {
                jump();
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            endJump();
        });
        
        // Mobile touch events
        jumpBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameRunning) {
                jump();
            }
        });
        
        jumpBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            endJump();
        });

        // Jump variables
        let jumpKeyPressed = false;
        let jumpPressTime = 0;
        let maxJumpHoldTime = 350; // Maximum time in ms to hold for full jump power
        let minJumpForce = 12;
        let maxJumpForce = 18;
        let jumpFeedbackActive = false;
        let jumpFeedbackTime = 0;

        function jump() {
            if (!player.jumping) {
                player.jumping = true;
                player.jumpTimeStart = Date.now();
                player.yVelocity = -player.jumpForce;
                player.jumpPower = 0;
            }
        }

        function endJump() {
            if (jumpKeyPressed) {
                jumpKeyPressed = false;
                
                // Calculate how long the jump button was held
                const holdTime = Math.min(Date.now() - player.jumpTimeStart, player.maxJumpHoldTime);
                const jumpPower = minJumpForce + ((maxJumpForce - minJumpForce) * (holdTime / player.maxJumpHoldTime));
                
                // Apply the calculated jump force (only if it's more powerful than current velocity)
                if (-jumpPower < player.yVelocity) {
                    player.yVelocity = -jumpPower;
                }
            }
        }

        // å½“å‰åœºæ™¯è¿‡æ¸¡å˜é‡
        let sceneFade = {
            active: false,
            fromScene: null,
            toScene: null,
            progress: 0,
            duration: 60  // åœºæ™¯è¿‡æ¸¡æŒç»­60å¸§ï¼ˆçº¦1ç§’ï¼‰
        };
        
        // æ”¹è¿›çš„åœºæ™¯æ¿€æ´»å‡½æ•°ï¼Œæ·»åŠ è¿‡æ¸¡æ•ˆæœ
        function activateScene(sceneName) {
            // å¦‚æœå·²ç»æ˜¯å½“å‰åœºæ™¯ï¼Œä¸åšä»»ä½•å¤„ç†
            if (activeSceneName === sceneName) return;
            
            // è®¾ç½®åœºæ™¯è¿‡æ¸¡
            sceneFade.active = true;
            sceneFade.fromScene = activeSceneName;
            sceneFade.toScene = sceneName;
            sceneFade.progress = 0;
            
            // è®¾ç½®æ–°çš„æ¿€æ´»åœºæ™¯
            activeSceneName = sceneName;
            
            // è®¾ç½®æ–°åœºæ™¯çš„åˆå§‹çŠ¶æ€
            for (const element of bgElements) {
                if (element.name === sceneName) {
                    element.setup();
                }
            }
        }

        // åˆ‡æ¢åœºæ™¯
        function switchScene(newScene) {
            // åªæœ‰åœ¨åœºæ™¯çœŸæ­£å˜åŒ–æ—¶æ‰æ‰§è¡Œ
            if (gameScene !== newScene) {
                gameScene = newScene;
                
                // é‡ç½®èƒŒæ™¯ä½ç½®
                let bgX = 0;
                
                // é‡ç½®éšœç¢ç‰©
                obstacles = [];
                
                // æ ¹æ®åœºæ™¯åˆ›å»ºèƒŒæ™¯äº‘æœµ
                createClouds();
            }
        }
        
        // åœºæ™¯æ£€æŸ¥å’Œåˆ‡æ¢
        function checkAndSwitchScene() {
            // åŸºäºåˆ†æ•°åˆ‡æ¢åœºæ™¯ - è°ƒæ•´ä¸º3000ç±³åˆ‡æ¢
            if (distance < 3000) {
                switchScene('sakura');
            } else if (distance < 6000) {
                switchScene('pirate');
            } else {
                switchScene('egypt');
            }
        }
        
        // å¤–æ˜Ÿäººé£èˆ¹
        let ufo = {
            x: -80, // ä»å±å¹•å·¦ä¾§å¼€å§‹
            y: 120,
            width: 60,
            height: 30,
            speed: 0.8,
            beamActive: false,
            beamTimer: 0,
            beamDuration: 150,
            beamCooldown: 0,
            lights: [],
            direction: 1, // 1å‘å³ç§»åŠ¨ï¼Œ-1å‘å·¦ç§»åŠ¨
            hover: 0
        };
        
        // åˆå§‹åŒ–é£èˆ¹çš„ç¯å…‰
        for (let i = 0; i < 8; i++) {
            ufo.lights.push({
                angle: i * (Math.PI * 2 / 8),
                color: `hsl(${i * 45}, 100%, 60%)`,
                phase: Math.random() * Math.PI * 2
            });
        }
        
        // ç»˜åˆ¶UFO
        function drawUFO() {
            if (activeSceneName) return; // åªåœ¨åˆå§‹å¤œç©ºæ˜¾ç¤º
            
            // æ›´æ–°UFOä½ç½®
            ufo.hover = Math.sin(frameCount * 0.05) * 5; // æ‚¬æµ®æ•ˆæœ
            ufo.x += ufo.speed * ufo.direction;
            ufo.y = 120 + ufo.hover;
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦æ”¹å˜æ–¹å‘
            if (ufo.x > canvas.width + 80) {
                ufo.direction = -1; // å‘å·¦ç§»åŠ¨
            } else if (ufo.x < -80) {
                ufo.direction = 1; // å‘å³ç§»åŠ¨
            }
            
            // æ§åˆ¶å…‰æŸ
            if (ufo.beamCooldown > 0) {
                ufo.beamCooldown--;
            } else if (!ufo.beamActive && Math.random() < 0.005) {
                ufo.beamActive = true;
                ufo.beamTimer = ufo.beamDuration;
            }
            
            if (ufo.beamActive) {
                ufo.beamTimer--;
                if (ufo.beamTimer <= 0) {
                    ufo.beamActive = false;
                    ufo.beamCooldown = 300; // å†·å´æ—¶é—´
                }
            }
            
            // ç»˜åˆ¶é£ç¢Ÿä¸»ä½“
            ctx.save();
            ctx.translate(ufo.x + ufo.width/2, ufo.y + ufo.height/2);
            if (ufo.direction === -1) {
                ctx.scale(-1, 1); // å·¦å³ç¿»è½¬
            }
            
            // èˆ±ä½“ - æ¤­åœ†å½¢åº•éƒ¨
            ctx.fillStyle = '#3A478F';
            ctx.beginPath();
            ctx.ellipse(0, 10, ufo.width/2, ufo.height/3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // èˆ±ä½“ä¸Šéƒ¨ - åœ†é¡¶
            ctx.fillStyle = '#596BB3';
            ctx.beginPath();
            ctx.ellipse(0, 0, ufo.width/3, ufo.height/3, 0, 0, Math.PI, true);
            ctx.fill();
            
            // æœºèˆ±çª—æˆ· - é€æ˜åœ†é¡¶
            ctx.fillStyle = 'rgba(144, 238, 255, 0.7)';
            ctx.beginPath();
            ctx.ellipse(0, 0, ufo.width/4, ufo.height/4, 0, 0, Math.PI, true);
            ctx.fill();
            
            // èˆ±ä½“ä¸­éƒ¨åˆ†éš”çº¿
            ctx.strokeStyle = '#252A52';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-ufo.width/2, 10);
            ctx.lineTo(ufo.width/2, 10);
            ctx.stroke();
            
            // ç»˜åˆ¶ç¯å…‰
            for (const light of ufo.lights) {
                const flickerIntensity = Math.sin(frameCount * 0.2 + light.phase) * 0.5 + 0.5;
                ctx.fillStyle = light.color;
                
                const radius = ufo.width/2 - 3;
                const x = Math.cos(light.angle) * radius;
                const y = Math.sin(light.angle) * (ufo.height/3 - 2) + 10;
                
                ctx.beginPath();
                ctx.arc(x, y, 2 + flickerIntensity * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // ç¯å…‰å‘å…‰æ•ˆæœ
                ctx.fillStyle = `${light.color}${Math.floor(flickerIntensity * 90).toString(16).padStart(2, '0')}`;
                ctx.beginPath();
                ctx.arc(x, y, 4 + flickerIntensity * 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
            
            // ç»˜åˆ¶å…‰æŸ
            if (ufo.beamActive) {
                const beamStartX = ufo.x + ufo.width/2;
                const beamStartY = ufo.y + ufo.height/2 + 5;
                const beamEndY = canvas.height - 30;
                const beamWidth = 25 + Math.sin(frameCount * 0.1) * 5;
                
                // åˆ›å»ºå…‰æŸæ¸å˜
                const beamGradient = ctx.createLinearGradient(beamStartX, beamStartY, beamStartX, beamEndY);
                beamGradient.addColorStop(0, 'rgba(144, 238, 255, 0.8)');
                beamGradient.addColorStop(1, 'rgba(144, 238, 255, 0)');
                
                // ç»˜åˆ¶å…‰æŸ
                ctx.fillStyle = beamGradient;
                ctx.beginPath();
                ctx.moveTo(beamStartX - beamWidth/2, beamStartY);
                ctx.lineTo(beamStartX + beamWidth/2, beamStartY);
                ctx.lineTo(beamStartX + beamWidth, beamEndY);
                ctx.lineTo(beamStartX - beamWidth, beamEndY);
                ctx.closePath();
                ctx.fill();
                
                // å…‰æŸå†…éƒ¨çº¿æ¡
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    const linePos = beamStartY + (i * (beamEndY - beamStartY) / 5);
                    const lineWidth = beamWidth/2 + (i * beamWidth / 5);
                    
                    ctx.beginPath();
                    ctx.moveTo(beamStartX - lineWidth, linePos);
                    ctx.lineTo(beamStartX + lineWidth, linePos);
                    ctx.stroke();
                }
                
                // å…‰æŸç²’å­æ•ˆæœ
                if (frameCount % 3 === 0) {
                    for (let i = 0; i < 2; i++) {
                        const particleX = beamStartX + (Math.random() - 0.5) * beamWidth;
                        const particleY = beamStartY + Math.random() * (beamEndY - beamStartY);
                        createParticles(particleX, particleY, 'rgba(144, 238, 255, 0.8)', 1);
                    }
                }
            }
        }

        // åˆ›å»ºäº‘æœµ
        function createClouds() {
            clouds = [];
            const cloudCount = 5 + Math.floor(Math.random() * 3);
            
            for (let i = 0; i < cloudCount; i++) {
                // åˆ›å»ºæ›´ç¾è§‚çš„äº‘æœµ
                const cloud = {
                    x: Math.random() * canvas.width,
                    y: 50 + Math.random() * 100,
                    width: 80 + Math.random() * 120,
                    height: 30 + Math.random() * 20,
                    speed: (Math.random() * 0.5 + 0.2) * gameSpeed * 0.2,
                    puffs: [] // äº‘æœµç»„æˆéƒ¨åˆ†
                };
                
                // ä¸ºæ¯æœµäº‘åˆ›å»ºå¤šä¸ªç»’æ¯›çŠ¶çš„éƒ¨åˆ†
                const puffCount = 4 + Math.floor(Math.random() * 3);
                for (let j = 0; j < puffCount; j++) {
                    // è®©æ¯ä¸ªéƒ¨åˆ†æŒ‰ç…§æ¯”ä¾‹åˆ†å¸ƒ
                    const puffSize = cloud.height * (0.6 + Math.random() * 0.7);
                    // ç»™æ¯ä¸ªéƒ¨åˆ†ä¸€ä¸ªåˆç†çš„åˆå§‹ä½ç½®ï¼Œå½¢æˆè‡ªç„¶çš„äº‘å½¢çŠ¶
                    cloud.puffs.push({
                        x: cloud.x + (j / (puffCount - 1)) * cloud.width,
                        y: cloud.y + Math.sin(j * 0.8) * (cloud.height * 0.2),
                        size: puffSize
                    });
                }
                
                clouds.push(cloud);
            }
        }

        function drawClouds() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            
            for (const cloud of clouds) {
                // ç§»åŠ¨äº‘æœµ
                cloud.x -= cloud.speed;
                
                // é‡ç½®ç¦»å¼€å±å¹•çš„äº‘æœµ
                if (cloud.x + cloud.width < 0) {
                    cloud.x = canvas.width;
                    cloud.y = 50 + Math.random() * 100;
                    // é‡æ–°è®¡ç®—äº‘æœµç»’æ¯›éƒ¨åˆ†çš„ä½ç½®
                    for (let i = 0; i < cloud.puffs.length; i++) {
                        cloud.puffs[i].y = cloud.y + Math.sin(i * 0.8) * (cloud.height * 0.2);
                    }
                }
                
                // ç»˜åˆ¶æ”¹è¿›çš„å¤šç»’æ¯›çŠ¶äº‘æœµ
                for (const puff of cloud.puffs) {
                    // ç»˜åˆ¶åœ†å½¢ç»’æ¯›
                    ctx.beginPath();
                    ctx.arc(puff.x, puff.y, puff.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function startGame() {
            try {
                gameRunning = true;
                gameOverScreen.style.display = 'none';
                startScreen.style.display = 'none';
            // é‡ç½®æ¸¸æˆçŠ¶æ€
                distance = 0;
                gameSpeed = 5;
                score = 0;
                obstacles = [];
                medals = [];
                teaCount = 2;
        
        // é‡ç½®èƒŒæ™¯çŠ¶æ€
                if (currentMap === "newMap") {
                currentBackgroundState.current = 'bg1';
                currentBackgroundState.next = null;
                currentBackgroundState.fadeProgress = 0;
                currentBackgroundState.isFading = false;
                currentBackgroundState.lastChangeDistance = 0;
                }
        
        // é‡ç½®ç©å®¶çŠ¶æ€
                player.x = 50;
                player.y = GROUND_Y;
                player.jumping = false;
                player.yVelocity = 0;
                player.invincible = false;
                player.invincibleTimer = 0;
        
                requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error("å¯åŠ¨æ¸¸æˆé”™è¯¯:", error);
                gameRunning = false;
            }
        }

        function restartGame() {
            startGame();
        }

        function gameOver() {
            gameRunning = false;
            gameoverSound.currentTime = 0;
            gameoverSound.play();
            
            // æ£€æŸ¥è§’è‰²è§£é”æ¡ä»¶
            if (score >= UNLOCK_SCORE && !window.characterUnlocked.sprite02) {
                window.characterUnlocked.sprite02 = true;
                saveUnlockStatus();

                setTimeout(() => {
                    showUnlockNotification('å°å˜å°å“å·²è§£é”ï¼');
                }, 1000);
            }

            // æ·»åŠ ï¼šæ£€æŸ¥åœ°å›¾è§£é”æ¡ä»¶
            if (score >= MAP_UNLOCK_SCORE && !mapUnlocked.newMap) {
                mapUnlocked.newMap = true;
                saveMapUnlockStatus();
                
                setTimeout(() => {
                    showUnlockNotification('åœ°å›¾ï¼šæœ«æ—¥æ—…è¡Œå·²è§£é”ï¼');
                }, 1500);  // å»¶è¿Ÿæ˜¾ç¤ºï¼Œé¿å…ä¸è§’è‰²è§£é”æç¤ºé‡å 
    }
            if (score > highScore) {
                highScore = score;
            }
            
            finalScoreDisplay.textContent = `é‡‘ç‰Œæ•°é‡: ${score}`;
            highScoreDisplay.textContent = `æœ€é«˜é‡‘ç‰Œæ•°é‡: ${highScore}`;
            finalDistanceDisplay.textContent = `è·ç¦»: ${distance}ç±³`;
            
            updateCharacterSelectionUI(); 
            // ç§»é™¤æ¸¸æˆç»“æŸç•Œé¢ä¸­çš„æ‰€æœ‰å…ƒç´ ï¼Œä»¥ä¾¿é‡æ–°æ’åˆ—
            const restartBtn = document.getElementById('restart-btn');
            const authorCredit = gameOverScreen.querySelector('.author-credit') || gameOverScreen.querySelector('div[style*="margin-top: 15px"]');
    
    // ä¸´æ—¶ä¿å­˜è¿™äº›å…ƒç´ 
            if (restartBtn) restartBtn.remove();
            if (authorCredit) authorCredit.remove();

            // æ·»åŠ ï¼šç§»é™¤ä¹‹å‰çš„åœ°å›¾é€‰æ‹©åŒºåŸŸï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            const existingMapSelection = gameOverScreen.querySelector('.map-selection-container');
            if (existingMapSelection) {
                existingMapSelection.remove();
    }
    
    // æ·»åŠ ï¼šåˆ›å»ºåœ°å›¾é€‰æ‹©åŒºåŸŸ
            const mapSelectionContainer = document.createElement('div');
            mapSelectionContainer.className = 'map-selection-container';
            mapSelectionContainer.style.marginTop = '3px';
            mapSelectionContainer.style.marginBottom = '3px'; // æ·»åŠ åº•éƒ¨é—´è·
            mapSelectionContainer.style.display = 'flex';
            mapSelectionContainer.style.flexDirection = 'column';
            mapSelectionContainer.style.alignItems = 'center';
    
    // æ·»åŠ ï¼šåˆ›å»ºæ ‡é¢˜
            const mapSelectionTitle = document.createElement('div');
            mapSelectionTitle.textContent = 'é€‰æ‹©åœ°å›¾';
            mapSelectionTitle.style.fontSize = '16px';
            mapSelectionTitle.style.marginBottom = '3px';
            mapSelectionTitle.style.color = 'var(--accent-light)'; // ä¸è§’è‰²é€‰æ‹©æ ‡é¢˜é¢œè‰²ä¸€è‡´
            mapSelectionContainer.appendChild(mapSelectionTitle);
    
    // æ·»åŠ ï¼šåˆ›å»ºæŒ‰é’®å®¹å™¨
            const mapButtonsContainer = document.createElement('div');
            mapButtonsContainer.style.display = 'flex';
            mapButtonsContainer.style.gap = '8px';
    
    // æ·»åŠ ï¼šåˆ›å»ºåœ°å›¾æŒ‰é’®
            Object.keys(mapConfigs).forEach(mapKey => {
                const mapConfig = mapConfigs[mapKey];
                const mapButton = document.createElement('div');
                mapButton.className = 'map-button';
                mapButton.textContent = mapConfig.name;
                mapButton.style.padding = '8px 15px';
                mapButton.style.position = 'relative';  // æ·»åŠ ï¼šè®¾ç½®ç›¸å¯¹å®šä½ï¼Œç”¨äºæ·»åŠ è§£é”æç¤º

                // æ·»åŠ ï¼šæ£€æŸ¥åœ°å›¾æ˜¯å¦è§£é”
                const isUnlocked = mapUnlocked[mapKey];
    
                if (isUnlocked) {
        // å·²è§£é”åœ°å›¾æ ·å¼
                    mapButton.style.backgroundColor = currentMap === mapKey ? 'var(--primary-color)' : 'var(--background-light)';
                    mapButton.style.cursor = 'pointer';
                } else {
        // æœªè§£é”åœ°å›¾æ ·å¼
                    mapButton.style.backgroundColor = 'rgba(80, 80, 80, 0.5)';
                    mapButton.style.cursor = 'not-allowed';
                    mapButton.style.color = 'rgba(255, 255, 255, 0.6)';
        
        // æ·»åŠ è§£é”æç¤º
                    const unlockHint = document.createElement('div');
                    unlockHint.textContent = `æ”¶é›†${mapConfig.unlockScore}å—é‡‘ç‰Œè§£é”`;
                    unlockHint.style.position = 'absolute';
                    unlockHint.style.bottom = '-20px';
                    unlockHint.style.left = '0';
                    unlockHint.style.width = '100%';
                    unlockHint.style.fontSize = '12px';
                    unlockHint.style.color = 'var(--accent-light)';
                    mapButton.appendChild(unlockHint);
    }
                mapButton.style.backgroundColor = currentMap === mapKey ? 'var(--primary-color)' : 'var(--background-light)';
                mapButton.style.borderRadius = '5px';
                mapButton.style.cursor = 'pointer';
                mapButton.style.transition = 'all 0.2s';
        
        // æ·»åŠ ï¼šæ·»åŠ åœ°å›¾æè¿°æç¤º
                mapButton.title = mapConfig.description;
        
        // æ·»åŠ ï¼šæ·»åŠ ç‚¹å‡»äº‹ä»¶
                mapButton.addEventListener('click', () => {
                // æ·»åŠ ï¼šæ£€æŸ¥åœ°å›¾æ˜¯å¦è§£é”
                    if (!isUnlocked) {
                // æœªè§£é”æ—¶æ·»åŠ æŠ–åŠ¨æ•ˆæœ
                        mapButton.classList.add('shake');
                        setTimeout(() => {
                            mapButton.classList.remove('shake');
                        }, 500);
            
            // æ˜¾ç¤ºæœªè§£é”æç¤º
                        showMilestoneNotification(`æ”¶é›†${mapConfig.unlockScore}å—é‡‘ç‰Œè§£é”æ­¤åœ°å›¾`, '#FF6B6B');
                        return;
                    }
            
            // æ·»åŠ ï¼šæ›´æ–°å½“å‰é€‰æ‹©çš„åœ°å›¾
                    currentMap = mapKey;
            
            // æ·»åŠ ï¼šæ›´æ–°æŒ‰é’®æ ·å¼
                    document.querySelectorAll('.map-button').forEach(btn => {
                        if (btn.classList.contains('map-button')) {
                        btn.style.backgroundColor = 'var(--background-light)';
                        }
                    });
                mapButton.style.backgroundColor = 'var(--primary-color)';
            
            // æ·»åŠ ï¼šæ˜¾ç¤ºåœ°å›¾åˆ‡æ¢æç¤º
                showMilestoneNotification(`å·²åˆ‡æ¢åˆ°${mapConfig.name}ï¼`, '#FFD700');
        });
        
        mapButtonsContainer.appendChild(mapButton);
    });
    
    mapSelectionContainer.appendChild(mapButtonsContainer);
    gameOverScreen.appendChild(mapSelectionContainer);
     // é‡æ–°æ·»åŠ "å†ç©ä¸€æ¬¡"æŒ‰é’®å’Œä½œè€…ç½²å
    if (restartBtn) gameOverScreen.appendChild(restartBtn);
    if (authorCredit) gameOverScreen.appendChild(authorCredit);
    
            gameOverScreen.style.display = 'flex';
            
            cancelAnimationFrame(animationId);
            animationId = null;
        }

        function updateCharacterSelection() {
            const characterOptions = document.querySelectorAll('.character-option');
            characterOptions.forEach(option => {
                const characterType = option.getAttribute('data-character');
                option.classList.toggle('selected', characterType === currentCharacter);
            });
        }

        function spawnObstacle() {
            // Select obstacle type based on score, randomness, and current distance
            let availableTypes = [];
            let obstacleType, obstacleWidth, obstacleHeight, requiresJump;
            
            // åŸºäºåœºæ™¯é€‰æ‹©éšœç¢ç‰©ç±»å‹
            if (gameScene === 'sakura') {
                const types = [
                    obstacleTypes.HURDLE, 
                    obstacleTypes.POOL, 
                    obstacleTypes.PARALLEL_BARS, 
                    obstacleTypes.WATER_JUMP,
                    obstacleTypes.BALANCE_BEAM
                ];
                obstacleType = types[Math.floor(Math.random() * types.length)];
                
                if (obstacleType === obstacleTypes.HURDLE) {
                    obstacleWidth = 20;
                    obstacleHeight = 40;
                    requiresJump = true;
                } else if (obstacleType === obstacleTypes.POOL) {
                    obstacleWidth = 100;
                    obstacleHeight = 20;
                    requiresJump = Math.random() > 0.3; // æœ‰äº›å¯ä»¥æ»‘è¡Œç©¿è¿‡
                } else if (obstacleType === obstacleTypes.PARALLEL_BARS) {
                    obstacleWidth = 60;
                    obstacleHeight = 50;
                    requiresJump = true;
                } else if (obstacleType === obstacleTypes.WATER_JUMP) {
                    obstacleWidth = 80;
                    obstacleHeight = 25;
                    requiresJump = true;
                } else if (obstacleType === obstacleTypes.BALANCE_BEAM) {
                    obstacleWidth = 120;
                    obstacleHeight = 30;
                    requiresJump = true;
                }
            } 
            else if (gameScene === 'pirate') {
                const types = [
                    obstacleTypes.BARREL, 
                    obstacleTypes.BIRD, 
                    obstacleTypes.CRATE,
                    obstacleTypes.UNEVEN_BARS
                ];
                obstacleType = types[Math.floor(Math.random() * types.length)];
                
                if (obstacleType === obstacleTypes.BARREL) {
                    obstacleWidth = 35;
                    obstacleHeight = 35;
                    requiresJump = true;
                } else if (obstacleType === obstacleTypes.CRATE) {
                    obstacleWidth = 40;
                    obstacleHeight = 40;
                    requiresJump = true;
                } else if (obstacleType === obstacleTypes.UNEVEN_BARS) {
                    obstacleWidth = 70;
                    obstacleHeight = 60;
                    requiresJump = true;
                } else { // BIRD
                    obstacleWidth = 30;
                    obstacleHeight = 20;
                    // é¸Ÿçš„é«˜åº¦æ˜¯éšæœºçš„
                    const birdY = canvas.height - 30 - (50 + Math.random() * 100);
                    requiresJump = birdY < canvas.height - 30 - player.height;
                    
                    // åˆ›å»ºé£é¸Ÿéšœç¢
                    obstacles.push({
                        x: canvas.width,
                        y: birdY,
                        width: obstacleWidth,
                        height: obstacleHeight,
                        type: obstacleType,
                        requiresJump: requiresJump,
                        wingPosition: 0
                    });
                    
                    return; // å·²ç»åˆ›å»ºäº†é¸Ÿéšœç¢ï¼Œç›´æ¥è¿”å›
                }
            } 
            else { // åŸƒåŠåœºæ™¯
                const types = [
                    obstacleTypes.CACTUS, 
                    obstacleTypes.SNAKE,
                    obstacleTypes.HIGH_JUMP,
                    obstacleTypes.POMMEL_HORSE
                ];
                obstacleType = types[Math.floor(Math.random() * types.length)];
                
                if (obstacleType === obstacleTypes.CACTUS) {
                    obstacleWidth = 25;
                    obstacleHeight = 40;
                    requiresJump = true;
                } else if (obstacleType === obstacleTypes.SNAKE) {
                    obstacleWidth = 40;
                    obstacleHeight = 15;
                    requiresJump = Math.random() > 0.4; // æœ‰äº›å¯ä»¥æ»‘è¡Œç©¿è¿‡
                } else if (obstacleType === obstacleTypes.HIGH_JUMP) {
                    obstacleWidth = 10;
                    obstacleHeight = 50;
                    requiresJump = true;
                } else if (obstacleType === obstacleTypes.POMMEL_HORSE) {
                    obstacleWidth = 70;
                    obstacleHeight = 50;
                    requiresJump = true;
                }
            }
            
            // åˆ›å»ºæ ‡å‡†çš„åœ°é¢éšœç¢ç‰©
            obstacles.push({
                x: canvas.width,
                y: canvas.height - 30 - obstacleHeight,
                width: obstacleWidth,
                height: obstacleHeight,
                type: obstacleType,
                requiresJump: requiresJump
            });
        }

        function spawnMedal(forceGold = false) {
            // Check if there's already a gold medal in play - if so, don't spawn another one
            const goldMedalExists = medals.some(medal => medal.type === collectibleTypes.GOLD);
            const teaMedalExists = medals.some(medal => medal.type === collectibleTypes.TEA);
            
            // Only spawn if there's no gold medal and no tea medal already on screen
            // or if we're forcing a gold medal for game start
            if ((goldMedalExists && !forceGold) || (teaMedalExists && !forceGold)) {
                return; // Don't spawn anything if medals already exist
            }
            
            const lastObstacle = obstacles.length > 0 ? obstacles[obstacles.length - 1] : null;
            let medalX = canvas.width;
            let medalY = canvas.height - Math.random() * 120 - 80; // Higher position to make it more accessible
            
            // 15000ç±³åçš„é‡‘ç‰Œæ”¾åœ¨æ›´é«˜ã€æ›´éš¾è·å–çš„ä½ç½®
            if (distance > 15000 && Math.random() < 0.4 && !forceGold) {
                medalY = canvas.height - Math.random() * 180 - 120; // æ›´é«˜çš„ä½ç½®
            }
            
            // If there's an obstacle, make sure medal isn't too close to it
            if (lastObstacle) {
                // If the last obstacle is close to where we want to spawn the medal
                if (Math.abs(lastObstacle.x - medalX) < 180) {
                    // Either place it before or after the obstacle with enough gap
                    if (Math.random() > 0.5) {
                        medalX = lastObstacle.x - 100; // Before obstacle
                    } else {
                        medalX = lastObstacle.x + lastObstacle.width + 100; // After obstacle
                    }
                }
            }
            
            // 15000ç±³åï¼Œå¶å°”åœ¨ä¸¤ä¸ªéšœç¢ç‰©ä¹‹é—´çš„ç©ºéš™æ”¾ç½®é‡‘ç‰Œ
            if (distance > 15000 && obstacles.length >= 2 && Math.random() < 0.3 && !forceGold) {
                const prevObstacle = obstacles[obstacles.length - 2];
                const lastObstacle = obstacles[obstacles.length - 1];
                
                // æ£€æŸ¥ä¸¤ä¸ªéšœç¢ç‰©ä¹‹é—´æ˜¯å¦æœ‰è¶³å¤Ÿç©ºé—´
                if (lastObstacle && prevObstacle && 
                    lastObstacle.x - (prevObstacle.x + prevObstacle.width) > 200) {
                    // åœ¨ä¸­é—´ä½ç½®æ”¾ç½®é‡‘ç‰Œ
                    medalX = prevObstacle.x + prevObstacle.width + 
                             (lastObstacle.x - (prevObstacle.x + prevObstacle.width)) / 2;
                    // å¶å°”åœ¨è¾ƒé«˜ä½ç½®æ”¾ç½®
                    if (Math.random() < 0.5) {
                        medalY = canvas.height - Math.random() * 180 - 120;
                    }
                }
            }
            
            // Decide what type of collectible to spawn
            // Tea is very rare (0.05 chance), only spawn if player has less than 2 teas,
            // we've traveled more than 500 meters, and no tea exists on screen
            if (!forceGold && teaCount < 2 && distance > 500 && Math.random() < 0.05 && !teaMedalExists) {
                // Tea should appear a bit higher for challenge
                medalY = Math.min(medalY, canvas.height - 150);
                
                medals.push({
                    x: medalX,
                    y: medalY,
                    width: medalSize,
                    height: medalSize,
                    type: collectibleTypes.TEA
                });
            } else if (forceGold || !goldMedalExists) {
                // Only spawn gold if no gold medal exists or we're forcing a gold medal
                medals.push({
                    x: medalX,
                    y: medalY,
                    width: medalSize,
                    height: medalSize,
                    type: collectibleTypes.GOLD
                });
            }
        }
        
        // ä½¿ç”¨ç²¾çµå›¾ç»˜åˆ¶ç©å®¶
        function drawPlayer() {
            ctx.save();
            
            const drawX = player.x;
            const drawY = player.y + cameraY;
            
            // æ— æ•ŒçŠ¶æ€ç‰¹æ•ˆ
            if (player.invincible) {
                // å‘å…‰æ•ˆæœ - ä½¿ç”¨èŒ¶ç»¿è‰²
                ctx.shadowColor = 'rgba(152, 251, 152, 0.7)'; // æ”¹ä¸ºæ·¡ç»¿è‰²
                ctx.shadowBlur = 20 + Math.sin(Date.now() / 100) * 5;
                
                // ç»˜åˆ¶å…‰ç¯ - ä½¿ç”¨æ¸å˜è‰²
                const glowSize = 2 + Math.sin(Date.now() / 200) * 0.5;
                ctx.globalAlpha = 0.3;
                
                // åˆ›å»ºå¾„å‘æ¸å˜
                const gradient = ctx.createRadialGradient(
                    drawX + player.width/2, drawY + player.height/2, 0,
                    drawX + player.width/2, drawY + player.height/2, player.width/2 * glowSize
                );
                gradient.addColorStop(0, 'rgba(152, 251, 152, 0.5)');   // å†…åœˆèŒ¶ç»¿è‰²
                gradient.addColorStop(0.6, 'rgba(173, 255, 47, 0.3)');  // ä¸­é—´æ·¡ç»¿è‰²
                gradient.addColorStop(1, 'rgba(50, 205, 50, 0)');       // å¤–åœˆæ·±ç»¿è‰²
                
                ctx.beginPath();
                ctx.arc(drawX + player.width/2, drawY + player.height/2, 
                        player.width/2 * glowSize, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.globalAlpha = 1;
                
                // ç”Ÿæˆæ˜Ÿæ˜Ÿç²’å­ - ä½¿ç”¨èŒ¶ç»¿è‰²ç³»
                if (Math.random() < 0.3) {
                    const colors = [
                        'rgba(152, 251, 152, ', // æ·¡ç»¿è‰²
                        'rgba(173, 255, 47, ',  // é»„ç»¿è‰²
                        'rgba(50, 205, 50, '    // ç»¿è‰²
                    ];
                    player.sparkles.push({
                        x: drawX + Math.random() * player.width,
                        y: drawY + Math.random() * player.height,
                        size: 2 + Math.random() * 3,
                        speed: 1 + Math.random() * 2,
                        angle: Math.random() * Math.PI * 2,
                        life: 1,
                        color: colors[Math.floor(Math.random() * colors.length)] // éšæœºé€‰æ‹©é¢œè‰²
                    });
                }
            }
            
            // æ”¶é›†èŒ¶é“å…·æ—¶çš„é—ªå…‰æ•ˆæœ - æ·»åŠ ç»¿è‰²è°ƒ
            if (player.teaCollectFlash > 0) {
                ctx.globalAlpha = player.teaCollectFlash;
                const flashGradient = ctx.createRadialGradient(
                    drawX + player.width/2, drawY + player.height/2, 0,
                    drawX + player.width/2, drawY + player.height/2, player.width
                );
                flashGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                flashGradient.addColorStop(0.5, 'rgba(152, 251, 152, 0.6)');
                flashGradient.addColorStop(1, 'rgba(50, 205, 50, 0)');
                
                ctx.fillStyle = flashGradient;
                ctx.fillRect(drawX - 20, drawY - 20, player.width + 40, player.height + 40);
                player.teaCollectFlash -= 0.05;
                ctx.globalAlpha = 1;
            }
            
            // è®¾ç½®æ—‹è½¬ä¸­å¿ƒç‚¹å¹¶åº”ç”¨å€¾æ–œ
            ctx.translate(drawX + player.width/2, drawY + player.height/2);
            ctx.rotate(player.bodyTilt * Math.PI / 180);
            ctx.translate(-(drawX + player.width/2), -(drawY + player.height/2));
            
            // æ›´æ–°åŠ¨ç”»å¸§
            if (player.jumping) {
                player.frameX = spriteConfig.jumpFrames.frames[2];
                player.frameY = spriteConfig.jumpFrames.row;
            } else {
                player.animationTimer += player.animationSpeed;
                player.runningPhase += player.animationSpeed;
                const runFrame = Math.floor(player.animationTimer) % spriteConfig.runFrames.frames.length;
                player.frameX = spriteConfig.runFrames.frames[runFrame];
                player.frameY = spriteConfig.runFrames.row;
            }
            
            // ç»˜åˆ¶è§’è‰²
            ctx.drawImage(
                characterSprite,
                player.frameX * spriteConfig.frameWidth,
                player.frameY * spriteConfig.frameHeight,
                spriteConfig.frameWidth,
                spriteConfig.frameHeight,
                drawX,
                drawY,
                player.width,
                player.height
            );
            
            // ç»˜åˆ¶æ˜Ÿæ˜Ÿç²’å­
            player.sparkles = player.sparkles.filter(sparkle => {
                sparkle.y -= sparkle.speed;
                sparkle.x += Math.cos(sparkle.angle) * sparkle.speed;
                sparkle.life -= 0.02;
                
                if (sparkle.life > 0) {
                    ctx.beginPath();
                    ctx.arc(sparkle.x, sparkle.y, sparkle.size, 0, Math.PI * 2);
                    ctx.fillStyle = sparkle.color + sparkle.life + ')';
                    ctx.fill();
                    return true;
                }
                return false;
            });
            
            ctx.restore();
        }

        // æ£€æµ‹æ˜¯å¦ä¸ºç«–å±æ¨¡å¼
        function isPortraitMode() {
            return window.innerHeight > window.innerWidth || canvas.height > canvas.width;
        }

        // è·å–å½“å‰è·³è·ƒé€Ÿåº¦æ–¹å‘ï¼ˆå‘ä¸Šæ˜¯è´Ÿæ•°ï¼‰
        function getJumpDirection() {
            return Math.sign(player.yVelocity);
        }
        
        // åˆ¤æ–­ç©å®¶æ˜¯å¦åœ¨ä¸Šå‡é˜¶æ®µ
        function isPlayerRising() {
            return player.jumping && player.yVelocity < 0;
        }

        function updatePlayer() {
            // ä¿å­˜ä¸Šä¸€å¸§çš„é€Ÿåº¦æ–¹å‘ï¼Œç”¨äºæ£€æµ‹æ–¹å‘å˜åŒ–
            const prevDirection = getJumpDirection();
            
            // Apply gravity
            player.yVelocity += gravity;
            player.y += player.yVelocity;
            
            // åŠ¨æ€ç›¸æœºç³»ç»Ÿï¼ŒåŸºäºç©å®¶çŠ¶æ€çš„æ™ºèƒ½é¢„æµ‹
            const isPortrait = isPortraitMode();
            
            // æ ¹æ®å±å¹•æ–¹å‘è®¾ç½®ä¸åŒçš„é˜ˆå€¼
            // ç«–å±æ¨¡å¼ä¸‹ï¼Œä½¿ç”¨æ›´é«˜çš„ç›¸æœºè§¦å‘é˜ˆå€¼ï¼ˆå±å¹•çš„30-40%ï¼‰
            const cameraThreshold = isPortrait ? canvas.height * 0.4 : canvas.height / 3;
            
            // é¢„æµ‹æ€§ç›¸æœºç³»ç»Ÿï¼šæ ¹æ®ç©å®¶çš„é€Ÿåº¦å’Œä½ç½®æ™ºèƒ½è°ƒæ•´
            
            // å®‰å…¨é¡¶éƒ¨è¾¹è·è°ƒæ•´ - åœ¨ç«–å±æ¨¡å¼ä¸‹ç»™äºˆæ›´å¤šç©ºé—´
            const topMargin = isPortrait ? 40 : 20;
            const currentDirection = getJumpDirection();
            
            // é¢„æµ‹ä¸‹ä¸€å¸§çš„ç©å®¶ä½ç½®ï¼Œé¿å…è§†è§‰å»¶è¿Ÿ
            const predictedY = isPlayerRising() ? 
                player.y + player.yVelocity * 3 : // å‘ä¸Šç§»åŠ¨æ—¶é¢„æµ‹æ›´å¤šï¼Œå‡å°‘å»¶è¿Ÿæ„Ÿ
                player.y + player.yVelocity;
                
            // æé™æƒ…å†µå¤„ç†ï¼šå¦‚æœå³å°†ç¢°åˆ°é¡¶éƒ¨
            if (predictedY - cameraY < topMargin) {
                // ä»é¡¶éƒ¨æä¾›å®‰å…¨è·ç¦»çš„ç›¸æœºä½ç½®
                const safeY = player.y - topMargin;
                // å¹³æ»‘è¿‡æ¸¡
                cameraY = cameraY * 0.8 + safeY * 0.2;
                
                // å¦‚æœé€Ÿåº¦æ–¹å‘å˜åŒ–ï¼Œé¢å¤–æ–½åŠ ç¼“å†²ï¼Œé¿å…é•œå¤´æŠ–åŠ¨
                if (prevDirection !== currentDirection && currentDirection > 0) {
                    // ä¸‹è½å¼€å§‹æ—¶ç¨å¾®å»¶è¿Ÿç›¸æœºä¸‹ç§»
                    cameraY += player.yVelocity * 0.1;
                }
            }
            // æ­£å¸¸ç›¸æœºè·Ÿéšé€»è¾‘ - å½“ç©å®¶ä¸Šå‡åˆ°é˜ˆå€¼åŒºåŸŸå†…
            else if (player.y < cameraThreshold) {
                // è®¡ç®—ç›®æ ‡ç›¸æœºä½ç½®ï¼Œè€ƒè™‘ç«–å±æ¨¡å¼çš„ç‰¹æ®Šå› ç´ 
                const targetY = (cameraThreshold - player.y) * (isPortrait ? 1.15 : 1.0);
                
                // å¹³æ»‘å› å­ï¼šåœ¨ä¸Šå‡å’Œä¸‹è½é˜¶æ®µä½¿ç”¨ä¸åŒçš„å¹³æ»‘å€¼ï¼Œä½¿åŠ¨ä½œæ›´æµç•…
                const smoothFactor = isPlayerRising() ? 
                    (isPortrait ? 5 : 8) : // ä¸Šå‡é˜¶æ®µæ›´å¿«å“åº”
                    (isPortrait ? 10 : 15); // ä¸‹è½é˜¶æ®µæ›´å¹³ç¼“
                
                // æ›´æ–°ç›¸æœºä½ç½®
                cameraY += (targetY - cameraY) / smoothFactor;
            }
            // å¦‚æœç©å®¶åœ¨é˜ˆå€¼ä»¥ä¸‹ï¼Œé€æ¸å›å½’åŸä½
            else if (cameraY > 0) {
                // å¦‚æœå·²æœ‰ç›¸æœºåç§»ï¼Œåˆ™å¹³æ»‘è¿”å›
                const returnSpeed = isPortrait ? 0.05 : 0.03;
                cameraY *= (1 - returnSpeed);
                
                // å½“ç›¸æœºæ¥è¿‘é›¶æ—¶ï¼Œç›´æ¥è®¾ä¸ºé›¶ä»¥é¿å…æå°å€¼æŠ–åŠ¨
                if (cameraY < 0.5) cameraY = 0;
            }
            
            // åœ°é¢ç¢°æ’æ£€æµ‹
            if (player.y > canvas.height - player.height - groundHeight) {
                player.y = canvas.height - player.height - groundHeight;
                player.jumping = false;
                player.yVelocity = 0;
                
                // è½åœ°æ—¶çš„ç²’å­æ•ˆæœ
                if (prevDirection > 0) { // åªåœ¨ä»ç©ºä¸­è½ä¸‹æ—¶åˆ›å»º
                    const dustCount = Math.min(Math.abs(prevDirection) * 2, 8);
                    createParticles(player.x + player.width / 2, player.y + player.height, '#FFFFFF', dustCount);
                }
            }
        }

        function updateObstacles() {
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= gameSpeed;
                
                // Remove obstacles that are off screen
                if (obstacles[i].x + obstacles[i].width < 0) {
                    obstacles.splice(i, 1);
                    // Only adjust game speed based on distance
                    if (distance % 250 === 0 && gameSpeed < 10) { // Lower max speed from 12 to 10
                        gameSpeed += 0.2; // Even smaller increment for smoother difficulty
                    }
                }
            }
            
            // Spawn obstacles with difficulty progression
            if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - 300 - Math.random() * 200) {
                // Beginning easier stage (first 5 obstacles) - more time to learn
                if (score < 5) {
                    // Larger gaps between obstacles for beginners
                    if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - 600) {
                        spawnObstacle();
                    }
                } 
                // Mid-game difficulty
                else if (score < 25) {
                    if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - 500) {
                        spawnObstacle();
                    }
                }
                // Regular difficulty (still more space)
                else if (distance < 1000) {
                    if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - 400) {
                        spawnObstacle();
                    }
                }
                // Beyond 1000m, slightly easier for sustained play
                else {
                    if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - 450) {
                        spawnObstacle();
                    }
                }
                
                // Randomly spawn medals, with higher chance in the beginning
                const medalChance = score < 10 ? 0.6 : 0.35;
                if (Math.random() < medalChance) {
                    spawnMedal();
                }
            }
        }

        function updateMedals() {
            for (let i = medals.length - 1; i >= 0; i--) {
                medals[i].x -= gameSpeed;
                
                // Remove medals that are off screen
                if (medals[i].x + medals[i].width < 0) {
                    medals.splice(i, 1);
                }
            }
        }
        
        function checkMilestones() {
    // è®¡ç®—å½“å‰æ‰€åœ¨çš„åœºæ™¯å¾ªç¯
    const cycleLength = 20700;
    const currentCycle = Math.floor(distance / cycleLength);
    const distanceInCycle = distance % cycleLength;

    // ç»Ÿä¸€çš„åœºæ™¯åˆ‡æ¢å¤„ç†å‡½æ•°
    const switchScene = (newScene, sceneIndex) => {
        sceneFade.active = true;
        sceneFade.fromScene = activeSceneName;
        sceneFade.toScene = newScene;
        sceneFade.progress = 0;
        
        // è®¾ç½®æ–°åœºæ™¯
        if (newScene === null) {
            // å¤œç©ºä½“è‚²åœº
            activeSceneName = null;
            currentBgStage = 0;
            showMilestoneNotification("å›åˆ°ä½“è‚²åœºä¹‹å¤œï¼", "#FFD700");
        } else {
            const element = bgElements[sceneIndex];
            if (element.setup) element.setup();
            activeSceneName = element.name;
            currentBgStage = sceneIndex + 1;
            showMilestoneNotification(element.description, element.color);
        }
    };

    // æ£€æŸ¥åœºæ™¯åˆ‡æ¢ç‚¹
    if (currentMap === "initialMap") {  // æ·»åŠ ï¼šæ£€æŸ¥å½“å‰åœ°å›¾
    if (distanceInCycle >= 17700 && distanceInCycle < 20700) {
        // çƒŸèŠ±åœºæ™¯
        if (activeSceneName !== 'fireworks') {
            switchScene('fireworks', 5);
        }
    } else if (distanceInCycle >= 21500 || distanceInCycle < 1200) {
        // å¤œç©ºä½“è‚²åœº
        if (activeSceneName !== null) {
            switchScene(null, -1);
        }
    } else {
        // æ£€æŸ¥å…¶ä»–åœºæ™¯é‡Œç¨‹ç¢‘
        for (let i = 0; i < bgElements.length; i++) {
            const element = bgElements[i];
            if (distanceInCycle >= element.distance && 
                distanceInCycle < element.distance + 100 && 
                activeSceneName !== element.name) {
                switchScene(element.name, i);
                break;
            }
        }
    }
    }
    // æ›´æ–°åœºæ™¯è¿‡æ¸¡æ•ˆæœ
    if (sceneFade.active) {
        sceneFade.progress++;
        if (sceneFade.progress >= sceneFade.duration) {
            sceneFade.active = false;
        }
    }
}
        
        function showMilestoneMessage(message, color) {
            milestoneNotification.textContent = message;
            milestoneNotification.style.color = color;
            milestoneNotification.style.opacity = 1;
            
            // Hide after 3 seconds
            setTimeout(() => {
                milestoneNotification.style.opacity = 0;
            }, 3000);
        }

        // Game difficulty levels
        const difficultyLevels = [
            { distance: 18000, speedMultiplier: 1.1, obstacleFrequency: 0.9, obstacleVarietyModifier: 1.2 }, 
            { distance: 26000, speedMultiplier: 1.15, obstacleFrequency: 0.8, obstacleVarietyModifier: 1.3 },
            { distance: 34000, speedMultiplier: 1.2, obstacleFrequency: 0.7, obstacleVarietyModifier: 1.4 },
            { distance: 42000, speedMultiplier: 1.25, obstacleFrequency: 0.65, obstacleVarietyModifier: 1.5 },
            { distance: 50000, speedMultiplier: 1.3, obstacleFrequency: 0.6, obstacleVarietyModifier: 1.6 }
        ];
        let currentDifficultyIndex = -1; // Start with base difficulty
        
        // Collision effects
        let collisionFlashActive = false;
        let collisionFlashTime = 0;
        let revivalEffectActive = false;
        let revivalParticles = [];

        function checkCollisions() {
            // æ£€æŸ¥ä¸æ”¶é›†ç‰©çš„ç¢°æ’
            for (let i = medals.length - 1; i >= 0; i--) {
                const medal = medals[i];
                if (
                    player.x < medal.x + medalSize &&
                    player.x + player.width > medal.x &&
                    player.y < medal.y + medalSize &&
                    player.y + player.height > medal.y
                ) {
                    collectSound.currentTime = 0;
                    collectSound.play();
                    
                    if (medal.type === collectibleTypes.GOLD) {
                        score++;
                        scoreDisplay.textContent = score;
                        createParticles(medal.x + medalSize/2, medal.y + medalSize/2, '#FFD700', 15);
                        
                        if (score >= UNLOCK_SCORE && !window.characterUnlocked.sprite02) {
                            window.characterUnlocked.sprite02 = true;
                            saveCharacterUnlockStatus();
        
        // ç«‹å³æ˜¾ç¤ºè§£é”æç¤º
                            showUnlockNotification('æ­å–œï¼æ–°è§’è‰²"å°å˜å°å“"å·²è§£é”ï¼');
                        }
                    // æ·»åŠ ï¼šç«‹å³æ£€æŸ¥åœ°å›¾è§£é”æ¡ä»¶
                    if (score >= MAP_UNLOCK_SCORE && !mapUnlocked.newMap) {
                        mapUnlocked.newMap = true;
                        saveMapUnlockStatus();
        
                    // ç«‹å³æ˜¾ç¤ºè§£é”æç¤º
                        showUnlockNotification('åœ°å›¾ï¼šæœ«æ—¥æ—…è¡Œå·²è§£é”ï¼');
                    }
                    } else if (medal.type === collectibleTypes.TEA) {
                        teaCount++;
                        document.getElementById('tea-count').textContent = teaCount;
                        createParticles(medal.x + medalSize/2, medal.y + medalSize/2, '#66CC66', 15);
                    }
                    medals.splice(i, 1);
                }
            }

            // å¦‚æœç©å®¶å¤„äºæ— æ•ŒçŠ¶æ€ï¼Œè·³è¿‡ç¢°æ’æ£€æµ‹
            if (player.invincible) {
                return;
            }

            // æ£€æŸ¥ä¸éšœç¢ç‰©çš„ç¢°æ’
            for (const obstacle of obstacles) {
                const collisionMargin = 10;
                const playerHitbox = {
                    x: player.x + collisionMargin,
                    y: player.y + collisionMargin,
                    width: player.width - (collisionMargin * 2),
                    height: player.height - (collisionMargin * 2)
                };

                if (
                    playerHitbox.x < obstacle.x + obstacle.width &&
                    playerHitbox.x + playerHitbox.width > obstacle.x &&
                    playerHitbox.y < obstacle.y + obstacle.height &&
                    playerHitbox.y + playerHitbox.height > obstacle.y
                ) {
                    if (teaCount > 0) {
                        // ä½¿ç”¨èŒ¶çš„æ•ˆæœ
                        teaCount--;
                        
                        // æ·»åŠ èŒ¶æ¶ˆè€—çš„UIåŠ¨ç”»æ•ˆæœ
                        const teaCountElement = document.getElementById('tea-container');
                        teaCountElement.style.transform = 'scale(1.3)';
                        teaCountElement.style.backgroundColor = 'rgba(102, 255, 102, 0.3)';
                        setTimeout(() => {
                            teaCountElement.style.transform = 'scale(1)';
                            teaCountElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                        }, 300);
                        
                        document.getElementById('tea-count').textContent = teaCount;
                        
                        // åˆ›å»ºæ›´åä¸½çš„ä¿æŠ¤æ•ˆæœç²’å­
                        createTeaEffect(player.x + player.width/2, player.y + player.height/2);
                        
                        // è®¾ç½®æ— æ•ŒçŠ¶æ€
                        player.invincible = true;
                        setTimeout(() => {
                            player.invincible = false;
                        }, 2000);
                        
                        return;
                    } else {
                        // æ²¡æœ‰èŒ¶å°±ç»“æŸæ¸¸æˆ
                        gameoverSound.currentTime = 0;
                        gameoverSound.play();
                        endGame();
                        return;
                    }
                }
            }
        }

        function endGame() {
             // ç›´æ¥è°ƒç”¨gameOverå‡½æ•°ï¼Œè€Œä¸æ˜¯é‡å¤å®ç°ç›¸åŒçš„åŠŸèƒ½
            gameOver();
        }

        function showRevivalMessage() {
            const message = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                text: "èŒ¶å¤æ´»!",
                life: 60,
                yVelocity: -1,
                size: 30, // Starting size
                growing: true
            };
            
            // Create a temporary animation function to show the message
            const drawRevivalMessage = () => {
                if (message.life <= 0) return;
                
                // Pulse effect for text size
                if (message.growing) {
                    message.size += 0.5;
                    if (message.size >= 38) message.growing = false;
                } else {
                    message.size -= 0.5;
                    if (message.size <= 30) message.growing = true;
                }
                
                ctx.font = `${message.size}px Pixel, monospace`;
                ctx.textAlign = 'center';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 4;
                ctx.strokeText(message.text, message.x, message.y);
                ctx.fillStyle = '#00FF00';
                ctx.fillText(message.text, message.x, message.y);
                
                message.y += message.yVelocity;
                message.life--;
                
                if (message.life > 0) {
                    requestAnimationFrame(drawRevivalMessage);
                }
            };
            
            drawRevivalMessage();
        }

        function createRevivalEffect() {
            revivalEffectActive = true;
            
            // Create circular particles that expand outward
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                
                revivalParticles.push({
                    x: player.x + player.width / 2,
                    y: player.y + player.height / 2,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 5 + Math.random() * 5,
                    color: '#8AFF8A', // Light green
                    life: 60 + Math.random() * 20
                });
            }
            
            // Green glow around player (will be drawn separately)
        }

        function updateRevivalEffect() {
            if (!revivalEffectActive) return;
            
            // Update particles
            for (let i = revivalParticles.length - 1; i >= 0; i--) {
                const particle = revivalParticles[i];
                
                // Move particle
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // Decrease life
                particle.life--;
                
                // Remove dead particles
                if (particle.life <= 0) {
                    revivalParticles.splice(i, 1);
                }
            }
            
            // Check if all particles are gone
            if (revivalParticles.length === 0) {
                revivalEffectActive = false;
            }
        }

        function drawRevivalEffect() {
            if (!revivalEffectActive) return;
            
            // Draw particles
            for (const particle of revivalParticles) {
                ctx.globalAlpha = particle.life / 80; // Fade out as life decreases
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw glow around player when revival is active
            if (revivalEffectActive) {
                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#00FF00';
                ctx.beginPath();
                ctx.ellipse(
                    player.x + player.width / 2,
                    player.y + player.height / 2,
                    player.width * 0.8,
                    player.height * 0.8,
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                ctx.restore();
            }
            
            // Reset global alpha
            ctx.globalAlpha = 1;
        }

        // Collectible animation
        let pointsAnimations = [];
        
        function showCollectibleAnimation(x, y, text, color) {
            pointsAnimations.push({
                x: x,
                y: y,
                text: text,
                color: color,
                life: 30, // Frames the animation will last
                yVelocity: -2 // Animation moves upward
            });
        }
        
        function updatePointsAnimations() {
            for (let i = pointsAnimations.length - 1; i >= 0; i--) {
                const anim = pointsAnimations[i];
                // Move animation up
                anim.y += anim.yVelocity;
                // Decrease life
                anim.life--;
                // Remove dead animations
                if (anim.life <= 0) {
                    pointsAnimations.splice(i, 1);
                }
            }
        }
        
        function drawPointsAnimations() {
            for (const anim of pointsAnimations) {
                // Calculate opacity based on remaining life
                const opacity = anim.life / 30;
                ctx.globalAlpha = opacity;
                
                // Draw text with pixel art style
                ctx.font = '20px Pixel, monospace';
                ctx.textAlign = 'center';
                ctx.lineWidth = 2;
                
                // Draw outline for better visibility
                ctx.strokeStyle = 'black';
                ctx.strokeText(anim.text, anim.x, anim.y);
                
                // Draw text
                ctx.fillStyle = anim.color;
                ctx.fillText(anim.text, anim.x, anim.y);
            }
            
            ctx.globalAlpha = 1; // Reset alpha
        }
        
        let animationId = null;
        
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            drawSky();
            drawClouds();
            drawTrack();
            
            // æ£€æŸ¥å’Œåº”ç”¨éš¾åº¦è®¾ç½®
            let currentDifficulty = null;
            for (let i = 0; i < difficultyLevels.length; i++) {
                if (distance >= difficultyLevels[i].distance && 
                    (i > currentDifficultyIndex || currentDifficultyIndex === -1)) {
                    currentDifficultyIndex = i;
                    currentDifficulty = difficultyLevels[i];
                    
                    // æ˜¾ç¤ºéš¾åº¦æå‡æ¶ˆæ¯
                    showMilestoneMessage(`éš¾åº¦æå‡! ç»§ç»­å‰è¿›!`, '#FF5252');
                    break;
                }
            }
            
            // å¦‚æœæœ‰æ–°çš„éš¾åº¦çº§åˆ«ï¼Œåº”ç”¨å®ƒ
            if (currentDifficulty && frameCount % 60 === 0) {
                gameSpeed = 5 * currentDifficulty.speedMultiplier;
            }
            
            // Update game objects
            updatePlayer();
            updateObstacles();
            updateMedals();
            updatePointsAnimations();
            updateRevivalEffect();
            updateParticles();
            
            // Check for milestone achievements
            checkMilestones();
            
            // Draw game objects
            drawObstacles();
            drawMedals();
            drawPlayer();
            
            // Draw effects
            drawRevivalEffect();
            drawPointsAnimations();
            drawParticles();
            
            // Draw collision flash if active
            if (collisionFlashActive) {
                ctx.fillStyle = `rgba(255, 0, 0, ${collisionFlashTime / 80})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                collisionFlashTime--;
                
                if (collisionFlashTime <= 0) {
                    collisionFlashActive = false;
                }
            }
            
            // Check collisions
            checkCollisions();
            
            // Update frame count and distance
            frameCount++;
            if (gameRunning) {
                // Update distance based on game speed and frame rate
                // Assuming approximately 60fps, distance increases proportionally to game speed
                distance += Math.round(gameSpeed / 5); // Convert game speed to approximate meters
                distanceDisplay.textContent = distance.toString();
            }
            
            if (gameRunning) {
                animationId = requestAnimationFrame(gameLoop);
            }
        }

        // Responsive canvas resizing
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // åœ¨æ¸¸æˆé‡ç½®æ—¶é‡ç½®èŒ¶çš„æ•°é‡
        function resetGame() {
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameRunning = true;
            score = 0;
            distance = 0;
            frameCount = 0;
            lastMilestone = 0;
            gameSpeed = 5;
            currentBgStage = 0;
            activeSceneName = null;
            
            // é‡ç½®ç©å®¶çŠ¶æ€
            player.x = 50;
            player.y = GROUND_Y;
            player.jumping = false;
            player.yVelocity = 0;
            player.invincible = false;
            player.invincibleTimer = 0;
            player.sparkles = [];
            player.glowIntensity = 0;
            player.teaCollectFlash = 0;
            
            // é‡ç½®åœºæ™¯å…ƒç´ 
            clouds = [];
            mountains = [];
            pirateElements = [];
            cherrySakura = [];
            gardenElements = [];
            meteors = [];
            fireworks = [];
            fireworksCity = [];
            
            // é‡ç½®éšœç¢ç‰©å’Œé“å…·
            obstacles = [];
            teas = [];
            
            // é‡ç½®æ˜¾ç¤º
            scoreDisplay.textContent = '0';
            distanceDisplay.textContent = '0';
            
             // æ·»åŠ ï¼šæ ¹æ®å½“å‰åœ°å›¾è®¾ç½®åˆå§‹åœºæ™¯
            if (currentMap === "newMap") {  // æ·»åŠ ï¼šæ£€æŸ¥å½“å‰åœ°å›¾
        // æ·»åŠ ï¼šæ–°åœ°å›¾å§‹ç»ˆæ˜¯å¤œç©ºèƒŒæ™¯
                currentBackgroundState = {
                current: 'bg1',
                next: null,
                fadeProgress: 0,
                isFading: false,
                fadeDuration: 60,
                lastChangeDistance: 0
        }; // ã€è¯´æ˜ã€‘ï¼šé‡ç½®èƒŒæ™¯çŠ¶æ€ä¸ºåˆå§‹å€¼ 
            } else {  // æ·»åŠ ï¼šåˆå§‹åœ°å›¾
        // æ·»åŠ ï¼šåˆå§‹åœ°å›¾ä»å¤œç©ºä½“è‚²åœºå¼€å§‹
                activeSceneName = null;  // æ·»åŠ ï¼šè®¾ç½®æ´»åŠ¨åœºæ™¯ä¸ºnullï¼ˆå¤œç©ºï¼‰
                currentBgStage = 0;  // æ·»åŠ ï¼šè®¾ç½®èƒŒæ™¯é˜¶æ®µä¸º0
    }
            // éšè—æ¸¸æˆç»“æŸç•Œé¢
            gameOverScreen.style.display = 'none';
            
            // é‡ç½®èƒŒæ™¯åœºæ™¯
            gameScene = 'sakura'; // é‡ç½®ä¸ºåˆå§‹åœºæ™¯
            
            // é‡æ–°åˆå§‹åŒ–ç¬¬ä¸€ä¸ªåœºæ™¯
            if (bgElements[0].setup) {
                bgElements[0].setup();
            }
            
            characterSprite.src = `${currentCharacter}.png`;
            updatePlayerAttributes();
        }

        // æ·»åŠ èŒ¶ç‰¹æ•ˆå‡½æ•°
        function createTeaEffect(x, y) {
            // åˆ›å»ºç»¿è‰²èƒ½é‡ç¯
            for (let i = 0; i < 2; i++) {
                const ringParticles = 20;
                for (let j = 0; j < ringParticles; j++) {
                    const angle = (j / ringParticles) * Math.PI * 2;
                    const speed = 3 + i * 2;
                    particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 60,
                        maxLife: 60,
                        color: `rgba(102, 255, 102, ${0.8 - i * 0.3})`,
                        size: 8 - i * 2,
                        type: 'ring'
                    });
                }
            }

            // åˆ›å»ºä¸Šå‡çš„èŒ¶å¶ç²’å­
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -Math.random() * 4 - 2,
                    life: 45,
                    maxLife: 45,
                    color: '#90EE90',
                    size: 6,
                    type: 'leaf',
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2
                });
            }
        }

        // æ›´æ–°ç²’å­ç»˜åˆ¶å‡½æ•°
        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                
                if (p.type === 'ring') {
                    // ç¯å½¢ç²’å­
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / p.maxLife;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.type === 'leaf') {
                    // èŒ¶å¶ç²’å­
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / p.maxLife;
                    
                    // ç»˜åˆ¶èŒ¶å¶å½¢çŠ¶
                    ctx.beginPath();
                    ctx.moveTo(0, -p.size);
                    ctx.quadraticCurveTo(p.size/2, 0, 0, p.size);
                    ctx.quadraticCurveTo(-p.size/2, 0, 0, -p.size);
                    ctx.fill();
                    
                    ctx.restore();
                    
                    // æ›´æ–°èŒ¶å¶æ—‹è½¬
                    p.rotation += p.rotationSpeed;
                } else {
                    // æ™®é€šç²’å­
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / p.maxLife;
                    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
                }
                
                // æ›´æ–°ç²’å­ä½ç½®
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                // ç§»é™¤æ­»äº¡ç²’å­
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            ctx.globalAlpha = 1;
        }

        // æ›´æ–°èŒ¶é“å…·æ”¶é›†é€»è¾‘
        function collectTea(tea) {
            teaCount++;
            teaCountDisplay.textContent = teaCount;
            player.invincible = true;
            player.invincibleTimer = Date.now();
            player.teaCollectFlash = 1; // è§¦å‘é—ªå…‰æ•ˆæœ
            
            // æ’­æ”¾æ”¶é›†éŸ³æ•ˆ
            collectSound.currentTime = 0;
            collectSound.play();
            
            // åˆ›å»ºæ”¶é›†ç‰¹æ•ˆ
            createTeaCollectEffect(tea.x, tea.y);
        }

        // æ·»åŠ èŒ¶é“å…·æ”¶é›†ç‰¹æ•ˆ
        function createTeaCollectEffect(x, y) {
            const colors = [
                'rgba(152, 251, 152, ', // æ·¡ç»¿è‰²
                'rgba(173, 255, 47, ',  // é»„ç»¿è‰²
                'rgba(50, 205, 50, '    // ç»¿è‰²
            ];
            
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                player.sparkles.push({
                    x: x + 15,
                    y: y + 15,
                    size: 4,
                    speed: 3,
                    angle: angle,
                    life: 1,
                    color: colors[i % colors.length]
                });
            }
        }

        // åœ¨updateGameä¸­æ›´æ–°æ— æ•ŒçŠ¶æ€
        function updateGame() {
            // ... existing code ...
            
            // æ›´æ–°æ— æ•ŒçŠ¶æ€
            if (player.invincible && Date.now() - player.invincibleTimer > player.invincibleDuration) {
                player.invincible = false;
                player.sparkles = []; // æ¸…é™¤æ‰€æœ‰ç‰¹æ•ˆç²’å­
            }
            
            // ... existing code ...
        }

        // æ·»åŠ è§’è‰²é€‰æ‹©å˜é‡
        let currentCharacter = 'sprite';
        
        // æ·»åŠ è§’è‰²é€‰æ‹©å‡½æ•°
        function setupCharacterSelection() {
            const characterOptions = document.querySelectorAll('.character-option');
            
            characterOptions.forEach(option => {
                option.addEventListener('click', function() {
                    characterOptions.forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                    
                    const characterType = this.getAttribute('data-character');
                    currentCharacter = characterType;
                    characterSprite.src = `${characterType}.png`;
                    
                    updatePlayerAttributes();
                });
            });
        }

        function updatePlayerAttributes() {
            if (currentCharacter === 'sprite02') {
                player.jumpForce = 12.5;
                player.maxJumpForce = 19;
            } else {
                player.jumpForce = 12;
                player.maxJumpForce = 18;
            }
        }

        // åˆå§‹åŒ–è§’è‰²é€‰æ‹©
        document.addEventListener('DOMContentLoaded', function() {
            // æˆ‘ä»¬çš„æ°¸ä¹…è§£å†³æ–¹æ¡ˆä»£ç å¼€å§‹
    // ç¡®ä¿ä»localStorageåŠ è½½è§£é”çŠ¶æ€
    const savedStatus = localStorage.getItem('characterUnlocked');
    if (savedStatus) {
        try {
            window.characterUnlocked = JSON.parse(savedStatus);
            console.log('å·²åŠ è½½è§£é”çŠ¶æ€:', window.characterUnlocked);
        } catch (e) {
            console.error('è§£æè§£é”çŠ¶æ€æ—¶å‡ºé”™:', e);
            window.characterUnlocked = {
                'sprite': true,
                'sprite02': false
            };
        }
    } else {
        window.characterUnlocked = {
            'sprite': true,
            'sprite02': false
        };
    }
    
    // æ·»åŠ å…¨å±€åŒæ­¥å‡½æ•°
    window.syncUnlockStatus = function() {
        localStorage.setItem('characterUnlocked', JSON.stringify(window.characterUnlocked));
        console.log('å·²åŒæ­¥è§£é”çŠ¶æ€:', window.characterUnlocked);
    };
    
    // è¦†ç›–åŸæœ‰çš„saveUnlockStatuså‡½æ•°
    window.saveUnlockStatus = function() {
        localStorage.setItem('characterUnlocked', JSON.stringify(window.characterUnlocked));
        console.log('å·²ä¿å­˜è§£é”çŠ¶æ€:', window.characterUnlocked);
    };
    
    // æ¯éš”ä¸€æ®µæ—¶é—´è‡ªåŠ¨åŒæ­¥ä¸€æ¬¡
    setInterval(window.syncUnlockStatus, 10000);
    // æˆ‘ä»¬çš„æ°¸ä¹…è§£å†³æ–¹æ¡ˆä»£ç ç»“æŸ
    
    // åŸæœ‰çš„åˆå§‹åŒ–ä»£ç 
    // æ³¨æ„ï¼šå¦‚æœåŸä»£ç ä¸­æœ‰loadUnlockStatus()è°ƒç”¨ï¼Œå¯ä»¥è€ƒè™‘æ³¨é‡Šæ‰ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»å¤„ç†äº†åŠ è½½é€»è¾‘
    // loadUnlockStatus(); // å¯ä»¥æ³¨é‡Šæ‰ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»å¤„ç†äº†åŠ è½½é€»è¾‘
    updateCharacterSelectionUI();
    // ... å…¶ä»–åˆå§‹åŒ–ä»£ç  ...
            setupCharacterSelection();
        });

        // è§’è‰²è§£é”ç³»ç»Ÿ
        window.characterUnlocked = {
            'sprite': true,     // åˆå§‹è§’è‰²é»˜è®¤è§£é”
            'sprite02': false   // æ–°è§’è‰²é»˜è®¤æœªè§£é”
        };
        const UNLOCK_SCORE = 84;

        function updateCharacterSelectionUI() {
            const characterSelectionElement = document.getElementById('character-selection');
            
            if (characterSelectionElement) {

                characterSelectionElement.innerHTML = `
                    <h3 style="margin-bottom: 10px; color: var(--accent-light);">é€‰æ‹©è§’è‰²</h3>
                    <div class="character-options">
                        <div class="character-option ${currentCharacter === 'sprite' ? 'selected' : ''}" data-character="sprite">
                            <div class="character-preview">
                                <img src="chushiyulan.png" style="width: 100%; height: 100%; object-fit: contain;">
                            </div>
                            <div class="character-name">å°ä¹å°èŒ¶</div>
                        </div>
                        
                        <div class="character-option ${currentCharacter === 'sprite02' ? 'selected' : ''} ${!window.characterUnlocked.sprite02 ? 'locked' : ''}" data-character="sprite02">
                            <div class="character-preview">
                                ${window.characterUnlocked.sprite02 ? 
                                    `<img src="xinjueseyulan.png" style="width: 100%; height: 100%; object-fit: contain; filter: none;">` :
                                    `<div class="character-silhouette">
                                        <img src="xinjueseyulan.png" class="silhouette" style="width: 100%; height: 100%; object-fit: contain;">
                                        <div class="question-mark">?</div>
                                    </div>`
                                }
                            </div>
                            <div class="character-name">${window.characterUnlocked.sprite02 ? 'å°å˜å°å“' : 'æœªè§£é”'}</div>
                            ${!window.characterUnlocked.sprite02 ? '<div class="unlock-hint">æ”¶é›†84å—é‡‘ç‰Œè§£é”</div>' : ''}
                        </div>
                    </div>
                `;
                
                setupCharacterSelection();
            }
        }

        function setupCharacterSelection() {
            const characterOptions = document.querySelectorAll('.character-option');
            
            characterOptions.forEach(option => {
                option.addEventListener('click', function() {
                    const characterType = this.getAttribute('data-character');
                    
                    if (window.characterUnlocked[characterType]) {
                        characterOptions.forEach(opt => opt.classList.remove('selected'));
                        this.classList.add('selected');
                        
                        currentCharacter = characterType;
                        characterSprite.src = `${characterType}.png`;
                        
                        updatePlayerAttributes();
                    } else {
                        this.classList.add('shake');
                        setTimeout(() => {
                            this.classList.remove('shake');
                        }, 500);
                    }
                });
            });
        }

        function showUnlockNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'unlock-notification';
            notification.innerHTML = `
                <div class="unlock-icon">ğŸ</div>
                <div class="unlock-message">${message}</div>
            `;
            
            const gameContainer = document.getElementById('game-container');
            gameContainer.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3500);
        }

        // ä¿®æ”¹ç°æœ‰çš„handleGMCommandå‡½æ•°
        function handleGMCommand(key) {
            if (key === 'g' || key === 'G') {
                score += 300;
                scoreDisplay.textContent = score;
                
                if (score > highScore) {
                    highScore = score;
                    highScoreDisplay.textContent = "æœ€é«˜é‡‘ç‰Œæ•°é‡: " + highScore;
                }
                
                if (score >= UNLOCK_SCORE && !characterUnlocked.sprite02) {
                    characterUnlocked.sprite02 = true;
                    saveUnlockStatus();
                    showUnlockNotification('å°å˜å°å“å·²è§£é”ï¼');
                    
                    if (gameOverScreen.style.display === 'flex') {
                        updateCharacterSelectionUI();
                    }
                }
                
                console.log('GM Command: Added 300 to score');
            } else if (key === 'p' || key === 'P') {
                // å¿«é€Ÿå‘¼å‡ºæµ·ç›—èˆ¹åœºæ™¯
                console.log('GM Command: åˆ‡æ¢åˆ°æµ·ç›—èˆ¹åœºæ™¯');
                
                // è®¾ç½®è·ç¦»åˆ°æµ·ç›—èˆ¹åœºæ™¯çš„é‡Œç¨‹ç¢‘
                distance = 4500;
                distanceDisplay.textContent = Math.floor(distance);
                
                // æ‰‹åŠ¨è§¦å‘åœºæ™¯åˆ‡æ¢
                checkMilestones();
                
                // æ˜¾ç¤ºæç¤º
                showMilestoneNotification("å¼€å‘æ¨¡å¼: æµ·ç›—èˆ¹åœºæ™¯å·²åŠ è½½", "#4682B4");
            }
            // [æ–°å¢] æŒ‰Ré”®é‡ç½®è§’è‰²è§£é”çŠ¶æ€
            else if (key === 'r' || key === 'R') {
                // é‡ç½®è§’è‰²è§£é”çŠ¶æ€
                characterUnlocked = {
                    'sprite': true,     // åˆå§‹è§’è‰²ä¿æŒè§£é”
                    'sprite02': false   // æ–°è§’è‰²é‡ç½®ä¸ºæœªè§£é”
                };
                // ä¿å­˜åˆ°localStorage
                saveUnlockStatus();
                // æ›´æ–°UI
                updateCharacterSelectionUI();
                // æ˜¾ç¤ºæç¤º
                showMilestoneNotification("å·²é‡ç½®è§’è‰²è§£é”çŠ¶æ€", "#FF6B6B");
            }
            // [æ–°å¢] æŒ‰Lé”®æŸ¥çœ‹å½“å‰è§£é”çŠ¶æ€
            else if (key === 'l' || key === 'L') {
                const status = characterUnlocked.sprite02 ? "å·²è§£é”" : "æœªè§£é”";
                showMilestoneNotification(`å°å˜å°å“: ${status}`, "#4682B4");
            }
        }

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            loadUnlockStatus();
            updateCharacterSelectionUI();
            // ... existing code ...
        });

// ä¿å­˜åœ°å›¾è§£é”çŠ¶æ€
        function saveMapUnlockStatus() {
            localStorage.setItem('mapUnlocked', JSON.stringify(mapUnlocked));
}

// åŠ è½½åœ°å›¾è§£é”çŠ¶æ€
        function loadMapUnlockStatus() {
            const savedStatus = localStorage.getItem('mapUnlocked');
            if (savedStatus) {
                try {
                    mapUnlocked = JSON.parse(savedStatus);
                } catch (e) {
            // å¦‚æœè§£æå‡ºé”™ï¼Œä½¿ç”¨é»˜è®¤å€¼
            mapUnlocked = {
                initialMap: true,
                newMap: false
            };
        }
    }
}

        function saveUnlockStatus() {
            // ä½¿ç”¨localStorageä¿å­˜è§’è‰²è§£é”çŠ¶æ€
            localStorage.setItem('characterUnlocked', JSON.stringify(window.characterUnlocked));
        }

        function loadUnlockStatus() {
            // ä»localStorageåŠ è½½è§’è‰²è§£é”çŠ¶æ€
            const savedStatus = localStorage.getItem('characterUnlocked');
            if (savedStatus) {
                try {
                    window.characterUnlocked = JSON.parse(savedStatus);
                } catch (e) {
                    // å¦‚æœè§£æå‡ºé”™ï¼Œä½¿ç”¨é»˜è®¤å€¼
                    window.characterUnlocked = {
                        'sprite': true,
                        'sprite02': false
                    };
                }
            }
        }

        // æ·»åŠ æ–°çš„è¾…åŠ©å‡½æ•°
        function drawRainClouds() {
            // ç»˜åˆ¶å‡ ä¸ªå¤§å‹æš—è‰²äº‘å›¢
            const cloudColors = ['#1A2535', '#202D3E', '#283547'];
            // ... drawRainCloudsä»£ç  ...
        }

        function drawRainOverlay() {
            // åœ¨ç”»é¢ä¸Šæ–¹æ·»åŠ æ›´å¤šçš„é›¨æ»´æ•ˆæœ
            ctx.fillStyle = 'rgba(180, 210, 240, 0.05)';
            // ... drawRainOverlayä»£ç  ...
        }

        function createLightningBolt(lightning, startX, startY, length, angle, generation) {
            if (generation > 3) return;
            
            const endX = startX + Math.cos(angle) * length;
            const endY = startY + Math.sin(angle) * length;
            
            lightning.branches.push({
                startX: startX,
                startY: startY,
                endX: endX,
                endY: endY
            });
            
            if (Math.random() < 0.6 && generation < 2) {
                const newAngle = angle + (Math.random() * 0.5 - 0.25) * Math.PI;
                const newLength = length * (0.3 + Math.random() * 0.4);
                
                const branchStartPos = 0.3 + Math.random() * 0.5;
                const branchStartX = startX + (endX - startX) * branchStartPos;
                const branchStartY = startY + (endY - startY) * branchStartPos;
                
                createLightningBolt(
                    lightning,
                    branchStartX,
                    branchStartY,
                    newLength,
                    newAngle,
                    generation + 1
                );
            }
        }

        // æ·»åŠ åœºæ™¯åˆ‡æ¢åŠŸèƒ½
        window.addEventListener('keydown', function(e) {
            // åªå“åº”ä¸»é”®ç›˜ä¸Šæ–¹çš„æ•°å­—é”®ï¼ˆä¸åŒ…æ‹¬å°é”®ç›˜ï¼‰
            switch(e.key) {
                case '1': // ä½“è‚²åœºï¼ˆé»˜è®¤åœºæ™¯ï¼‰
                    distance = 0;
                    currentBgStage = 0;
                    activeSceneName = null;
                    console.log('åˆ‡æ¢åˆ°ï¼šä½“è‚²åœºåœºæ™¯');
                    break;
                case '2': // å±±åœ°åœºæ™¯
                    distance = 2000;
                    currentBgStage = 1;
                    activeSceneName = 'mountains';
                    createMountains();
                    console.log('åˆ‡æ¢åˆ°ï¼šå±±åœ°åœºæ™¯');
                    break;
                case '3': // æµ·åº•ä¸¤ä¸‡é‡Œåœºæ™¯
                    distance = 11000;
                    currentBgStage = 2;
                    activeSceneName = 'pirate';
                    createPirateScene();
                    console.log('åˆ‡æ¢åˆ°ï¼šæµ·åº•ä¸¤ä¸‡é‡Œåœºæ™¯');
                    break;
                case '4': // æ¨±èŠ±åœºæ™¯
                    distance = 15000;
                    currentBgStage = 3;
                    activeSceneName = 'cherryBlossom';
                    createCherryBlossom();
                    console.log('åˆ‡æ¢åˆ°ï¼šæ¨±èŠ±åœºæ™¯');
                    break;
                case '5': // æµæ˜Ÿé›¨åœºæ™¯
                    distance = 18500;
                    currentBgStage = 4;
                    activeSceneName = 'meteors';
                    createMeteorShower();
                    console.log('åˆ‡æ¢åˆ°ï¼šæµæ˜Ÿé›¨åœºæ™¯');
                    break;
                case '6': // çƒŸèŠ±åœºæ™¯
                    distance = 21500;
                    currentBgStage = 5;
                    activeSceneName = 'fireworks';
                    createFireworks();
                    console.log('åˆ‡æ¢åˆ°ï¼šçƒŸèŠ±åœºæ™¯');
                    break;
                case '0': // æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
                    console.log(`
åœºæ™¯åˆ‡æ¢å¿«æ·é”®:
1 - ä½“è‚²åœºï¼ˆé»˜è®¤åœºæ™¯ï¼‰
2 - å±±åœ°åœºæ™¯ (3000ç±³)
3 - æµ·åº•ä¸¤ä¸‡é‡Œåœºæ™¯ (6000ç±³)
4 - æ¨±èŠ±åœºæ™¯ (9000ç±³)
5 - æµæ˜Ÿé›¨åœºæ™¯ (12000ç±³)
6 - çƒŸèŠ±åœºæ™¯ (15000ç±³)
0 - æ˜¾ç¤ºæ­¤å¸®åŠ©ä¿¡æ¯
                    `);
                    break;
            }
            
            // æ›´æ–°è·ç¦»æ˜¾ç¤º
            if (distanceDisplay) {
                distanceDisplay.textContent = Math.floor(distance) + ' ç±³';
            }
        });

        // æ·»åŠ æç¤ºä¿¡æ¯
        console.log('æŒ‰ 0 æŸ¥çœ‹åœºæ™¯åˆ‡æ¢å¿«æ·é”®');

        // æµ·ç›—èˆ¹åœºæ™¯å…ƒç´ å®¹å™¨
        let pirateShipElements = [];

        function createPirateShipScene() {
            // æ¸…ç©ºç°æœ‰å…ƒç´ 
            pirateElements = [];
            
            // åˆ›å»ºé›¨æ»´
            for (let i = 0; i < 200; i++) {
                pirateElements.push({
                    type: 'raindrop',
                    x: Math.random() * canvas.width* 1.5,
                    y: Math.random() * canvas.height,
                    length: 10 + Math.random() * 20,
                    speed: 15 + Math.random() * 5
                });
            }
            
            // åˆ›å»ºé—ªç”µ - å‡å°‘æ•°é‡ä»3ä¸ªåˆ°1ä¸ª
            for (let i = 0; i < 1; i++) {
                pirateElements.push({
                    type: 'lightning',
                    x: Math.random() * canvas.width,
                    y: 0,
                    segments: 5 + Math.floor(Math.random() * 5),
                    width: 2 + Math.random() * 3,
                    alpha: 0,
                    maxAlpha: 0.6 + Math.random() * 0.4,
                    fadeSpeed: 0.01 + Math.random() * 0.02, // é™ä½æ·¡å…¥æ·¡å‡ºé€Ÿåº¦ï¼Œå‡å°‘é¢‘ç‡
                    state: 'fadein',
                    zigzag: 20 + Math.random() * 30,
                    cooldown: 0,
                    maxCooldown: 120 + Math.floor(Math.random() * 180) // æ·»åŠ å†·å´æ—¶é—´ï¼Œå‡å°‘é¢‘ç‡
                });
            }
            
            // åˆ›å»ºæ›´é…·ç‚«çš„æµ·ç›—èˆ¹
            pirateElements.push({
                type: 'ship',
                x: canvas.width * 0.7,
                y: canvas.height - 80,
                width: 180,
                height: 120,
                mastHeight: 150,
                sailWidth: 70,
                sailHeight: 90,
                angle: 0,
                maxAngle: 5,
                direction: 1,
                speed: 0.05
            });
            
            // åˆ›å»ºæ³¢æµª
            for (let i = 0; i < 8; i++) {
                pirateElements.push({
                    type: 'wave',
                    x: i * (canvas.width / 8),
                    y: canvas.height - 40,
                    width: canvas.width / 8,
                    height: 20,
                    speed: 0.05,
                    offset: i * 0.5
                });
            }
        }

        function drawPirateShipScene() {
            // ç»˜åˆ¶æš´é£é›¨èƒŒæ™¯
            const stormGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            stormGradient.addColorStop(0, '#0A1B29');
            stormGradient.addColorStop(0.7, '#1A2C3E');
            stormGradient.addColorStop(1, '#334759');
            
            ctx.fillStyle = stormGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // æ›´æ–°å’Œç»˜åˆ¶æ‰€æœ‰å…ƒç´ 
            for (let i = 0; i < pirateElements.length; i++) {
                const element = pirateElements[i];
                
                switch (element.type) {
                    case 'raindrop':
                        // é›¨æ»´ä»£ç ä¿æŒä¸å˜
                        element.y += element.speed;
                        element.x -= element.speed * 0.5;
                        
                        if (element.y > canvas.height || element.x < 0) {
                            element.y = Math.random() * -50;
                            element.x = Math.random() * canvas.width* 1.5;
                        }
                        
                        ctx.strokeStyle = 'rgba(180, 230, 255, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(element.x, element.y);
                        ctx.lineTo(element.x - element.length * 0.5, element.y + element.length);
                        ctx.stroke();
                        break;
                        
                    case 'lightning':
                        // é—ªç”µä»£ç ä¿æŒä¸å˜
                        if (element.cooldown > 0) {
                            element.cooldown--;
                            break; // è·³è¿‡ç»˜åˆ¶
                        }
                        
                        if (element.state === 'fadein') {
                            element.alpha += element.fadeSpeed;
                            if (element.alpha >= element.maxAlpha) {
                                element.state = 'fadeout';
                                element.fadeSpeed *= 2;
                            }
                        } else if (element.state === 'fadeout') {
                            element.alpha -= element.fadeSpeed;
                            if (element.alpha <= 0) {
                                element.x = Math.random() * canvas.width;
                                element.segments = 5 + Math.floor(Math.random() * 5);
                                element.alpha = 0;
                                element.maxAlpha = 0.6 + Math.random() * 0.4;
                                element.fadeSpeed = 0.01 + Math.random() * 0.02;
                                element.state = 'fadein';
                                element.zigzag = 20 + Math.random() * 30;
                                element.cooldown = element.maxCooldown;
                            }
                        }
                        
                        if (element.alpha > 0) {
                            ctx.strokeStyle = `rgba(220, 240, 255, ${element.alpha})`;
                            ctx.lineWidth = element.width;
                            ctx.beginPath();
                            ctx.moveTo(element.x, element.y);
                            
                            let currentX = element.x;
                            let currentY = element.y;
                            const segmentLength = canvas.height / element.segments;
                            
                            for (let j = 0; j < element.segments; j++) {
                                currentY += segmentLength;
                                currentX += (Math.random() - 0.5) * element.zigzag;
                                ctx.lineTo(currentX, currentY);
                            }
                            
                            ctx.stroke();
                            
                            ctx.strokeStyle = `rgba(180, 225, 255, ${element.alpha * 0.3})`;
                            ctx.lineWidth = element.width * 3;
                            ctx.stroke();
                        }
                        break;
                        
                    case 'ship':
                        // èˆ¹çš„åŸºæœ¬åŠ¨ç”»å’Œä½ç½®ä»£ç ä¿æŒä¸å˜
                        element.angle += element.speed * element.direction;
                        if (Math.abs(element.angle) > element.maxAngle) {
                            element.direction *= -1;
                        }
                        
                        ctx.save();
                        ctx.translate(element.x + element.width / 2, element.y + element.height / 2);
                        ctx.rotate(element.angle * Math.PI / 180);
                        
                        // ç»˜åˆ¶èˆ¹ä½“
                        ctx.fillStyle = '#5D4037';
                        ctx.beginPath();
                        ctx.moveTo(-element.width / 2, -element.height / 2 + 30);
                        ctx.lineTo(element.width / 2, -element.height / 2 + 30);
                        ctx.lineTo(element.width / 2 + 20, 0);
                        ctx.lineTo(element.width / 2, element.height / 2);
                        ctx.lineTo(-element.width / 2, element.height / 2);
                        ctx.lineTo(-element.width / 2 - 20, 0);
                        ctx.closePath();
                        ctx.fill();
                        
                        // èˆ¹ä½“è£…é¥°
                        ctx.fillStyle = '#8D6E63';
                        ctx.fillRect(-element.width / 2 - 5, -element.height / 2 + 30, element.width + 10, 10);
                        ctx.fillRect(-element.width / 2 - 5, element.height / 2 - 15, element.width + 10, 10);
                        
                        // èˆ¹èˆ±
                        ctx.fillStyle = '#3E2723';
                        ctx.fillRect(-element.width / 4, -element.height / 2 + 45, element.width / 2, 30);
                        
                        // èˆ¹èˆ±çª—æˆ·
                        ctx.fillStyle = '#FFF59D';
                        for (let j = 0; j < 3; j++) {
                            ctx.fillRect(
                                -element.width / 4 + 10 + j * 20, 
                                -element.height / 2 + 55, 
                                10, 
                                10
                            );
                        }
                        
                        // æ¡…æ† - ç¨å¾®åŠ ç²—
                        ctx.fillStyle = '#5D4037';
                        ctx.fillRect(-8, -element.height / 2 + 40, 16, -element.mastHeight);
                        
                        // å¤šä¸ªæ¨ªæ†ï¼Œå¢åŠ çœŸå®æ„Ÿ
                        ctx.fillStyle = '#5D4037';
                        // ä¸»æ¨ªæ†
                        ctx.fillRect(-element.sailWidth / 2 - 10, -element.height / 2 - 30, element.sailWidth + 20, 8);
                        // æ¬¡æ¨ªæ†
                        ctx.fillRect(-element.sailWidth / 2 - 5, -element.height / 2 - 80, element.sailWidth + 10, 6);
                        // é¡¶éƒ¨æ¨ªæ†
                        ctx.fillRect(-element.sailWidth / 3, -element.height / 2 - element.sailHeight - 10, element.sailWidth * 2/3, 5);
                        
                        // ç»˜åˆ¶æ›´è‡ªç„¶çš„ä¸»å¸†
                        ctx.fillStyle = '#E3D7C8'; // ç•¥å¾®ç±³é»„è‰²çš„å¸†å¸ƒè‰²
                        
                        // é£å¹åŠ¨çš„å¸†å½¢çŠ¶ - ä½¿ç”¨è´å¡å°”æ›²çº¿åˆ›å»ºæ›´è‡ªç„¶çš„å¼§åº¦
                        ctx.beginPath();
                        // å¸†çš„å·¦ä¸Šè§’
                        ctx.moveTo(-element.sailWidth / 2 - 5, -element.height / 2 - 30);
                        
                        // å¸†çš„å·¦ä¾§æ›²çº¿ - æ¨¡æ‹Ÿé£å¹èµ·çš„å¼§åº¦
                        ctx.bezierCurveTo(
                            -element.sailWidth / 2 + 10, -element.height / 2 - 60, // æ§åˆ¶ç‚¹1
                            -element.sailWidth / 3, -element.height / 2 - 100,     // æ§åˆ¶ç‚¹2
                            -element.sailWidth / 4, -element.height / 2 - element.sailHeight - 5 // ç»ˆç‚¹
                        );
                        
                        // å¸†çš„é¡¶éƒ¨
                        ctx.lineTo(element.sailWidth / 4, -element.height / 2 - element.sailHeight - 5);
                        
                        // å¸†çš„å³ä¾§æ›²çº¿
                        ctx.bezierCurveTo(
                            element.sailWidth / 3, -element.height / 2 - 100,      // æ§åˆ¶ç‚¹1
                            element.sailWidth / 2 - 10, -element.height / 2 - 60,  // æ§åˆ¶ç‚¹2
                            element.sailWidth / 2 + 5, -element.height / 2 - 30    // ç»ˆç‚¹
                        );
                        
                        // å¸†çš„åº•éƒ¨
                        ctx.lineTo(-element.sailWidth / 2 - 5, -element.height / 2 - 30);
                        ctx.closePath();
                        ctx.fill();
                        
                        // å¸†çš„é˜´å½±æ•ˆæœï¼Œå¢åŠ ç«‹ä½“æ„Ÿ
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                        ctx.beginPath();
                        ctx.moveTo(-element.sailWidth / 2 - 5, -element.height / 2 - 30);
                        ctx.bezierCurveTo(
                            -element.sailWidth / 2 + 10, -element.height / 2 - 60,
                            -element.sailWidth / 3, -element.height / 2 - 100,
                            -element.sailWidth / 4, -element.height / 2 - element.sailHeight - 5
                        );
                        ctx.lineTo(0, -element.height / 2 - element.sailHeight + 10);
                        ctx.lineTo(0, -element.height / 2 - 30);
                        ctx.closePath();
                        ctx.fill();
                        
                        // å¸†ä¸Šçš„ç¼çº¿
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                        ctx.lineWidth = 1;
                        for (let j = 1; j < 4; j++) {
                            const y = -element.height / 2 - 30 - (j * element.sailHeight / 4);
                            ctx.beginPath();
                            ctx.moveTo(-element.sailWidth / 2 + (j * 5), y);
                            ctx.lineTo(element.sailWidth / 2 - (j * 5), y);
                            ctx.stroke();
                        }
                        
                        // ç»˜åˆ¶æ¬¡å¸†
                        ctx.fillStyle = '#E3D7C8';
                        ctx.beginPath();
                        // æ¬¡å¸†çš„é¡¶éƒ¨è¿æ¥ç‚¹
                        ctx.moveTo(0, -element.height / 2 - 80);
                        // æ¬¡å¸†çš„å³ä¸Šè§’
                        ctx.lineTo(element.sailWidth / 3, -element.height / 2 - 80);
                        // æ¬¡å¸†çš„å³ä¸‹è§’
                        ctx.lineTo(element.sailWidth / 2, -element.height / 2 - 30);
                        // æ¬¡å¸†çš„å·¦ä¸‹è§’
                        ctx.lineTo(0, -element.height / 2 - 30);
                        ctx.closePath();
                        ctx.fill();
                        
                        // æ¬¡å¸†çš„é˜´å½±
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                        ctx.beginPath();
                        ctx.moveTo(0, -element.height / 2 - 80);
                        ctx.lineTo(element.sailWidth / 6, -element.height / 2 - 80);
                        ctx.lineTo(element.sailWidth / 4, -element.height / 2 - 30);
                        ctx.lineTo(0, -element.height / 2 - 30);
                        ctx.closePath();
                        ctx.fill();
                        
                        // å¸†ä¸Šçš„æµ·ç›—æ ‡å¿— - æ”¹ä¸ºå°ä¹Œé¾Ÿ
                        const turtleX = 0;
                        const turtleY = -element.height / 2 - element.sailHeight / 2 - 10;
                        
                        // ä¹Œé¾ŸèƒŒæ™¯ - ä½¿ç”¨æ¸å˜æ•ˆæœ
                        const turtleBgGradient = ctx.createRadialGradient(
                            turtleX, turtleY, 0,
                            turtleX, turtleY, 22
                        );
                        turtleBgGradient.addColorStop(0, '#008B45');
                        turtleBgGradient.addColorStop(1, '#004D26');
                        ctx.fillStyle = turtleBgGradient;
                        ctx.beginPath();
                        ctx.arc(turtleX, turtleY, 22, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ä¹Œé¾Ÿå£³ - ä½¿ç”¨æ›´è‡ªç„¶çš„å½¢çŠ¶å’Œæ¸å˜
                        const shellGradient = ctx.createRadialGradient(
                            turtleX, turtleY, 0,
                            turtleX, turtleY, 16
                        );
                        shellGradient.addColorStop(0, '#32CD32');
                        shellGradient.addColorStop(0.7, '#228B22');
                        shellGradient.addColorStop(1, '#006400');
                        ctx.fillStyle = shellGradient;
                        
                        // ç»˜åˆ¶æ›´è‡ªç„¶çš„å…­è¾¹å½¢å£³
                        ctx.beginPath();
                        ctx.moveTo(turtleX, turtleY - 16);  // é¡¶éƒ¨
                        ctx.lineTo(turtleX + 14, turtleY - 8);  // å³ä¸Š
                        ctx.lineTo(turtleX + 14, turtleY + 8);  // å³ä¸‹
                        ctx.lineTo(turtleX, turtleY + 16);  // åº•éƒ¨
                        ctx.lineTo(turtleX - 14, turtleY + 8);  // å·¦ä¸‹
                        ctx.lineTo(turtleX - 14, turtleY - 8);  // å·¦ä¸Š
                        ctx.closePath();
                        ctx.fill();
                        
                        // å£³ä¸Šçš„èŠ±çº¹ - æ›´å¤æ‚çš„å›¾æ¡ˆ
                        ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
                        ctx.lineWidth = 1.5;
                        
                        // ä¸­å¿ƒçº¿
                        ctx.beginPath();
                        ctx.moveTo(turtleX, turtleY - 16);
                        ctx.lineTo(turtleX, turtleY + 16);
                        ctx.stroke();
                        
                        // æ¨ªå‘çº¿
                        ctx.beginPath();
                        ctx.moveTo(turtleX - 14, turtleY);
                        ctx.lineTo(turtleX + 14, turtleY);
                        ctx.stroke();
                        
                        // å£³ä¸Šçš„å…­è¾¹å½¢å›¾æ¡ˆ
                        ctx.beginPath();
                        ctx.arc(turtleX, turtleY, 8, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // å£³ä¸Šçš„å°ç‚¹è£…é¥°
                        ctx.fillStyle = 'rgba(255, 255, 150, 0.8)';
                        for (let i = 0; i < 6; i++) {
                            const angle = i * Math.PI / 3;
                            const dotX = turtleX + Math.cos(angle) * 12;
                            const dotY = turtleY + Math.sin(angle) * 12;
                            ctx.beginPath();
                            ctx.arc(dotX, dotY, 1.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // ä¹Œé¾Ÿå¤´ - æ›´è‡ªç„¶çš„å½¢çŠ¶
                        ctx.fillStyle = '#3CB371';
                        ctx.beginPath();
                        ctx.ellipse(turtleX + 16, turtleY, 6, 4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ä¹Œé¾Ÿçœ¼ç› - æ·»åŠ ç™½è‰²éƒ¨åˆ†
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(turtleX + 18, turtleY - 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(turtleX + 19, turtleY - 2, 1, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ä¹Œé¾Ÿå˜´å·´
                        ctx.strokeStyle = '#663300';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(turtleX + 20, turtleY);
                        ctx.lineTo(turtleX + 22, turtleY);
                        ctx.stroke();
                        
                        // ä¹Œé¾Ÿå››è‚¢ - æ›´è‡ªç„¶çš„æ¤­åœ†å½¢
                        ctx.fillStyle = '#3CB371';
                        
                        // å‰è‚¢
                        ctx.beginPath();
                        ctx.ellipse(turtleX + 10, turtleY - 12, 5, 3, Math.PI/4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.ellipse(turtleX + 10, turtleY + 12, 5, 3, -Math.PI/4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // åè‚¢
                        ctx.beginPath();
                        ctx.ellipse(turtleX - 10, turtleY - 12, 5, 3, -Math.PI/4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.ellipse(turtleX - 10, turtleY + 12, 5, 3, Math.PI/4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ä¹Œé¾Ÿå°¾å·´ - æ›´è‡ªç„¶çš„æ›²çº¿
                        ctx.strokeStyle = '#3CB371';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(turtleX - 14, turtleY);
                        ctx.quadraticCurveTo(
                            turtleX - 18, turtleY,
                            turtleX - 20, turtleY + 2
                        );
                        ctx.stroke();
                        
                        ctx.restore();
                        break;
                        
                    case 'wave':
                        // æ³¢æµªä»£ç ä¿æŒä¸å˜
                        element.offset += element.speed;
                        
                        ctx.fillStyle = 'rgba(65, 105, 140, 0.7)';
                        ctx.beginPath();
                        ctx.moveTo(element.x, element.y);
                        
                        for (let x = 0; x <= element.width; x += 5) {
                            const waveHeight = Math.sin(x * 0.05 + element.offset + frameCount * 0.05) * 5;
                            ctx.lineTo(element.x + x, element.y + waveHeight);
                        }
                        
                        ctx.lineTo(element.x + element.width, element.y + element.height);
                        ctx.lineTo(element.x, element.y + element.height);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.fillStyle = 'rgba(200, 230, 255, 0.5)';
                        for (let x = 0; x < element.width; x += 20) {
                            const foamX = element.x + x + Math.sin(frameCount * 0.05 + x) * 5;
                            const foamY = element.y + Math.sin(x * 0.05 + element.offset + frameCount * 0.05) * 5;
                            const foamSize = 2 + Math.sin(frameCount * 0.1 + x * 0.1) * 2;
                            
                            ctx.beginPath();
                            ctx.arc(foamX, foamY, foamSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                }
            }
        }

        // åœ¨showMilestoneNotificationå‡½æ•°é™„è¿‘æ·»åŠ æˆ–ä¿®æ”¹
        function showMilestoneNotification(text, color = "#ffcc00") {
            milestoneNotification.textContent = text;
            milestoneNotification.style.color = color;
            milestoneNotification.style.opacity = 1;
            
            
            // 3ç§’åéšè—é€šçŸ¥
            setTimeout(() => {
                milestoneNotification.style.opacity = 0;
            }, 3000);
        }
    </script>

    <!-- æ·»åŠ è¿™ä¸ªè„šæœ¬åˆ°é¡µé¢åº•éƒ¨ï¼Œç”¨äºè°ƒæ•´æ–‡æœ¬å†…å®¹ -->
    <script>
        // ç­‰å¾…DOMå®Œå…¨åŠ è½½
        window.addEventListener('DOMContentLoaded', function() {
            // æ·»åŠ ï¼šåŠ è½½åœ°å›¾è§£é”çŠ¶æ€
            const savedMapStatus = localStorage.getItem('mapUnlocked');
            if (savedMapStatus) {
                try {
                    mapUnlocked = JSON.parse(savedMapStatus);
                } catch (e) {
                    mapUnlocked = {
                    initialMap: true,
                    newMap: false
                    };
                }
            } else {
                mapUnlocked = {
                initialMap: true,
                newMap: false
                };
            }

            // ä¿®æ”¹æ¸¸æˆè¯´æ˜æ–‡å­—å†…å®¹å’Œæ¢è¡Œ
            const instructionsElements = document.querySelectorAll('.instructions');
            instructionsElements.forEach(function(element) {
                if (element.innerHTML.includes('ä¸å°ä¹å°èŒ¶ä¸€èµ·å¥”è·‘')) {
                    element.innerHTML = 'ä¸å°ä¹å°èŒ¶ä¸€èµ·å¥”è·‘ï¼Œ<br>è·³è¿‡éšœç¢ï¼Œèµ¢å¾—é‡‘ç‰Œï¼<br><span style="color: var(--accent-light);">ç©ºæ ¼é”®/ç‚¹å‡»å±å¹•</span> è¿›è¡Œè·³è·ƒ';
                }
            });
            
            // ç¡®ä¿å¼€å§‹æŒ‰é’®æ–‡æœ¬ä¸ä¼šæ¢è¡Œ
            const startBtn = document.getElementById('start-btn');
            if (startBtn) {
                startBtn.style.whiteSpace = 'nowrap';
            }
            
            // ç¡®ä¿é‡æ–°å¼€å§‹æŒ‰é’®æ–‡æœ¬ä¸ä¼šæ¢è¡Œ
            const restartBtn = document.getElementById('restart-btn');
            if (restartBtn) {
                restartBtn.style.whiteSpace = 'nowrap';
            }
        });

        // é¡µé¢åŠ è½½å®Œæˆåæ£€æŸ¥ç½²å
        window.addEventListener('load', function() {
            // å¦‚æœå·²ç»æœ‰æ¸¸æˆç»“æŸç”»é¢æ˜¾ç¤ºï¼Œä¿®å¤å…¶ä¸­çš„ç½²å
            fixAuthorCredit();
            
            // ç›‘å¬æ¸¸æˆç»“æŸäº‹ä»¶ï¼ˆå½“æ¸¸æˆç»“æŸç•Œé¢æ˜¾ç¤ºæ—¶ï¼‰
            const gameOverObserver = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.attributeName === 'style' && 
                        mutation.target.style.display === 'flex') {
                        fixAuthorCredit();
                    }
                });
            });
            
            const gameOverElement = document.getElementById('game-over');
            if (gameOverElement) {
                gameOverObserver.observe(gameOverElement, { attributes: true });
            }
        });

        // ä¿®å¤ç½²åå‡½æ•°
        function fixAuthorCredit() {
            const gameOverScreen = document.getElementById('game-over');
            if (gameOverScreen) {
                // æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½æ˜¯ç½²åçš„å…ƒç´ 
                const authorElements = gameOverScreen.querySelectorAll('div[style*="margin-top: 15px"], .author-credit');
                authorElements.forEach(function(element) {
                    if (element.textContent.includes('BYï¼šåˆº')) {
                        element.className = 'author-credit';
                        element.style.marginTop = '20px';
                        element.style.marginBottom = '15px';
                        element.style.position = 'relative';
                        element.style.width = '100%';
                        element.style.textAlign = 'center';
                        element.style.padding = '5px 0';
                        element.style.whiteSpace = 'nowrap';
                        element.style.overflow = 'visible';
                    }
                });
            }
        }

// ç¡®ä¿localStorageå’Œwindow.characterUnlockedåŒæ­¥ï¼Œå¹¶å®æ—¶æ›´æ–°UI
(function() {
    // åœ¨é¡µé¢åŠ è½½æ—¶æ‰§è¡Œ
    document.addEventListener('DOMContentLoaded', function() {
        // ä»localStorageåŠ è½½è§£é”çŠ¶æ€
        const savedStatus = localStorage.getItem('characterUnlocked');
        if (savedStatus) {
            try {
                window.characterUnlocked = JSON.parse(savedStatus);
            } catch (e) {
                window.characterUnlocked = { 'sprite': true, 'sprite02': false };
            }
        } else {
            window.characterUnlocked = { 'sprite': true, 'sprite02': false };
        }
        
        // è¦†ç›–ä¿å­˜å‡½æ•°
        window.saveUnlockStatus = function() {
            localStorage.setItem('characterUnlocked', JSON.stringify(window.characterUnlocked));
        };
    });
    
    // å¼ºåˆ¶æ›´æ–°UIå‡½æ•°
    function forceUpdateUI() {
        if (window.characterUnlocked && window.characterUnlocked.sprite02) {
            const characterElement = document.querySelector('.character-option[data-character="sprite02"]');
            if (!characterElement) return;
            
            characterElement.classList.remove('locked');
            
            const previewElement = characterElement.querySelector('.character-preview');
            if (previewElement) {
                previewElement.innerHTML = `<img src="xinjueseyulan.png" style="width: 100%; height: 100%; object-fit: contain; filter: none;">`;
            }
            
            const nameElement = characterElement.querySelector('.character-name');
            if (nameElement) nameElement.textContent = 'å°å˜å°å“';
            
            const hintElement = characterElement.querySelector('.unlock-hint');
            if (hintElement) hintElement.remove();
        }
    }

    // å¢å¼ºgameOverå‡½æ•°
    const originalGameOver = window.gameOver;
    window.gameOver = function() {
        originalGameOver.apply(this, arguments);
        if (window.characterUnlocked && window.characterUnlocked.sprite02) {
            setTimeout(forceUpdateUI, 500);
        }
    };

    // å¢å¼ºhandleGMCommandå‡½æ•°
    const originalHandleGMCommand = window.handleGMCommand;
    window.handleGMCommand = function(key) {
        originalHandleGMCommand.apply(this, arguments);
        if ((key === 'g' || key === 'G') && window.characterUnlocked && window.characterUnlocked.sprite02) {
            setTimeout(forceUpdateUI, 500);
        }
    };
})();
    </script>
</body>
</html>